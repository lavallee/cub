# Itemized Plan: 2026 02 03

> Source: [2026-02-03.md](2026-02-03.md)
> Generated: 2026-02-04

## Context Summary
Tasks generated from punchlist: 2026-02-03.md

---

## Epic: cub-t44 - 2026 02 03
Priority: 2
Labels: punchlist, punchlist:2026-02-03

Punchlist tasks from: 2026-02-03.md

### Task: cub-t44.1 - Fix statusline to support JSONL task backend
Priority: 2
Labels: punchlist

**Context**: The statusline script hardcodes reading task counts from the Beads backend (`.beads/issues.jsonl`) and ignores the JSONL backend (`.cub/tasks.jsonl`). This causes projects using the JSONL backend to show 0/0/0 task counts in their statusline, providing no visibility into task progress. The fix should detect the available backend at runtime using the same logic as the core tasks module, ensuring statusline works consistently across both backends.

**Implementation Steps**:
1. Examine `src/cub/core/tasks/backend.py` to understand the `get_backend()` detection logic and how it determines which backend is available
2. Review `templates/scripts/statusline.py` line 35 and surrounding code to understand the current hardcoded Beads path
3. Import or replicate the backend detection logic in statusline.py
4. Update the task count reading code to use the detected backend instead of hardcoding `.beads/issues.jsonl`
5. Test with both Beads and JSONL backends to verify task counts display correctly

**Acceptance Criteria**:
- [ ] Statusline detects and reads from JSONL backend (`.cub/tasks.jsonl`) when Beads backend is not available
- [ ] Statusline still reads from Beads backend (`.beads/issues.jsonl`) when it exists
- [ ] Task counts display correctly (non-zero) for projects using JSONL backend
- [ ] No existing Beads backend functionality is broken
- [ ] Detection logic matches the approach used in `cub.core.tasks.backend.get_backend()`

---

### Task: cub-t44.2 - Add explicit project_id to prevent task ID prefix collisions
Priority: 2
Labels: punchlist

**Context**: The current `_get_prefix()` method in jsonl.py derives task ID prefixes from the first 3 characters of the project directory name, causing collisions when multiple projects share the same prefix (e.g., both "cub" and "cub-roundabout" get prefix "cub"). This results in task IDs like `cub-a1x` in the roundabout project instead of the intended `rou-a1x`, making task IDs non-unique across projects. The fix requires adding an explicit `project_id` setting to `.cub/config.json` that persists a unique prefix, with `cub init` prompting users to set or auto-generating one if not provided.

**Implementation Steps**:
1. Modify `.cub.json` template to include a `project_id` field with a unique prefix (auto-generated if not provided during init)
2. Update `src/cub/cli/init_cmd.py` to prompt for or auto-generate a project_id during initialization, ensuring uniqueness
3. Update `src/cub/core/tasks/jsonl.py::_get_prefix()` to read the project_id from config instead of deriving from directory name
4. Update config loading in `src/cub/core/config/loader.py` to handle the new `project_id` field
5. Add migration logic to detect old projects without `project_id` and auto-populate based on directory name on first use
6. Update tests to verify prefix comes from config, not directory name

**Acceptance Criteria**:
- [ ] `cub init` prompts for or auto-generates unique `project_id` and stores it in `.cub/config.json`
- [ ] Task IDs use the configured `project_id` prefix instead of directory name
- [ ] Existing projects without `project_id` migrate gracefully on first use
- [ ] Multiple projects with overlapping names (e.g., "cub" and "cub-roundabout") get distinct task ID prefixes
- [ ] All tests pass and cover prefix generation from config vs. directory name scenarios

---

### Task: cub-t44.3 - Consolidate AGENTS.md and CLAUDE.md into single source
Priority: 2
Labels: punchlist

**Context**: The `cub init` command currently generates both AGENTS.md and CLAUDE.md as separate files with identical content, creating maintenance burden and risk of drift. This violates DRY principle and causes confusion about which file is canonical. The solution is to generate CLAUDE.md as the single source of truth and create AGENTS.md as a symlink, ensuring consistency across the codebase and simplifying future updates.

**Implementation Steps**:
1. Examine current implementation in `src/cub/cli/init_cmd.py` and `src/cub/core/instructions.py` to understand how both files are currently generated
2. Modify `src/cub/core/instructions.py` to have a single template/function that generates CLAUDE.md content
3. Update `src/cub/cli/init_cmd.py` to write CLAUDE.md and create AGENTS.md as a symlink pointing to CLAUDE.md instead of generating duplicate content
4. Handle edge cases: Windows (symlinks require admin/developer mode), existing files (backup if needed), and git tracking (ensure .gitignore doesn't prevent symlink tracking)
5. Add tests to verify symlink creation and content consistency between the two logical references

**Acceptance Criteria**:
- [ ] CLAUDE.md is generated with full content from single source
- [ ] AGENTS.md exists as symlink to CLAUDE.md (not duplicate file)
- [ ] `cub init` creates both files without errors on Linux/macOS
- [ ] Symlink points to correct relative path (readable from `.cub/` directory)
- [ ] Existing tests pass and no duplicate content generation remains
- [ ] Documentation updated to reflect CLAUDE.md as canonical file

---

### Task: cub-t44.4 - Consolidate runloop.md and PROMPT.md initialization
Priority: 2
Labels: punchlist

**Context**: The project creates two overlapping system prompt files during init (`.cub/runloop.md` and `.cub/prompt.md`), creating confusion about their purpose and proper usage. The runloop.md contains core loop instructions while PROMPT.md is a larger template with customization guidance. This dual-file approach leads to unclear ownership: cub stage should not modify prompt.md, but instead plan-level context should be injected at runtime. Clear separation between system-managed core runloop instructions and user-customizable additions is needed to prevent improper file mutations and enable proper prompt composition.

**Implementation Steps**:
1. Audit current usage: Review how init_cmd.py creates both files, how prompt.md is generated, and where prompt.md is referenced/mutated (especially in cub stage)
2. Define file roles: Establish that `runloop.md` = system-managed core loop instructions (immutable by features), `prompt.md` = user-customizable additions or consider removal if redundant
3. Create plan-level context: Introduce pattern for capturing plan-scoped system context (e.g., `plan-prompt-context.md` in plan directories) that gets injected at runtime rather than persisted globally
4. Update init_cmd.py: Create only the primary file (runloop.md), remove prompt.md generation unless there's clear use case for user customization zone
5. Remove prompt.md mutations: Audit codebase for code that writes to prompt.md (especially cub stage) and replace with plan-directory context mechanism
6. Update CLAUDE.md: Document final file structure, roles, and context composition hierarchy (system runloop → user prompt.md if kept → plan context at runtime)

**Acceptance Criteria**:
- [ ] Only one system prompt template file is generated during init (runloop.md, clearly labeled for system use)
- [ ] Prompt.md is either removed or explicitly designated as user-customizable zone with clear ownership
- [ ] No code writes to prompt.md during feature/stage execution (context composition happens at runtime instead)
- [ ] Plan-level context follows a standard pattern (e.g., `plans/<name>/prompt-context.md`) that is injected into harness sessions
- [ ] CLAUDE.md section on "Context Composition" clearly explains: system runloop → optional user additions → plan context grafting at runtime
- [ ] All tests pass and init command still generates functional system prompts

---

### Task: cub-t44.5 - Consolidate config files into single .cub/config.json
Priority: 2
Labels: punchlist

**Context**: The project has two config files with overlapping purposes: `.cub.json` (project root) for user settings like harness and budget, and `.cub/config.json` (internal state) for dev_mode flags. This split is confusing for users who don't know which file to edit. Consolidating all config into `.cub/config.json` simplifies the mental model, reduces maintenance burden, and makes configuration self-discoverable in the `.cub/` directory structure.

**Implementation Steps**:
1. Audit current config usage in `src/cub/core/config/loader.py` to identify all fields in `.cub.json` and `.cub/config.json`, document which are user-facing vs internal
2. Design unified config schema in `.cub/config.json` with clear separation between user settings (harness, budget, state checks) and internal state (dev_mode, etc.) via top-level sections
3. Update `src/cub/cli/init_cmd.py` to write all config to `.cub/config.json` and stop creating `.cub.json`
4. Update `src/cub/core/config/loader.py` to read from `.cub/config.json` with fallback to `.cub.json` for backwards compatibility, issue deprecation warning if `.cub.json` is found
5. Update template in `src/cub/templates/.cub.json` to add migration note or convert to `.cub/config.json` template
6. Add migration logic to detect existing `.cub.json` files and warn users to run `cub init` to consolidate
7. Write tests for backwards-compatible config loading and deprecation warnings
8. Update CLAUDE.md documentation to explain the consolidated config structure

**Acceptance Criteria**:
- [ ] All config read/write operations use `.cub/config.json` as primary location
- [ ] `.cub.json` is read for backwards compatibility with deprecation warning logged
- [ ] `cub init` creates only `.cub/config.json`, no `.cub.json`
- [ ] Unified config schema documented with clear user vs internal sections
- [ ] Migration path works: existing `.cub.json` projects are readable and warned to consolidate
- [ ] All tests pass including new backwards-compatibility tests
- [ ] mypy passes in strict mode
- [ ] CLAUDE.md updated with config structure and consolidation rationale

---

### Task: cub-t44.6 - Enhance agent.md template with richer cub workflow documentation
Priority: 2
Labels: punchlist

**Context**: The current `templates/agent.md` provides functional setup instructions but lacks comprehensive guidance for developers using cub effectively during sessions. It misses quick-start workflows, common command patterns, troubleshooting resources, and pointers to diagnostic tools like hook logs. Enriching this template will improve developer experience by providing self-contained guidance within each project's agent context, reducing friction when switching between projects and enabling better autonomous coding sessions.

**Implementation Steps**:
1. Review current `templates/agent.md` and identify gaps in workflow guidance
2. Add a "Quick Start Workflow" section covering task discovery, claiming, and completion patterns
3. Add a "Common Command Patterns" section with practical examples of cub task, status, and suggest commands
4. Add a "Troubleshooting" section including hook verification, forensics log locations (.cub/ledger/forensics/), and common issues
5. Add a "Reading Task Output" section explaining task metadata, blockers, and dependencies
6. Add cross-references to full documentation with @.cub/agent.md links and cub docs pointers
7. Ensure template preserves the existing structure and remains under ~500 lines total
8. Test that generated CLAUDE.md files in new projects include the enhanced content

**Acceptance Criteria**:
- [ ] Template includes a "Quick Start Workflow" section with 3-5 key steps for claiming and completing tasks
- [ ] Template includes "Common Command Patterns" with at least 5 real-world command examples
- [ ] Template includes "Troubleshooting" section with hook verification and forensics log location (.cub/ledger/forensics/)
- [ ] Template includes "Reading Task Output" section explaining task metadata interpretation
- [ ] All sections reference external docs or .cub/ files appropriately using @-syntax
- [ ] Template remains well-organized and under ~500 lines (excluding existing architecture sections)
- [ ] Generated CLAUDE.md files in new projects (`cub new`) include the enhanced content
- [ ] mypy and ruff pass with no changes needed to template file itself

---

### Task: cub-t44.7 - Expand constitution.md template with principles and examples
Priority: 2
Labels: punchlist

**Context**: The constitution.md template currently provides minimal guidance, making it difficult for projects to establish meaningful engineering principles. This feature adds detailed principle examples, code pattern comparisons (good vs. bad), and step-by-step customization guidance so projects can create constitutions aligned with their specific values and constraints.

**Implementation Steps**:
1. Read the current constitution.md template to understand its structure
2. Expand the principles section with 4-5 example principles (testing, performance, security, documentation, collaboration) including descriptions and rationale
3. Add "Good Pattern vs. Bad Pattern" subsections showing concrete code examples for each principle
4. Create a "Customizing for Your Project" section with step-by-step guidance on identifying and defining custom principles
5. Add an "Anti-patterns to Avoid" section documenting common pitfalls when establishing engineering culture
6. Include a "Living Document" section explaining how to evolve the constitution over time
7. Verify template formatting, ensure markdown is valid, and check for clarity

**Acceptance Criteria**:
- [ ] Template contains at least 4 detailed example principles with rationale
- [ ] Each example principle includes a "Good Pattern" and "Bad Pattern" code example
- [ ] "Customizing for Your Project" section provides 3+ concrete customization steps
- [ ] Template includes guidance on anti-patterns and common mistakes
- [ ] All changes are backwards compatible (existing constitution.md files still valid)
- [ ] Template is under 500 lines and remains readable and not overwhelming
- [ ] No broken markdown links or formatting issues

---

### Task: cub-t44.8 - Create cub:stage skill template
Priority: 2
Labels: punchlist

**Context**: The `cub stage` command exists in the CLI but lacks a corresponding skill definition in `templates/commands/`. Without this file, the skill won't appear in the skill list and users can't invoke it via `/stage`. This is a documentation/discoverability gap that prevents users from easily accessing the stage command through the skill interface.

**Implementation Steps**:
1. Research the `cub stage` command implementation to understand its purpose, arguments, and behavior
2. Examine existing skill templates in `templates/commands/` to understand the expected format and structure
3. Create `src/cub/templates/commands/cub:stage.md` following the established skill template pattern
4. Document the command's purpose, usage examples, and any relevant flags or options
5. Verify the skill file is properly formatted and references the correct CLI command

**Acceptance Criteria**:
- [ ] `src/cub/templates/commands/cub:stage.md` file created with complete skill definition
- [ ] Skill template follows the same format and structure as other command skills
- [ ] Skill description accurately represents the `cub stage` command functionality
- [ ] Documentation includes purpose, syntax, examples, and relevant options
- [ ] Skill can be invoked via `/stage` and appears in skill list when available

---

### Task: cub-t44.9 - Document hook forensics location and add log viewing
Priority: 2
Labels: punchlist

**Context**: Hook forensics are written to `.cub/ledger/forensics/{session_id}.jsonl` but users have no way to discover this location or view recent activity. This makes troubleshooting sessions difficult and leaves the feature undocumented. Adding clear documentation to the agent.md template and a `cub hooks log` command to view recent forensics would improve discoverability and usability of the symbiotic workflow feature.

**Implementation Steps**:
1. Add "Hook Forensics Location" section to the Symbiotic Workflow documentation in agent.md, explaining the forensics JSONL format, location, and example contents
2. Document the forensics JSONL schema (event types, fields, timestamps) so users understand what data is captured
3. Implement `cub hooks log` command in src/cub/cli/hooks.py to display recent hook events with options for filtering by session, event type, and time range
4. Add usage examples to agent.md showing how to use `cub hooks log` for troubleshooting

**Acceptance Criteria**:
- [ ] agent.md documents the exact path where forensics are stored (`.cub/ledger/forensics/{session_id}.jsonl`)
- [ ] agent.md includes example forensics JSONL showing 3-4 event types (session_start, file_write, task_claim, session_end)
- [ ] `cub hooks log` command exists and displays recent forensics entries with timestamps and event details
- [ ] `cub hooks log` supports `--session <id>` flag to filter by specific session
- [ ] `cub hooks log` supports `--limit <n>` flag to show last N events (default 20)
- [ ] Help text and docstrings clearly explain forensics are auto-generated by hooks and not user-editable
- [ ] Troubleshooting section in agent.md references `cub hooks log` as a diagnostic tool

---

### Task: cub-t44.10 - Fix plan.json generation through planning pipeline
Priority: 2
Labels: punchlist

**Context**: The planning workflow (`cub plan orient`, `cub plan architect`, `cub plan itemize`) fails to properly generate and update plan.json at each phase, breaking the downstream `cub stage` command which depends on reading a complete plan.json file. This blocks the entire planning-to-tasks pipeline. The issue spans multiple phases and requires auditing each command to ensure plan.json is created on first phase, updated by subsequent phases, and in a format that `cub stage` can consume.

**Implementation Steps**:
1. Audit `cub plan orient` command to ensure it creates `.cub/sessions/{session}/plan.json` with orient-phase output
2. Audit `cub plan architect` command to ensure it reads the existing plan.json and appends/updates architect-phase output
3. Audit `cub plan itemize` command to ensure it reads the existing plan.json and appends/updates itemize-phase output
4. Verify plan.json schema is consistent and readable by `cub stage` at each phase
5. Add integration test covering the full pipeline: orient → architect → itemize → stage
6. Fix any serialization, path resolution, or state accumulation bugs discovered

**Acceptance Criteria**:
- [ ] `cub plan orient` creates `.cub/sessions/{session}/plan.json` with valid output
- [ ] `cub plan architect` reads and updates plan.json without losing orient data
- [ ] `cub plan itemize` reads and updates plan.json without losing previous phase data
- [ ] `cub stage` successfully reads plan.json and imports tasks after full pipeline
- [ ] plan.json schema is documented and validated at each phase
- [ ] Full pipeline integration test passes (orient → architect → itemize → stage)

---

### Task: cub-t44.11 - Set explicit backend in cub init instead of auto-detection
Priority: 2
Labels: punchlist

**Context**: Currently, `cub init` relies on auto-detection to determine the task backend, which checks for `.beads/` before `.cub/tasks.jsonl`. This can lead to unexpected behavior when both directories exist or when the detection order doesn't match user intent. By explicitly setting `backend.mode` in the config during initialization, we ensure predictable and transparent backend selection. This also makes it easier for users to understand and modify their backend choice later.

**Implementation Steps**:
1. Read the current `init_cmd.py` implementation to understand the config writing logic
2. Modify the initialization to write an explicit `"backend": {"mode": "jsonl"}` to the config (or prompt user to choose between available backends)
3. Update config model validation to accept and respect the explicit `backend.mode` setting
4. Verify that downstream code respects the explicit setting over auto-detection
5. Test that `cub init` correctly sets the backend and subsequent commands use the configured backend
6. Update documentation/comments to reflect that backend is now explicitly configured

**Acceptance Criteria**:
- [ ] `cub init` writes `"backend": {"mode": "jsonl"}` (or user-selected mode) to config
- [ ] Config model validation accepts and preserves the explicit `backend.mode` setting
- [ ] Backend loading logic respects explicit config setting over auto-detection
- [ ] All existing tests pass; add tests verifying explicit backend configuration
- [ ] Running `cub init` followed by `cub task list` uses the configured backend, not auto-detection

---

### Task: cub-t44.12 - Preserve user-modified prompt.md on init
Priority: 2
Labels: punchlist

**Context**: The `cub init` command currently overwrites prompt.md unconditionally, destroying user customizations. Since prompt.md is intended to be user-customizable (as documented in CLAUDE.md's context composition section), this breaks the workflow where users tailor the autonomous coding experience for their project. The fix should detect when prompt.md has been modified and either skip overwriting it or prompt the user to choose.

**Implementation Steps**:
1. Read the template prompt.md from the package templates directory
2. Check if prompt.md already exists in the project root
3. If it exists, compare the user's version with the template version (byte-for-byte or hash-based comparison)
4. If they differ, either: (a) skip the write with a log message, or (b) prompt the user with options to keep/replace/review
5. Only write the template if the file doesn't exist or the user explicitly approves overwriting
6. Add clear logging to indicate which action was taken (skipped, wrote, or prompted)

**Acceptance Criteria**:
- [ ] prompt.md is not overwritten if it exists and differs from the template
- [ ] User is informed when prompt.md is skipped (log message or prompt)
- [ ] User can choose to overwrite if prompted (e.g., via `--force` flag or interactive prompt)
- [ ] prompt.md is still created on first init (file doesn't exist yet)
- [ ] All changes tested with pytest (existing tests updated if needed)
- [ ] mypy passes with no errors
- [ ] Documentation in CLAUDE.md accurately reflects the behavior

---
