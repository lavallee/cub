# Punchlist: v0.27.0-bugs

## Auto-close epic when all tasks complete

When `cub run --epic <epic-id>` finishes, check if all tasks for that epic are completed/closed. If so, automatically close the epic itself through the task backend interface.

**Context:**
Currently, epics remain open even after all their constituent tasks are completed. This requires manual closure and creates inconsistency in task state tracking.

**Acceptance Criteria:**
- After `cub run --epic <epic-id>` completes, query the task backend for all tasks belonging to that epic
- If all tasks have status `completed` or `closed`, automatically close the epic
- Use the task backend interface (protocol) for all operations, not direct Beads/JSON access
- Handle cases where the backend doesn't support epic closure gracefully (no-op or appropriate logging)
- Add tests covering: all tasks complete (epic closes), some tasks pending (epic stays open), mixed states
- Update CLI output to indicate when an epic was auto-closed

---

## Auto-close epics with no incomplete tasks

The `cub doctor` command should identify epics that have no remaining open or in-progress tasks and automatically close them. This prevents stale epics from cluttering the task list after all their work is complete.

**Context:**
Epics often span multiple sessions and subtasks. When all subtasks are completed, the epic itself should be marked as closed to reflect true project status.

**Acceptance Criteria:**
- `cub doctor` detects epics where all tasks are either closed, cancelled, or skipped
- Automatically closes these epics with a message like "Auto-closed: all subtasks complete"
- Logs which epics were closed and how many
- Provides a summary of actions taken
- Does not close epics that have no tasks at all (they may be parent containers)

---

## Add --use-current-branch flag to cub run

By default, `cub run` should create a new branch off of `origin/main` (or `--from-branch` if specified) rather than allowing work in the current branch. This ensures a clean state for each run and avoids conflicts with local main which may be out of date due to beads' worktree behavior.

**Changes needed:**
- Add `--use-current-branch` flag to `cub run` command
- When flag is NOT set (default behavior):
  - Create a new branch from `origin/main` (or from the branch specified via `--from-branch`)
  - Switch to the newly created branch before running tasks
  - Branch name should follow existing naming conventions
- When flag IS set:
  - Allow `cub run` to execute in the current branch (preserves existing behavior when explicitly requested)
- Branch from `origin/main` not local `main` to account for out-of-date local main in beads worktree setups

**Acceptance criteria:**
- `cub run` creates new branch from `origin/main` by default
- `cub run --use-current-branch` works in current branch
- `cub run --from-branch <branch>` creates branch from specified branch
- `cub run --use-current-branch --from-branch <branch>` is a no-op for `--from-branch` (uses current branch)
- All existing tests pass
- mypy and ruff checks pass

---

## Fix cub:orient help text and plan output path

The `cub orient` command currently displays incorrect help text that describes the `ARGUMENTS` parameter as an output file path, when it should explain that arguments are inputs (like a spec) for the command to evaluate.

**Current Issue:**
- Help text says: "If provided, this is the path to write the output file"
- This is incorrect - `ARGUMENTS` should be input specs, not output paths

**Expected Behavior:**
- Help text should correctly describe `ARGUMENTS` as input specifications/context for the orient stage
- The command should write output to `plans/[slug]/` directory (following the standard plan storage pattern used by other planning commands)
- Output path should not be a user-provided argument

**Acceptance Criteria:**
- [ ] Help text for `cub orient` correctly describes `ARGUMENTS` as input specs (not output paths)
- [ ] Command writes plan output to `plans/[slug]/` instead of using user-provided path
- [ ] Help text is consistent with other planning commands (`architect`, `itemize`)
- [ ] Tests verify correct plan output directory

---

## Fix cub spec --list to work from project subdirectories

**Context:**
The `cub spec --list` command currently only works when run from the project root directory. Users should be able to run this command from any directory within the project and have it discover specs relative to the project root.

Additionally, the command only displays specs in the "researching" stage. Users need visibility into specs across all lifecycle stages (researching, designing, implementing, validating, completed).

**Current Behavior:**
- `cub spec --list` works only from project root
- Running from subdirectories fails or produces incorrect results
- Only shows specs in "researching" stage

**Expected Behavior:**
- `cub spec --list` works from any directory within the project
- Automatically discovers project root (via `.beads/` or `.git/`)
- Shows specs in all stages, not just "researching"
- Clear indication of each spec's current stage

**Acceptance Criteria:**
- [ ] Command locates project root from any subdirectory
- [ ] Specs are discovered relative to project root (typically `specs/`)
- [ ] Output includes specs from all lifecycle stages (researching, designing, implementing, validating, completed)
- [ ] Stage is displayed for each spec in the list output
- [ ] Works consistently whether run from root or subdirectory
- [ ] Tests cover execution from both root and subdirectory contexts

---

## Auto-execute /cub: handoff after plan stage approval

Currently, when a `cub plan` stage (orient, architect, itemize) completes and is approved by the user, the CLI just tells them to run the next command. We should:

1. **Primary goal**: Attempt to automatically execute the `/cub:` slash command handoff for the user after stage approval, so the workflow continues seamlessly without requiring manual intervention.

2. **Fallback**: If automatic execution isn't possible (e.g., due to environment constraints), update messaging to reference the `/cub:` slash command syntax instead of shell command syntax, making it clear this is Claude Code specific.

**Current behavior**: After stage approval, user sees messaging like "Run: cub plan architect" (shell syntax)

**Expected behavior**: 
- Try to invoke `/cub: plan architect` directly within Claude Code
- If that fails, show: "Run: `/cub: plan architect`" (slash command syntax)

**Acceptance criteria**:
- [ ] Plan stages (orient, architect, itemize) attempt `/cub:` handoff after approval
- [ ] Handoff passes all necessary context (plan ID, branch info, etc.)
- [ ] If handoff fails, error message references `/cub:` slash command, not shell syntax
- [ ] User gets clear feedback about whether handoff succeeded or fallback occurred
- [ ] Tests cover both success and fallback paths

---

## Fix cub pr async error handling for CI/review integration

When invoking `cub pr` to finalize work, the command fails with "Error: No messages returned" from an unhandled async rejection. This occurs when cub attempts to invoke Claude Code to manage CI checks and reviews. 

**Context:**
- The error originates from async promise rejection in the Claude Code integration layer
- The PR creation process appears to complete successfully initially, but fails during the review/CI management phase
- The unhandled async error prevents proper cleanup and user feedback

**Acceptance Criteria:**
- [ ] `cub pr` command properly catches and handles async errors from Claude Code invocation
- [ ] User receives a clear error message if review/CI invocation fails
- [ ] PR is still created/updated even if Claude Code integration fails (graceful degradation)
- [ ] No unhandled promise rejections in error logs

---

## Add --stream option to cub pr for real-time output

The `cub pr` command should support a `--stream` flag to display real-time output from the PR creation process, allowing users to see what operations are being performed. Additionally, when `--debug` is enabled, the command should surface detailed information about PR creation steps.

**Context:**
Currently, `cub pr` runs silently, making it unclear what's happening during PR creation. Users want visibility into the process without verbose logging.

**Acceptance Criteria:**
- [ ] `cub pr` accepts `--stream` flag
- [ ] When `--stream` is used, real-time output from PR creation is displayed (branch validation, PR body generation, gh API calls, etc.)
- [ ] When `--debug` is enabled, detailed diagnostic information is logged (variable values, decision points, API responses)
- [ ] Both flags work together: `cub pr <epic> --stream --debug` shows both streaming output and debug details
- [ ] Default behavior (no flags) remains silent/minimal output
- [ ] Exit codes and error handling are preserved

---

## Handle branch switch failure in cub merge

When `cub merge` executes a git merge and then attempts to switch back to the main branch, it fails if beads is active (beads may lock the branch or prevent the switch). The command should gracefully handle this failure by catching the branch switch error and leaving the user on the current branch instead of crashing.

**Context:**
- `cub merge` performs a git merge operation followed by a branch switch to main
- With beads task tracking active, the branch switch can fail
- Currently this causes the entire merge command to fail

**Acceptance Criteria:**
- `cub merge` executes the merge operation successfully
- If the subsequent branch switch to main fails, the error is caught
- User remains on the current branch (the merge source branch)
- A warning or informational message is displayed explaining why the switch was skipped
- Command exits with success (merge completed, even if final branch switch failed)

---
