

I'll start by claiming the task and understanding the codebase structure.Now let me explore the codebase in parallel to understand the existing structure:Excellent. Now let me read the actual CLI run.py to understand how it constructs dependencies and calls RunLoop:Let me continue reading the main run loop section:Now let me check the existing tests and the RunLoop constructor/execute interface more carefully:Now let me look at the RunLoop class constructor and key methods:Now let me also check existing test patterns for the run loop:Now I have a comprehensive understanding. Let me also check if there's a `core/services` directory already:Good, doesn't exist yet. Let me also check how config loading works:Now I have a thorough understanding of the codebase. Let me implement the service layer.Now let me create the RunService. I need to understand what dependencies it needs to set up:Now let me check the `get_result()` method:Good. Now I also need to understand the `get_task_backend` and `get_async_backend` patterns:Now I have a complete understanding. Let me create the RunService:Now I need to refactor `cli/run.py` to use `RunService`. The key section is around lines 1095-1265 where the main run loop is set up. I'll refactor to use `RunService.build_run_config()` and `RunService.execute()`. Let me re-read the critical section:Now I understand the CLI flow. The refactor needs to be strategic — the CLI has a LOT of setup code (branch management, worktree, sandbox, monitor, etc.) that stays in CLI. The key refactor point is the RunConfig construction and RunLoop creation/execution. I'll refactor to use `RunService` for the core loop while keeping CLI-specific concerns (branch, worktree, sandbox, Rich rendering) in the CLI.

Let me refactor the CLI to use `RunService`. The main section to refactor is lines 1095-1243 (harness setup through RunLoop creation). I'll replace the manual wiring with `RunService`:Now let me replace the section from "Setup harness" through "Create RunLoop" (lines 1095-1243):Now let me verify the section after the loop is still correct. The `run_loop` reference should no longer be used since we now call `run_service`. Let me check:Good - no remaining references to `run_loop`. Now let me also check there are no other direct imports of `RunLoop` in the cli/run.py (we should keep the import for backward compat but note it's now used through RunService):The import at line 42 is no longer directly used. Let me remove it:Wait - I should check if `RunLoop` is used anywhere else in the file (e.g., in `_run_direct` or other functions):Good, those are just comments, not code references. The import is safe to remove.

Now let me also verify the `InterruptHandler` import is still needed (used in the function):Good, still used.

Now let me verify the `LedgerIntegration` and `LedgerWriter` imports are still needed:Still used since the CLI still handles the initial wiring before passing to RunService. This is expected — the CLI builds the dependencies and passes them in.Now let me write the service-level integration tests:Now let me run the feedback loops. First, let me check how to run:Let me run the checks in parallel:Let me fix these issues:Now fix the test file:Now let me also fix the import sorting. Let me use ruff format to fix:Good, lint is clean. Now let me run the tests:The issue is with the mock harness backend - the `run_task` returns a MagicMock with mock `usage` field, but `HarnessResult` is a Pydantic model that validates `usage` as `TokenUsage`. I need to return a proper `HarnessResult`. Let me check:I need to update my test to return a real `HarnessResult`. Let me fix the test fixture:Now update the fixture to return the real result:Now let me check if `TokenUsage` has a `cost_usd` field:Ah, `total_tokens` is a property, not a field. Let me fix:All 24 tests pass. Now let me run the existing test suite to make sure nothing is broken:All existing tests pass. Now let me run the full lint and typecheck:The mypy errors are pre-existing (missing `types-PyYAML` stubs) and not caused by my changes. The errors are in `branches/store.py` and `ledger/writer.py`, not in my service files. Let me verify my files are clean:Clean. Let me also run a broader test to make sure cli/run.py changes don't break other tests:All 290 tests pass (1 skipped is pre-existing). Let me also format:Now close the task and commit:Now let me check if all tasks are closed:There are still many open tasks. My task (cub-b1c.1) is closed. The task is complete.Task **cub-b1c.1** is complete. Here's what was done:

## Summary

### Created: Service Layer Foundation (`cub.core.services`)

**`src/cub/core/services/__init__.py`** — Package with `RunService` export.

**`src/cub/core/services/run.py`** — `RunService` class with:
- **`from_config()`** factory — wires harness detection, task backend, ledger, sync service, interrupt handler
- **`build_run_config()`** — translates high-level params + CubConfig into `RunConfig` (mirrors CLI arg translation)
- **`execute(run_config)`** — yields `RunEvent` via generator, delegates to `RunLoop`
- **`run_once(task_id)`** — convenience for single-task execution
- **`get_result()`** — returns `RunResult` after generator exhaustion
- Typed exceptions: `RunServiceError`, `HarnessNotFoundError`, `HarnessNotAvailableError`, `TaskBackendError`

### Refactored: `src/cub/cli/run.py`
- Replaced direct `RunLoop` construction with `RunService`
- Uses `run_service.build_run_config()` instead of manual `RunConfig` construction
- Uses `run_service.execute()` instead of `run_loop.execute()`
- Removed `RunLoop` and `RunConfig` imports (no longer needed directly)

### Tests: `tests/test_service_run.py`
- **24 tests** covering constructor, factory, config builder, execution, run_once, and exceptions
- All **290 run-related tests** pass (including existing ones)