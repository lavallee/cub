{"id": "cub-k41", "title": "Harness Abstraction: Multi-Provider LLM Interface", "description": "## Context\nReplace Cub's current shell-out harness implementation with a unified abstraction layer that supports multiple LLM providers (Claude, OpenAI, Gemini, local) while enabling provider-specific features like Claude Agent SDK hooks.\n\n## Goals\n1. Unified async interface (`run_task`, `stream_task`, `supports_feature`)\n2. Claude Agent SDK for full hook and tool support\n3. Legacy shell-out harnesses preserved as fallback\n4. Graceful degradation for missing features\n\n## Success Criteria\n- [ ] AsyncHarnessBackend Protocol defined and implemented\n- [ ] Claude SDK harness with hooks and streaming\n- [ ] Legacy harnesses migrated to async interface\n- [ ] `cub run` works with new harness system\n- [ ] Tests pass for all harnesses", "status": "open", "priority": 0, "issue_type": "epic", "labels": ["harness-abstraction", "breaking-change", "async"], "dependencies": []}
{"id": "cub-k41.1", "title": "Create async harness protocol and models", "description": "## Context\nEstablish the async foundation for the new harness system without breaking existing code. This creates the core abstractions that all harnesses will implement.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 4 hours\n**Approach:** Start with models.py extensions, then create new async_backend.py. Reference existing backend.py patterns.\n\n## Implementation Steps\n1. Add `anyio` and `pytest-asyncio` to pyproject.toml dependencies\n2. Extend `HarnessCapabilities` in models.py with new fields: `hooks`, `custom_tools`, `sessions`, `session_forking`, `subagents`\n3. Add `HarnessFeature` enum to models.py for type-safe feature queries\n4. Create `TaskInput` model (distinct from beads Task) with prompt, system_prompt, working_dir, permissions, etc.\n5. Extend `TaskResult` (or create `AsyncTaskResult`) with messages, files_changed, files_created\n6. Add `Message`, `ToolUse` models for SDK message parsing\n7. Create `src/cub/core/harness/async_backend.py` with `AsyncHarnessBackend` Protocol\n8. Add async registry functions: `register_async_backend`, `get_async_backend`, `detect_async_harness`\n9. Add async wrapper to `cub run` entry point using `anyio.run()`\n\n## Acceptance Criteria\n- [ ] `anyio` and `pytest-asyncio` added to dependencies\n- [ ] `HarnessCapabilities` extended with hooks, custom_tools, sessions, session_forking, subagents\n- [ ] `HarnessFeature` enum defined with all feature flags\n- [ ] `TaskInput` model created with all fields from architecture\n- [ ] `TaskResult` extended with messages, files_changed, files_created\n- [ ] `Message` and `ToolUse` models created\n- [ ] `AsyncHarnessBackend` Protocol defined with run_task, stream_task, supports_feature\n- [ ] Async registry functions working\n- [ ] `cub run` can be invoked (even if harnesses not yet async)\n- [ ] mypy passes with strict mode\n- [ ] Existing tests still pass\n\n## Files Likely Involved\n- pyproject.toml\n- src/cub/core/harness/models.py\n- src/cub/core/harness/async_backend.py (new)\n- src/cub/core/harness/__init__.py\n- src/cub/cli/run.py\n\n## Notes\n- Keep sync `HarnessBackend` working during transition\n- Use `typing.Protocol` with `@runtime_checkable` (consistent with existing pattern)\n- TaskInput is distinct from beads Task to avoid coupling", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "setup", "model"], "dependencies": [{"depends_on_id": "cub-k41", "type": "parent-child"}]}
{"id": "cub-k41.2", "title": "Implement Claude SDK harness", "description": "## Context\nThis is the core value of the harness abstraction - a full-featured Claude harness using the Claude Agent SDK. This enables hooks, custom tools, and native streaming.\n\n## Implementation Hints\n\n**Recommended Model:** opus\n**Estimated Duration:** 6 hours\n**Approach:** Study Claude Agent SDK API first. Use `query()` for simple execution, map cub options to `ClaudeAgentOptions`. Parse SDK messages into our models.\n\n## Implementation Steps\n1. Add `claude-agent-sdk` to pyproject.toml dependencies\n2. Create `src/cub/core/harness/claude_sdk.py`\n3. Implement `ClaudeSDKHarness` class implementing `AsyncHarnessBackend`:\n   - `name` property returns \"claude\"\n   - `capabilities` property with all features enabled\n   - `is_available()` checks for SDK and Claude Code CLI\n   - `run_task()` using `claude_agent_sdk.query()`\n   - `stream_task()` using `query()` with async iteration\n   - `supports_feature()` returns True for all HarnessFeature values\n4. Map `TaskInput` to `ClaudeAgentOptions`:\n   - system_prompt -> options.system_prompt\n   - working_dir -> options.cwd\n   - auto_approve_edits/bash -> options.permission_mode\n   - max_turns -> options.max_turns\n   - model -> options.model\n5. Parse SDK messages (AssistantMessage, TextBlock, ToolUseBlock) into our `Message` and `ToolUse` models\n6. Extract token usage from SDK response into `TokenUsage`\n7. Handle SDK errors gracefully with clear error messages\n8. Register as \"claude\" backend using `@register_async_backend(\"claude\")`\n9. Add basic integration test (requires ANTHROPIC_API_KEY)\n\n## Acceptance Criteria\n- [ ] `claude-agent-sdk` added to dependencies\n- [ ] `ClaudeSDKHarness` implements full `AsyncHarnessBackend` Protocol\n- [ ] `run_task()` executes prompts via SDK `query()`\n- [ ] `stream_task()` streams messages with callback\n- [ ] SDK messages parsed into `Message` and `ToolUse` models\n- [ ] Token usage extracted from SDK response\n- [ ] Errors wrapped with clear messages\n- [ ] Registered as \"claude\" backend\n- [ ] Integration test passes (with API key)\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- pyproject.toml\n- src/cub/core/harness/claude_sdk.py (new)\n- src/cub/core/harness/__init__.py\n- tests/test_harness_claude_sdk.py (new)\n\n## Notes\n- Claude SDK is async-only, use `anyio.run()` for testing\n- SDK requires Node.js 18+ (document in prerequisites)\n- Handle `CLINotFoundError` gracefully\n- Consider rate limits and timeouts", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-2", "model:opus", "complexity:high", "logic", "sdk"], "dependencies": [{"depends_on_id": "cub-k41", "type": "parent-child"}, {"depends_on_id": "cub-k41.1", "type": "blocks"}]}
{"id": "cub-k41.3", "title": "Migrate legacy harnesses to async interface", "description": "## Context\nPreserve existing shell-out harnesses under new names while making them compatible with the async interface. This ensures backward compatibility during the transition.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 4 hours\n**Approach:** Wrap sync `invoke()` methods with `asyncio.to_thread()`. Rename classes and re-register under legacy names.\n\n## Implementation Steps\n1. In `claude.py`, rename `ClaudeBackend` to `ClaudeLegacyBackend`\n2. Create async wrapper methods:\n   - `run_task()` calls `asyncio.to_thread(self.invoke, ...)`\n   - `stream_task()` calls `asyncio.to_thread(self.invoke_streaming, ...)`\n3. Add `supports_feature()` method returning appropriate capabilities\n4. Register `ClaudeLegacyBackend` as \"claude-legacy\" backend\n5. Repeat for `CodexBackend` -> \"codex\" (already async-compatible name)\n6. Repeat for `OpenCodeBackend` -> \"opencode\"\n7. Repeat for `GeminiBackend` -> \"gemini\" (if exists)\n8. Add deprecation warning when legacy harnesses are used\n9. Update `detect_async_harness()` priority order: claude -> claude-legacy -> others\n10. Ensure all legacy harnesses implement `AsyncHarnessBackend` Protocol\n\n## Acceptance Criteria\n- [ ] `ClaudeLegacyBackend` created and registered as \"claude-legacy\"\n- [ ] Async wrappers work with `asyncio.to_thread()`\n- [ ] `CodexBackend` implements `AsyncHarnessBackend`\n- [ ] `OpenCodeBackend` implements `AsyncHarnessBackend`\n- [ ] Deprecation warning shown for legacy harnesses\n- [ ] Detection priority updated\n- [ ] All legacy harnesses pass Protocol check\n- [ ] Existing functionality preserved\n- [ ] mypy passes with strict mode\n- [ ] Existing tests still pass\n\n## Files Likely Involved\n- src/cub/core/harness/claude.py\n- src/cub/core/harness/codex.py\n- src/cub/core/harness/opencode.py\n- src/cub/core/harness/gemini.py\n- src/cub/core/harness/async_backend.py\n- tests/test_harness_*.py\n\n## Notes\n- `asyncio.to_thread()` runs sync code in thread pool\n- Keep sync methods for backward compatibility during transition\n- Deprecation warning should be clear but not alarming", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "logic", "migration"], "dependencies": [{"depends_on_id": "cub-k41", "type": "parent-child"}, {"depends_on_id": "cub-k41.1", "type": "blocks"}]}
{"id": "cub-k41.4", "title": "Implement hook system for Claude SDK", "description": "## Context\nEnable circuit breaker and guardrails via hooks. The hook system intercepts events during task execution, allowing external code to block or modify behavior.\n\n## Implementation Hints\n\n**Recommended Model:** opus\n**Estimated Duration:** 4 hours\n**Approach:** Study Claude SDK's `HookMatcher` and `PreToolUse`/`PostToolUse`. Map our hook events to SDK hooks. Implement hook registry in ClaudeSDKHarness.\n\n## Implementation Steps\n1. Add `HookEvent` enum to models.py: PRE_TASK, POST_TASK, PRE_TOOL_USE, POST_TOOL_USE, ON_ERROR, ON_MESSAGE\n2. Add `HookContext` dataclass with event, task, tool_use, message, error fields\n3. Add `HookResult` dataclass with block, reason, modified_input fields\n4. Define `HookHandler` type alias: `Callable[[HookContext], Awaitable[HookResult | None]]`\n5. Add hook registry to `ClaudeSDKHarness`:\n   - `_hooks: dict[HookEvent, list[HookHandler]]`\n   - `register_hook(event, handler)` method\n   - `_execute_hooks(event, context)` internal method\n6. Map cub hooks to SDK's `PreToolUse` hook:\n   - Create `HookMatcher` for tool-specific hooks\n   - Translate `HookResult.block` to SDK's `permissionDecision: \"deny\"`\n7. Execute PRE_TASK hooks before calling `query()`\n8. Execute POST_TASK hooks after `query()` completes\n9. Execute ON_ERROR hooks when exceptions occur\n10. Add no-op `register_hook()` to legacy harnesses (log warning)\n11. Add unit tests for hook registration and execution\n12. Add integration test for PreToolUse blocking\n\n## Acceptance Criteria\n- [ ] `HookEvent`, `HookContext`, `HookResult` defined in models.py\n- [ ] `HookHandler` type alias defined\n- [ ] `ClaudeSDKHarness.register_hook()` works\n- [ ] PRE_TASK hooks execute before task\n- [ ] POST_TASK hooks execute after task\n- [ ] PRE_TOOL_USE hooks can block tool execution\n- [ ] ON_ERROR hooks execute on exceptions\n- [ ] Legacy harnesses have no-op register_hook()\n- [ ] Unit tests for hook registry\n- [ ] Integration test for blocking hook\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- src/cub/core/harness/models.py\n- src/cub/core/harness/claude_sdk.py\n- src/cub/core/harness/claude.py (legacy no-op)\n- tests/test_harness_hooks.py (new)\n\n## Notes\n- SDK's `HookMatcher` filters by tool name\n- Hooks are async to allow IO operations\n- Keep hook overhead minimal (async, non-blocking)\n- Document hook API for downstream features (circuit breaker)", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-4", "model:opus", "complexity:high", "logic", "hooks"], "dependencies": [{"depends_on_id": "cub-k41", "type": "parent-child"}, {"depends_on_id": "cub-k41.2", "type": "blocks"}]}
{"id": "cub-k41.5", "title": "Integrate async harnesses into CLI and add tests", "description": "## Context\nFinal integration phase - update the CLI to use async harnesses and ensure comprehensive test coverage. This completes the harness abstraction feature.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 6 hours\n**Approach:** Update cub run to call async harness methods. Add integration tests for all harnesses. Update documentation.\n\n## Implementation Steps\n1. Update `src/cub/cli/run.py` to use async harness methods:\n   - Replace `harness_backend.invoke()` with `await harness_backend.run_task()`\n   - Replace `harness_backend.invoke_streaming()` with `await harness_backend.stream_task()`\n   - Wrap main loop in `async def _run_async()` and call via `anyio.run()`\n2. Update harness selection:\n   - Use `get_async_backend()` instead of `get_backend()`\n   - Update priority: claude (SDK) -> claude-legacy -> codex -> opencode\n3. Add `--harness claude-legacy` to CLI help and README\n4. Create `tests/test_harness_integration.py`:\n   - Test each harness with mock responses\n   - Test harness detection priority\n   - Test feature detection\n5. Update existing harness tests for async\n6. Add `tests/test_harness_claude_sdk_integration.py` (requires API key, marked skip)\n7. Update `docs/HARNESSES.md` with feature matrix\n8. Update README.md harness section\n9. Add migration guide section to UPGRADING.md\n10. Run full test suite and fix any issues\n\n## Acceptance Criteria\n- [ ] `cub run` uses async harness methods\n- [ ] `cub run --harness claude` uses Claude SDK harness\n- [ ] `cub run --harness claude-legacy` uses shell-out harness\n- [ ] Harness detection works with new priority\n- [ ] Integration tests for all harnesses\n- [ ] Feature detection tests pass\n- [ ] docs/HARNESSES.md updated with feature matrix\n- [ ] README.md harness section updated\n- [ ] UPGRADING.md has migration guide\n- [ ] All tests pass\n- [ ] mypy passes with strict mode\n- [ ] ruff check passes\n\n## Files Likely Involved\n- src/cub/cli/run.py\n- src/cub/core/harness/__init__.py\n- tests/test_harness_integration.py (new)\n- tests/test_harness_claude_sdk_integration.py (new)\n- docs/HARNESSES.md\n- README.md\n- UPGRADING.md\n\n## Notes\n- Mark SDK integration tests with `@pytest.mark.skipif(not API_KEY)`\n- Ensure streaming callback still works\n- Test with both `--stream` and non-streaming modes\n- Verify budget tracking still works with new TaskResult", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-5", "model:sonnet", "complexity:medium", "test", "docs", "checkpoint"], "dependencies": [{"depends_on_id": "cub-k41", "type": "parent-child"}, {"depends_on_id": "cub-k41.3", "type": "blocks"}, {"depends_on_id": "cub-k41.4", "type": "blocks"}]}
