{"id": "cub-E07", "title": "v0.21: Python Core Migration", "description": "# Epic: Python Core Migration (v0.21)\n\n## Overview\nMigrate cub from Bash to a full Python CLI using Typer, Pydantic, and Rich. This is the foundation for all subsequent releases.\n\n## Goals\n- Eliminate jq subprocess overhead (10-50x performance improvement)\n- Establish modern Python tooling (uv, typer, pydantic)\n- Preserve all existing functionality\n- Enable status.json generation for dashboard\n\n## Success Criteria\n- `cub run` works end-to-end in Python\n- Task operations < 100ms (vs current ~500ms)\n- All harness backends functional (Claude, Codex)\n- Configuration loading with correct precedence\n\n## Exit Criteria\n- All tasks in this epic closed\n- Integration tests passing\n- Can run `cub run --once` successfully", "status": "open", "priority": 0, "issue_type": "epic", "labels": ["release:v0.21", "phase-1"], "dependencies": []}
{"id": "cub-053", "title": "Initialize Python project with uv", "description": "## Context\nSet up the Python project structure using uv for fast dependency management. This is the foundation for all Python code.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Use uv init, configure pyproject.toml with project metadata and dependencies.\n\n## Implementation Steps\n1. Run `uv init` in project root\n2. Configure pyproject.toml with:\n   - Project name: cub\n   - Python version: >=3.10\n   - Dependencies: typer, pydantic, rich, GitPython, pytest\n   - Entry point: cub = \"cub.cli:app\"\n3. Create src/cub/ directory structure\n4. Add __init__.py and __main__.py\n5. Verify `uv run python -m cub --help` works\n\n## Acceptance Criteria\n- [ ] pyproject.toml exists with correct metadata\n- [ ] uv.lock generated\n- [ ] `uv run python -m cub --help` shows Typer help\n- [ ] Project installable with `uv pip install -e .`\n\n## Files Likely Involved\n- pyproject.toml (new)\n- src/cub/__init__.py (new)\n- src/cub/__main__.py (new)\n- src/cub/cli/__init__.py (new)\n\n## Notes\n- Use src layout for proper packaging\n- Include dev dependencies: pytest, ruff, mypy", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "setup", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}]}
{"id": "cub-054", "title": "Create Task and Config Pydantic models", "description": "## Context\nDefine the core data models using Pydantic v2. These models replace the ad-hoc JSON parsing in Bash and provide validation, serialization, and IDE support.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Study existing Bash code for field names and types. Use Pydantic v2 features (model_validator, computed fields).\n\n## Implementation Steps\n1. Create src/cub/core/tasks/models.py with:\n   - TaskStatus enum (open, in_progress, closed)\n   - TaskPriority enum (P0-P4)\n   - Task model with all fields from current prd.json/beads\n   - Add model_label computed property for model:X labels\n2. Create src/cub/core/config/models.py with:\n   - GuardrailsConfig\n   - BudgetConfig\n   - HarnessConfig\n   - HooksConfig\n   - CubConfig (top-level)\n3. Create src/cub/core/status/models.py with:\n   - RunStatus model for dashboard\n   - Include current_task, iteration, budget, events\n4. Add unit tests for model validation\n\n## Acceptance Criteria\n- [ ] Task model can parse existing prd.json tasks\n- [ ] CubConfig model can parse existing .cub.json\n- [ ] All enums have correct values matching existing code\n- [ ] Pydantic validation catches invalid data\n- [ ] Tests pass for happy path and error cases\n\n## Files Likely Involved\n- src/cub/core/__init__.py (new)\n- src/cub/core/tasks/__init__.py (new)\n- src/cub/core/tasks/models.py (new)\n- src/cub/core/config/__init__.py (new)\n- src/cub/core/config/models.py (new)\n- tests/test_models.py (new)\n\n## Notes\n- Reference lib/tasks.sh and lib/config.sh for field names\n- Use Field() for defaults and descriptions\n- Include examples in docstrings", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "model", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-053", "type": "blocks"}]}
{"id": "cub-055", "title": "Implement TaskBackend protocol and registry", "description": "## Context\nDefine the TaskBackend protocol that all task backends must implement. This enables the pluggable architecture where beads and JSON backends are interchangeable.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1h\n**Approach:** Use typing.Protocol with @runtime_checkable. Create a registry pattern for backend discovery.\n\n## Implementation Steps\n1. Create src/cub/core/tasks/backend.py with:\n   - TaskBackend Protocol class\n   - Methods: list_tasks, get_task, get_ready_tasks, update_task, close_task\n   - Backend registry dict\n   - register_backend decorator\n   - get_backend factory function\n   - detect_backend function (auto-detect beads vs json)\n2. Add type hints for all parameters and returns\n3. Document expected behavior in docstrings\n\n## Acceptance Criteria\n- [ ] TaskBackend protocol defined with all required methods\n- [ ] @register_backend decorator works\n- [ ] get_backend('beads') and get_backend('json') work\n- [ ] detect_backend auto-selects based on .beads/ presence\n- [ ] Protocol is @runtime_checkable\n\n## Files Likely Involved\n- src/cub/core/tasks/backend.py (new)\n- src/cub/core/tasks/__init__.py (update exports)\n\n## Notes\n- Reference lib/tasks.sh detect_backend() for auto-detection logic\n- Use Protocol from typing, not ABC\n- Include capability query method if needed", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-054", "type": "blocks"}]}
{"id": "cub-056", "title": "Implement BeadsBackend for task management", "description": "## Context\nImplement the beads backend that wraps the `bd` CLI tool. This is the primary task backend when beads is available.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Use subprocess to call bd CLI, parse JSON output with Pydantic models. Reference lib/beads.sh for command patterns.\n\n## Implementation Steps\n1. Create src/cub/core/tasks/beads.py with:\n   - BeadsBackend class implementing TaskBackend\n   - Helper for running bd commands with subprocess\n   - Parse bd JSON output into Task models\n   - Handle bd errors gracefully\n2. Implement all TaskBackend methods:\n   - list_tasks: `bd list --json [--status X] [--label X]`\n   - get_task: `bd show <id> --json`\n   - get_ready_tasks: `bd ready --json`\n   - update_task: `bd update <id> --status X`\n   - close_task: `bd close <id> -r \"reason\"`\n3. Add @register_backend('beads') decorator\n4. Handle case when bd is not installed\n\n## Acceptance Criteria\n- [ ] Can list tasks from beads\n- [ ] Can get single task by ID\n- [ ] Can find ready (unblocked) tasks\n- [ ] Can update task status\n- [ ] Can close task with reason\n- [ ] Graceful error when bd not installed\n- [ ] JSON parsing produces valid Task models\n\n## Files Likely Involved\n- src/cub/core/tasks/beads.py (new)\n- src/cub/core/tasks/__init__.py (update)\n\n## Notes\n- Reference lib/beads.sh for exact bd command patterns\n- Use subprocess.run with capture_output=True\n- Parse stderr for error messages", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-055", "type": "blocks"}]}
{"id": "cub-057", "title": "Implement JsonBackend for task management", "description": "## Context\nImplement the JSON file backend for projects not using beads. Reads/writes prd.json directly.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Load prd.json, parse with Pydantic, implement CRUD operations. Reference lib/tasks.sh json_* functions.\n\n## Implementation Steps\n1. Create src/cub/core/tasks/json.py with:\n   - JsonBackend class implementing TaskBackend\n   - Load/save prd.json file\n   - Parse tasks into Task models\n   - Implement dependency resolution for ready tasks\n2. Implement all TaskBackend methods:\n   - list_tasks: filter in-memory\n   - get_task: lookup by id\n   - get_ready_tasks: check depends_on resolution\n   - update_task: modify and save\n   - close_task: set status=closed, add notes\n3. Add @register_backend('json') decorator\n4. Handle missing prd.json gracefully\n\n## Acceptance Criteria\n- [ ] Can load tasks from prd.json\n- [ ] Can filter by status and label\n- [ ] Dependency resolution works correctly\n- [ ] Can update and save changes\n- [ ] File not corrupted on write errors\n- [ ] Creates empty task list if prd.json missing\n\n## Files Likely Involved\n- src/cub/core/tasks/json.py (new)\n- src/cub/core/tasks/__init__.py (update)\n\n## Notes\n- Use atomic write (write to temp, then rename)\n- Reference lib/tasks.sh json_* functions\n- Preserve unknown fields in prd.json", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-055", "type": "blocks"}]}
{"id": "cub-058", "title": "Implement config loader with multi-layer merging", "description": "## Context\nImplement configuration loading that merges defaults < user config < project config < env vars, matching the existing Bash behavior.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Load JSON files, deep merge dicts, apply env var overrides, validate with Pydantic.\n\n## Implementation Steps\n1. Create src/cub/core/config/loader.py with:\n   - load_config() function returning CubConfig\n   - get_user_config_path() using XDG\n   - get_project_config_path()\n   - deep_merge() helper for dict merging\n   - apply_env_overrides() for CUB_* vars\n2. Implement precedence:\n   - Start with hardcoded defaults\n   - Merge ~/.config/cub/config.json\n   - Merge ./.cub.json\n   - Apply CUB_BUDGET, CUB_REVIEW_STRICT, etc.\n3. Validate final result with Pydantic\n4. Cache loaded config for session\n\n## Acceptance Criteria\n- [ ] Loads defaults when no config files exist\n- [ ] User config overrides defaults\n- [ ] Project config overrides user config\n- [ ] Env vars override all config files\n- [ ] Invalid config produces helpful error\n- [ ] Config is cached after first load\n\n## Files Likely Involved\n- src/cub/core/config/loader.py (new)\n- src/cub/core/config/__init__.py (update exports)\n\n## Notes\n- Reference lib/config.sh for exact merge behavior\n- Use pathlib for paths\n- XDG: ~/.config/cub/ on Linux, ~/Library/Application Support/cub/ on macOS", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-054", "type": "blocks"}]}
{"id": "cub-059", "title": "Implement HarnessBackend protocol and registry", "description": "## Context\nDefine the HarnessBackend protocol for AI coding assistant abstraction. Supports capability detection and pluggable harness implementations.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1h\n**Approach:** Mirror TaskBackend pattern. Include capabilities model for feature detection.\n\n## Implementation Steps\n1. Create src/cub/core/harness/models.py with:\n   - HarnessCapabilities model (streaming, token_reporting, etc.)\n   - HarnessResult model (output, tokens, duration)\n2. Create src/cub/core/harness/backend.py with:\n   - HarnessBackend Protocol class\n   - Properties: name, capabilities\n   - Methods: invoke, invoke_streaming, is_available\n   - Registry and factory functions\n   - detect_harness function (auto-detect available)\n3. Define capability constants matching existing code\n\n## Acceptance Criteria\n- [ ] HarnessBackend protocol with all methods\n- [ ] HarnessCapabilities correctly typed\n- [ ] HarnessResult captures all needed data\n- [ ] detect_harness finds available harness\n- [ ] Registry pattern works\n\n## Files Likely Involved\n- src/cub/core/harness/__init__.py (new)\n- src/cub/core/harness/models.py (new)\n- src/cub/core/harness/backend.py (new)\n\n## Notes\n- Reference lib/harness.sh _harness_get_capabilities()\n- Include model_selection capability\n- Support both blocking and streaming invocation", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-053", "type": "blocks"}]}
{"id": "cub-060", "title": "Implement Claude harness backend", "description": "## Context\nImplement the Claude Code harness - the primary AI backend. Supports streaming, token reporting, system prompts, and model selection.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Wrap claude CLI with subprocess. Parse stream-json output for tokens. Reference lib/harness.sh claude_invoke().\n\n## Implementation Steps\n1. Create src/cub/core/harness/claude.py with:\n   - ClaudeBackend class implementing HarnessBackend\n   - is_available() checks for claude command\n   - Build command with flags:\n     - --print (non-interactive)\n     - --dangerously-skip-permissions (auto mode)\n     - --append-system-prompt (system prompt)\n     - --model (model selection)\n     - --output-format stream-json (streaming)\n2. Implement invoke():\n   - Run subprocess, capture output\n   - Parse JSON for result and token usage\n3. Implement invoke_streaming():\n   - Yield lines as they arrive\n   - Parse final token counts\n4. Set capabilities correctly\n\n## Acceptance Criteria\n- [ ] Can invoke Claude with prompt\n- [ ] System prompt passed correctly\n- [ ] Model selection works\n- [ ] Streaming yields output incrementally\n- [ ] Token usage reported accurately\n- [ ] Graceful handling when claude not installed\n\n## Files Likely Involved\n- src/cub/core/harness/claude.py (new)\n- src/cub/core/harness/__init__.py (update)\n\n## Notes\n- Reference lib/harness.sh claude_invoke() and claude_invoke_streaming()\n- Parse .usage from JSON output\n- Use subprocess.PIPE with line buffering for streaming", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-059", "type": "blocks"}]}
{"id": "cub-061", "title": "Implement Codex harness backend", "description": "## Context\nImplement the OpenAI Codex CLI harness. Supports auto mode and streaming but no separate system prompt.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Wrap codex CLI. Combine system and task prompts since no --system-prompt flag.\n\n## Implementation Steps\n1. Create src/cub/core/harness/codex.py with:\n   - CodexBackend class implementing HarnessBackend\n   - is_available() checks for codex command\n   - Build command with flags:\n     - --full-auto (autonomous mode)\n     - --json (JSONL output)\n     - -m (model selection)\n2. Implement invoke():\n   - Combine system_prompt + prompt into single message\n   - Parse JSONL output\n3. Implement invoke_streaming():\n   - Parse JSONL events as they arrive\n4. Set capabilities (no system_prompt, no token_reporting)\n\n## Acceptance Criteria\n- [ ] Can invoke Codex with prompt\n- [ ] System prompt combined correctly\n- [ ] Model selection works (-m flag)\n- [ ] Streaming parses JSONL events\n- [ ] Graceful handling when codex not installed\n\n## Files Likely Involved\n- src/cub/core/harness/codex.py (new)\n- src/cub/core/harness/__init__.py (update)\n\n## Notes\n- Reference lib/harness.sh codex_invoke()\n- Codex uses --json not --output-format\n- Token reporting is estimated, not from CLI", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-059", "type": "blocks"}]}
{"id": "cub-062", "title": "Create Typer CLI structure with core commands", "description": "## Context\nSet up the Typer CLI with the main command structure. This is the entry point for all cub commands.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Create main app with subcommands. Use Typer's callback for global options.\n\n## Implementation Steps\n1. Create src/cub/cli/__init__.py with:\n   - Main Typer app\n   - Global options callback (--debug, --version)\n   - Import and register subcommand modules\n2. Create stub commands:\n   - src/cub/cli/run.py - cub run\n   - src/cub/cli/status.py - cub status\n   - src/cub/cli/init_cmd.py - cub init (avoid init.py conflict)\n3. Wire up __main__.py to call app()\n4. Add shell completion setup\n\n## Acceptance Criteria\n- [ ] `cub --help` shows all commands\n- [ ] `cub --version` shows version\n- [ ] `cub run --help` shows run options\n- [ ] Shell completion installable\n- [ ] Exit codes correct (0 success, 1 error)\n\n## Files Likely Involved\n- src/cub/cli/__init__.py (new/update)\n- src/cub/cli/run.py (new)\n- src/cub/cli/status.py (new)\n- src/cub/cli/init_cmd.py (new)\n- src/cub/__main__.py (update)\n\n## Notes\n- Use app.command() decorator\n- Include rich_help_panel for organization\n- Add typer.Exit() for proper exit codes", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "setup", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-053", "type": "blocks"}]}
{"id": "cub-063", "title": "Implement cub run command with main loop", "description": "## Context\nImplement the main run command that executes the autonomous loop. This is the core of cub - picking tasks and invoking harnesses.\n\n## Implementation Hints\n**Recommended Model:** opus\n**Estimated Duration:** 2h\n**Approach:** Port main loop logic from cmd_run.sh. Use task backend for task selection, harness for execution.\n\n## Implementation Steps\n1. Update src/cub/cli/run.py with:\n   - run command with all flags (--once, --epic, --label, --harness, etc.)\n   - Main loop: while tasks remain and budget not exceeded\n   - Task selection using get_ready_tasks()\n   - Prompt generation\n   - Harness invocation\n   - Status updates\n   - Hook execution points\n2. Implement status.json writing:\n   - Write after each iteration\n   - Include all RunStatus fields\n3. Handle interrupts gracefully (SIGINT)\n4. Log events to JSONL\n\n## Acceptance Criteria\n- [ ] `cub run` picks next ready task\n- [ ] Invokes correct harness\n- [ ] Updates task status on completion\n- [ ] Respects --once flag\n- [ ] Respects --epic and --label filters\n- [ ] Writes status.json each iteration\n- [ ] Stops on budget exhaustion\n- [ ] Handles Ctrl+C gracefully\n\n## Files Likely Involved\n- src/cub/cli/run.py (major update)\n- src/cub/core/status/writer.py (new)\n- src/cub/utils/hooks.py (new)\n\n## Notes\n- Reference lib/cmd_run.sh for loop logic\n- This is complex - ensure good test coverage\n- Status.json location: .cub/runs/{session}/status.json", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:opus", "complexity:high", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-056", "type": "blocks"}, {"depends_on_id": "cub-057", "type": "blocks"}, {"depends_on_id": "cub-058", "type": "blocks"}, {"depends_on_id": "cub-060", "type": "blocks"}, {"depends_on_id": "cub-062", "type": "blocks"}]}
{"id": "cub-064", "title": "Implement cub status command", "description": "## Context\nImplement the status command that shows task progress summary.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Query task backend, format with Rich tables.\n\n## Implementation Steps\n1. Update src/cub/cli/status.py with:\n   - status command with --json flag\n   - Query task backend for all tasks\n   - Calculate statistics (open, in_progress, closed)\n   - Display with Rich table\n   - JSON output option\n2. Show:\n   - Task counts by status\n   - Current task (if any in_progress)\n   - Ready tasks count\n   - Blocked tasks count\n\n## Acceptance Criteria\n- [ ] Shows task summary\n- [ ] Correct counts for each status\n- [ ] Shows ready vs blocked tasks\n- [ ] --json outputs machine-readable format\n- [ ] Works with both backends\n\n## Files Likely Involved\n- src/cub/cli/status.py (update)\n\n## Notes\n- Reference lib/cmd_status.sh\n- Use Rich Table for nice formatting\n- Include progress bar for completion %", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "ui", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-056", "type": "blocks"}, {"depends_on_id": "cub-057", "type": "blocks"}, {"depends_on_id": "cub-062", "type": "blocks"}]}
{"id": "cub-065", "title": "Implement hook execution from Python", "description": "## Context\nImplement hook execution that calls Bash hook scripts from Python. Hooks remain Bash for user extensibility.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1h\n**Approach:** Find and execute scripts in hook directories. Pass context via environment variables.\n\n## Implementation Steps\n1. Create src/cub/utils/hooks.py with:\n   - run_hooks(hook_name, context) function\n   - Find scripts in ~/.config/cub/hooks/{name}.d/\n   - Find scripts in .cub/hooks/{name}.d/\n   - Execute in sorted order\n   - Pass context as env vars (CUB_TASK_ID, etc.)\n2. Support hook points:\n   - pre-loop, post-loop\n   - pre-task, post-task\n   - on-error\n3. Handle hook failures based on config\n\n## Acceptance Criteria\n- [ ] Finds hooks in both directories\n- [ ] Executes in sorted order\n- [ ] Context passed as env vars\n- [ ] Hook failures logged\n- [ ] fail_fast config respected\n\n## Files Likely Involved\n- src/cub/utils/hooks.py (new)\n\n## Notes\n- Reference lib/hooks.sh\n- Scripts must be executable\n- Use subprocess.run with shell=False", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-053", "type": "blocks"}]}
{"id": "cub-066", "title": "Implement structured JSONL logging", "description": "## Context\nImplement structured logging that writes JSONL events for debugging and analytics.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Create logger class that writes timestamped JSON lines.\n\n## Implementation Steps\n1. Create src/cub/utils/logging.py with:\n   - CubLogger class\n   - log_event(event_type, data) method\n   - Write to ~/.local/share/cub/logs/{project}/{session}.jsonl\n   - Include timestamp, event_type, data fields\n2. Event types:\n   - task_start, task_end\n   - loop_start, loop_end\n   - budget_warning\n   - error\n3. Ensure log directory created\n\n## Acceptance Criteria\n- [ ] Creates log file in correct location\n- [ ] Each line is valid JSON\n- [ ] Timestamps in ISO format\n- [ ] Events queryable with jq\n- [ ] Handles write errors gracefully\n\n## Files Likely Involved\n- src/cub/utils/logging.py (new)\n\n## Notes\n- Reference lib/logger.sh\n- Use XDG data directory\n- Append mode, don't overwrite", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "logic", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-053", "type": "blocks"}]}
{"id": "cub-067", "title": "Add pytest test suite for core modules", "description": "## Context\nCreate comprehensive pytest tests for core modules. Replace/supplement BATS tests.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Test each module in isolation with fixtures. Mock subprocess calls for harness tests.\n\n## Implementation Steps\n1. Create tests/conftest.py with:\n   - Fixtures for temp directories\n   - Fixtures for sample tasks/config\n   - Mock bd CLI responses\n2. Create test files:\n   - tests/test_tasks/test_models.py\n   - tests/test_tasks/test_beads.py\n   - tests/test_tasks/test_json.py\n   - tests/test_config/test_loader.py\n   - tests/test_harness/test_claude.py\n3. Test happy paths and error cases\n4. Add GitHub Actions workflow\n\n## Acceptance Criteria\n- [ ] >80% coverage on core modules\n- [ ] Tests run in <30 seconds\n- [ ] No external dependencies in tests (all mocked)\n- [ ] CI workflow runs on push\n- [ ] Tests documented\n\n## Files Likely Involved\n- tests/conftest.py (new)\n- tests/test_tasks/*.py (new)\n- tests/test_config/*.py (new)\n- tests/test_harness/*.py (new)\n- .github/workflows/test.yml (new)\n\n## Notes\n- Use pytest-mock for subprocess mocking\n- Reference tests/*.bats for test cases\n- Include integration tests that run actual commands", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "test", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-056", "type": "blocks"}, {"depends_on_id": "cub-057", "type": "blocks"}, {"depends_on_id": "cub-058", "type": "blocks"}, {"depends_on_id": "cub-060", "type": "blocks"}]}
{"id": "cub-068", "title": "Update installation and migration docs", "description": "## Context\nUpdate documentation for the Python CLI. Include migration guide from Bash version.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Update README, add UPGRADING notes.\n\n## Implementation Steps\n1. Update README.md:\n   - New installation instructions (uv/pip)\n   - Updated prerequisites (Python 3.10+)\n   - Updated command examples\n2. Update UPGRADING.md:\n   - v0.21 migration notes\n   - Breaking changes (if any)\n   - New features\n3. Update CLAUDE.md:\n   - New project structure\n   - Python commands\n\n## Acceptance Criteria\n- [ ] README shows Python install\n- [ ] UPGRADING documents v0.21 changes\n- [ ] All code examples work\n- [ ] Prerequisites accurate\n\n## Files Likely Involved\n- README.md (update)\n- UPGRADING.md (update)\n- CLAUDE.md (update)\n\n## Notes\n- Keep old Bash info in legacy section\n- Test installation instructions work", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "docs", "release:v0.21"], "dependencies": [{"depends_on_id": "cub-E07", "type": "parent-child"}, {"depends_on_id": "cub-063", "type": "blocks"}]}
{"id": "cub-E08", "title": "v0.22: Codebase Health Audit", "description": "# Epic: Codebase Health Audit (v0.22)\n\n## Overview\nFormalize audit tooling for dead code detection, documentation validation, and test coverage analysis.\n\n## Goals\n- Detect dead/unused code in Python and Bash\n- Validate documentation freshness\n- Report test coverage\n- Provide CI-friendly output\n\n## Success Criteria\n- `cub audit` produces actionable report\n- Can run in CI with pass/fail thresholds\n- Identifies real issues in codebase\n\n## Exit Criteria\n- All tasks in this epic closed\n- Audit runs on cub itself with good results", "status": "open", "priority": 1, "issue_type": "epic", "labels": ["release:v0.22", "phase-2"], "dependencies": [{"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-069", "title": "Implement dead code detection for Python", "description": "## Context\nDetect unused functions, classes, and variables in Python code using AST analysis.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Use ast module to find definitions, then find references. Report unreferenced definitions.\n\n## Implementation Steps\n1. Create src/cub/audit/dead_code.py with:\n   - find_python_definitions() - parse AST for functions, classes\n   - find_python_references() - find all name references\n   - detect_unused() - compare definitions vs references\n   - DeadCodeReport model\n2. Handle:\n   - Unused imports\n   - Unused functions/methods\n   - Unused classes\n   - Unused variables\n3. Support exclude patterns (test files, __all__)\n\n## Acceptance Criteria\n- [ ] Finds unused imports\n- [ ] Finds unused functions\n- [ ] Respects exclude patterns\n- [ ] Reports file and line number\n- [ ] No false positives for __all__ exports\n\n## Files Likely Involved\n- src/cub/audit/__init__.py (new)\n- src/cub/audit/dead_code.py (new)\n- src/cub/audit/models.py (new)\n\n## Notes\n- Consider using vulture as alternative/supplement\n- Handle dynamic imports gracefully", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "logic", "release:v0.22"], "dependencies": [{"depends_on_id": "cub-E08", "type": "parent-child"}, {"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-070", "title": "Implement dead code detection for Bash", "description": "## Context\nDetect unused functions and variables in remaining Bash code (hooks, legacy).\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Use shellcheck and/or regex parsing to find definitions and references.\n\n## Implementation Steps\n1. Add to src/cub/audit/dead_code.py:\n   - find_bash_functions() - regex for function definitions\n   - find_bash_calls() - regex for function calls\n   - run_shellcheck() - get shellcheck warnings\n2. Parse shellcheck JSON output\n3. Handle sourced files\n\n## Acceptance Criteria\n- [ ] Finds unused Bash functions\n- [ ] Integrates shellcheck warnings\n- [ ] Reports file and line number\n- [ ] Handles source/. includes\n\n## Files Likely Involved\n- src/cub/audit/dead_code.py (update)\n\n## Notes\n- shellcheck is optional dependency\n- Graceful fallback if shellcheck not installed", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "logic", "release:v0.22"], "dependencies": [{"depends_on_id": "cub-E08", "type": "parent-child"}, {"depends_on_id": "cub-069", "type": "blocks"}]}
{"id": "cub-071", "title": "Implement documentation validation", "description": "## Context\nValidate README and docs for broken links, outdated code examples, and stale content.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Parse markdown, extract links and code blocks, validate each.\n\n## Implementation Steps\n1. Create src/cub/audit/docs.py with:\n   - extract_links() - find all URLs in markdown\n   - check_links() - verify URLs are valid (HEAD request)\n   - extract_code_blocks() - find fenced code\n   - validate_code() - syntax check code blocks\n   - DocsReport model\n2. Check:\n   - Broken links (404s)\n   - Invalid internal references\n   - Syntax errors in code blocks\n   - Outdated version references\n\n## Acceptance Criteria\n- [ ] Finds broken links\n- [ ] Validates code block syntax\n- [ ] Reports specific line numbers\n- [ ] Handles relative links\n- [ ] Network timeouts handled gracefully\n\n## Files Likely Involved\n- src/cub/audit/docs.py (new)\n\n## Notes\n- Use requests for HTTP checks\n- Consider markdown-link-check integration\n- Rate limit external requests", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "logic", "release:v0.22"], "dependencies": [{"depends_on_id": "cub-E08", "type": "parent-child"}, {"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-072", "title": "Implement test coverage reporting", "description": "## Context\nReport test coverage and identify files with insufficient coverage.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Run pytest with coverage, parse coverage.py output.\n\n## Implementation Steps\n1. Create src/cub/audit/coverage.py with:\n   - run_coverage() - execute pytest --cov\n   - parse_coverage_report() - parse JSON output\n   - identify_low_coverage() - find files below threshold\n   - CoverageReport model\n2. Report:\n   - Overall coverage percentage\n   - Per-file coverage\n   - Files below threshold\n   - Uncovered lines\n\n## Acceptance Criteria\n- [ ] Runs pytest with coverage\n- [ ] Parses coverage report\n- [ ] Identifies low-coverage files\n- [ ] Reports specific uncovered lines\n- [ ] Handles missing coverage.py gracefully\n\n## Files Likely Involved\n- src/cub/audit/coverage.py (new)\n\n## Notes\n- coverage.py is dev dependency\n- Support configurable threshold", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:haiku", "complexity:low", "logic", "release:v0.22"], "dependencies": [{"depends_on_id": "cub-E08", "type": "parent-child"}, {"depends_on_id": "cub-067", "type": "blocks"}]}
{"id": "cub-073", "title": "Implement cub audit command", "description": "## Context\nCreate the CLI command that runs all audit checks and produces a unified report.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Orchestrate audit modules, combine reports, format output.\n\n## Implementation Steps\n1. Create src/cub/cli/audit.py with:\n   - audit command with flags (--dead-code, --docs, --coverage, --ci)\n   - Run selected audits\n   - Combine into AuditReport\n   - Format with Rich (summary view)\n   - JSON output option\n   - CI mode (exit codes based on thresholds)\n2. Output:\n   - Summary scores per category\n   - Detailed findings\n   - Recommendations\n\n## Acceptance Criteria\n- [ ] `cub audit` runs all checks\n- [ ] `cub audit --ci` exits non-zero on failure\n- [ ] `cub audit --json` outputs machine-readable\n- [ ] Summary shows scores per category\n- [ ] Detailed findings actionable\n\n## Files Likely Involved\n- src/cub/cli/audit.py (new)\n- src/cub/cli/__init__.py (register command)\n\n## Notes\n- Reference specs/roadmap/codebase-health-audit.md for output format\n- Include grading (A-F) for quick assessment", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "ui", "release:v0.22"], "dependencies": [{"depends_on_id": "cub-E08", "type": "parent-child"}, {"depends_on_id": "cub-069", "type": "blocks"}, {"depends_on_id": "cub-070", "type": "blocks"}, {"depends_on_id": "cub-071", "type": "blocks"}, {"depends_on_id": "cub-072", "type": "blocks"}]}
{"id": "cub-E09", "title": "v0.23: Live Dashboard", "description": "# Epic: Live Dashboard (v0.23)\n\n## Overview\nReal-time tmux-based dashboard for monitoring autonomous cub runs.\n\n## Goals\n- See current task and progress in real-time\n- Monitor budget usage\n- View recent activity\n- Attach to running sessions\n\n## Success Criteria\n- `cub run --monitor` launches with live dashboard\n- `cub monitor` can attach to existing run\n- Dashboard updates in real-time (1s refresh)\n\n## Exit Criteria\n- All tasks in this epic closed\n- Dashboard usable for real overnight runs", "status": "open", "priority": 1, "issue_type": "epic", "labels": ["release:v0.23", "phase-3"], "dependencies": [{"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-074", "title": "Implement Rich-based dashboard renderer", "description": "## Context\nCreate the dashboard rendering component using Rich library for terminal UI.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Use Rich Live display with Layout for multi-pane dashboard.\n\n## Implementation Steps\n1. Create src/cub/dashboard/renderer.py with:\n   - DashboardRenderer class\n   - render() method creating Rich Layout\n   - Panels for: status, progress, activity, budget\n   - Color coding for status\n2. Layout:\n   - Header: session name, status\n   - Left: current task, iteration\n   - Right: budget progress bar\n   - Bottom: recent activity log\n3. Use Rich components:\n   - Panel, Table, Progress\n   - Live for auto-refresh\n\n## Acceptance Criteria\n- [ ] Renders multi-pane dashboard\n- [ ] Shows current task prominently\n- [ ] Progress bars for budget and tasks\n- [ ] Activity log scrolls\n- [ ] Color indicates status\n\n## Files Likely Involved\n- src/cub/dashboard/__init__.py (new)\n- src/cub/dashboard/renderer.py (new)\n\n## Notes\n- Reference specs/roadmap/live-dashboard.md for layout\n- Test in different terminal sizes", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "ui", "release:v0.23"], "dependencies": [{"depends_on_id": "cub-E09", "type": "parent-child"}, {"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-075", "title": "Implement status file polling", "description": "## Context\nCreate the status file reader that polls status.json and updates dashboard.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Watch file for changes, parse into RunStatus model, notify renderer.\n\n## Implementation Steps\n1. Create src/cub/dashboard/status.py with:\n   - StatusWatcher class\n   - poll() method reading status.json\n   - Parse into RunStatus model\n   - Detect changes\n   - Callback on update\n2. Handle:\n   - File not existing yet\n   - Invalid JSON\n   - File being written\n\n## Acceptance Criteria\n- [ ] Polls status.json at configured interval\n- [ ] Parses into RunStatus model\n- [ ] Detects changes efficiently\n- [ ] Handles missing file gracefully\n- [ ] Handles partial writes\n\n## Files Likely Involved\n- src/cub/dashboard/status.py (new)\n\n## Notes\n- Use file mtime for change detection\n- Default 1s poll interval\n- Consider watchdog for efficiency", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:haiku", "complexity:low", "logic", "release:v0.23"], "dependencies": [{"depends_on_id": "cub-E09", "type": "parent-child"}, {"depends_on_id": "cub-074", "type": "blocks"}]}
{"id": "cub-076", "title": "Implement tmux integration for --monitor", "description": "## Context\nIntegrate with tmux to launch dashboard alongside main run.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Create tmux session with split panes - main run and dashboard.\n\n## Implementation Steps\n1. Create src/cub/dashboard/tmux.py with:\n   - launch_with_dashboard() function\n   - Create tmux session\n   - Split panes (main left, dashboard right)\n   - Start main run in left pane\n   - Start monitor in right pane\n2. Handle:\n   - tmux not installed\n   - Already in tmux session\n   - Session naming\n\n## Acceptance Criteria\n- [ ] `cub run --monitor` creates tmux session\n- [ ] Main run in left pane\n- [ ] Dashboard in right pane\n- [ ] Graceful fallback if no tmux\n- [ ] Clean exit when run completes\n\n## Files Likely Involved\n- src/cub/dashboard/tmux.py (new)\n- src/cub/cli/run.py (add --monitor flag)\n\n## Notes\n- Reference specs/roadmap/live-dashboard.md\n- Use tmux split-window -h\n- Consider pane size configuration", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "logic", "release:v0.23"], "dependencies": [{"depends_on_id": "cub-E09", "type": "parent-child"}, {"depends_on_id": "cub-074", "type": "blocks"}, {"depends_on_id": "cub-075", "type": "blocks"}]}
{"id": "cub-077", "title": "Implement cub monitor command", "description": "## Context\nCreate command to attach dashboard to an existing run session.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Find running session, start dashboard pointed at its status.json.\n\n## Implementation Steps\n1. Create src/cub/cli/monitor.py with:\n   - monitor command\n   - Find session by ID or auto-detect\n   - Locate status.json\n   - Start dashboard renderer\n2. Options:\n   - Session ID argument\n   - --list to show running sessions\n\n## Acceptance Criteria\n- [ ] `cub monitor` attaches to running session\n- [ ] `cub monitor <session-id>` attaches to specific session\n- [ ] `cub monitor --list` shows running sessions\n- [ ] Clear error if no running session\n\n## Files Likely Involved\n- src/cub/cli/monitor.py (new)\n- src/cub/cli/__init__.py (register command)\n\n## Notes\n- Look in .cub/runs/ for recent sessions\n- Check status.json exists and is recent", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:haiku", "complexity:low", "ui", "release:v0.23"], "dependencies": [{"depends_on_id": "cub-E09", "type": "parent-child"}, {"depends_on_id": "cub-074", "type": "blocks"}, {"depends_on_id": "cub-075", "type": "blocks"}]}
{"id": "cub-E10", "title": "v0.24: Git Worktrees for Parallel Development", "description": "# Epic: Git Worktrees (v0.24)\n\n## Overview\nEnable parallel development using git worktrees for isolated execution.\n\n## Goals\n- Run cub in dedicated worktree (--worktree flag)\n- Process independent tasks in parallel (--parallel N)\n- Manage worktree lifecycle\n\n## Success Criteria\n- Can run multiple cub instances on same repo\n- `--parallel 3` processes 3 independent tasks concurrently\n- Clean worktree management\n\n## Exit Criteria\n- All tasks in this epic closed\n- Parallel execution tested with real tasks", "status": "open", "priority": 1, "issue_type": "epic", "labels": ["release:v0.24", "phase-4"], "dependencies": [{"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-078", "title": "Implement WorktreeManager class", "description": "## Context\nCreate the core worktree management class wrapping git worktree commands.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Wrap git worktree commands with subprocess or GitPython.\n\n## Implementation Steps\n1. Create src/cub/core/worktree/__init__.py\n2. Create src/cub/core/worktree/manager.py with:\n   - WorktreeManager class\n   - create(branch, path) - create worktree\n   - list() - list all worktrees\n   - remove(path) - remove worktree\n   - get_for_task(task_id) - get/create worktree for task\n   - cleanup_merged() - remove worktrees for merged branches\n3. Handle:\n   - Worktree naming conventions\n   - Branch creation if needed\n   - Lock file issues\n\n## Acceptance Criteria\n- [ ] Can create worktree for task\n- [ ] Can list all worktrees\n- [ ] Can remove worktree\n- [ ] Handles branch not existing\n- [ ] Cleanup removes merged branches\n\n## Files Likely Involved\n- src/cub/core/worktree/__init__.py (new)\n- src/cub/core/worktree/manager.py (new)\n\n## Notes\n- Worktree path: .cub/worktrees/{task-id}/\n- Consider using GitPython for cleaner API", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-4", "model:sonnet", "complexity:medium", "logic", "release:v0.24"], "dependencies": [{"depends_on_id": "cub-E10", "type": "parent-child"}, {"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-079", "title": "Add --worktree flag to cub run", "description": "## Context\nAdd flag to run cub in an isolated worktree.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Create worktree, cd into it, run main loop.\n\n## Implementation Steps\n1. Update src/cub/cli/run.py:\n   - Add --worktree flag\n   - If set, create worktree via WorktreeManager\n   - Change working directory to worktree\n   - Run main loop\n   - Optionally cleanup on exit\n2. Handle:\n   - Worktree already exists\n   - Cleanup on error\n   - Status.json in worktree\n\n## Acceptance Criteria\n- [ ] `cub run --worktree` creates worktree\n- [ ] Run executes in worktree directory\n- [ ] Changes isolated to worktree\n- [ ] Clean exit removes worktree (optional)\n\n## Files Likely Involved\n- src/cub/cli/run.py (update)\n\n## Notes\n- Consider --worktree-keep flag to preserve", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-4", "model:sonnet", "complexity:medium", "logic", "release:v0.24"], "dependencies": [{"depends_on_id": "cub-E10", "type": "parent-child"}, {"depends_on_id": "cub-078", "type": "blocks"}]}
{"id": "cub-080", "title": "Implement --parallel N for concurrent tasks", "description": "## Context\nProcess multiple independent tasks concurrently, each in its own worktree.\n\n## Implementation Hints\n**Recommended Model:** opus\n**Estimated Duration:** 2h\n**Approach:** Find independent tasks, spawn workers in separate worktrees, coordinate results.\n\n## Implementation Steps\n1. Update src/cub/cli/run.py:\n   - Add --parallel N flag\n   - Find N independent tasks (no mutual dependencies)\n   - Create worktree per task\n   - Spawn subprocess per worktree\n   - Wait for completion\n   - Merge results\n2. Create src/cub/core/worktree/parallel.py:\n   - ParallelRunner class\n   - spawn_worker(task, worktree)\n   - wait_all()\n   - collect_results()\n3. Handle:\n   - Task dependencies\n   - Worker failures\n   - Result merging\n\n## Acceptance Criteria\n- [ ] `cub run --parallel 3` processes 3 tasks at once\n- [ ] Only independent tasks run in parallel\n- [ ] Each task in own worktree\n- [ ] Results merged correctly\n- [ ] Failures handled gracefully\n\n## Files Likely Involved\n- src/cub/cli/run.py (update)\n- src/cub/core/worktree/parallel.py (new)\n\n## Notes\n- Complex coordination logic\n- Consider asyncio or concurrent.futures\n- Ensure logging from all workers captured", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-4", "model:opus", "complexity:high", "logic", "release:v0.24"], "dependencies": [{"depends_on_id": "cub-E10", "type": "parent-child"}, {"depends_on_id": "cub-079", "type": "blocks"}]}
{"id": "cub-081", "title": "Implement cub worktree subcommands", "description": "## Context\nCreate CLI commands for worktree management.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Wrap WorktreeManager methods in CLI commands.\n\n## Implementation Steps\n1. Create src/cub/cli/worktree.py with:\n   - worktree list - show all worktrees\n   - worktree clean - remove merged worktrees\n   - worktree create <branch> - manually create\n   - worktree remove <path> - manually remove\n2. Format output with Rich tables\n\n## Acceptance Criteria\n- [ ] `cub worktree list` shows worktrees\n- [ ] `cub worktree clean` removes merged\n- [ ] `cub worktree create` works\n- [ ] `cub worktree remove` works\n\n## Files Likely Involved\n- src/cub/cli/worktree.py (new)\n- src/cub/cli/__init__.py (register)\n\n## Notes\n- Show task association in list", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:haiku", "complexity:low", "ui", "release:v0.24"], "dependencies": [{"depends_on_id": "cub-E10", "type": "parent-child"}, {"depends_on_id": "cub-078", "type": "blocks"}]}
{"id": "cub-E11", "title": "v0.25: Sandbox Mode", "description": "# Epic: Sandbox Mode (v0.25)\n\n## Overview\nSafe autonomous execution via Docker-based sandboxing with pluggable provider interface.\n\n## Goals\n- Run cub in isolated Docker container\n- Review changes before applying\n- Design pluggable provider interface\n\n## Success Criteria\n- `cub run --sandbox` executes in Docker isolation\n- Changes can be reviewed and applied or discarded\n- Provider interface supports future backends\n\n## Exit Criteria\n- All tasks in this epic closed\n- Can run overnight with confidence", "status": "open", "priority": 1, "issue_type": "epic", "labels": ["release:v0.25", "phase-5"], "dependencies": [{"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-082", "title": "Implement SandboxProvider protocol and registry", "description": "## Context\nDefine the provider protocol for sandbox execution. Enables future providers (Sprites, Firecracker).\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Mirror TaskBackend pattern with capabilities model.\n\n## Implementation Steps\n1. Create src/cub/core/sandbox/__init__.py\n2. Create src/cub/core/sandbox/models.py with:\n   - SandboxCapabilities model\n   - SandboxStatus model\n3. Create src/cub/core/sandbox/provider.py with:\n   - SandboxProvider Protocol\n   - Methods: start, stop, status, logs, diff, export, cleanup\n   - Properties: name, capabilities\n   - Registry and factory functions\n\n## Acceptance Criteria\n- [ ] SandboxProvider protocol complete\n- [ ] SandboxCapabilities defines all features\n- [ ] SandboxStatus captures runtime state\n- [ ] Registry pattern works\n\n## Files Likely Involved\n- src/cub/core/sandbox/__init__.py (new)\n- src/cub/core/sandbox/models.py (new)\n- src/cub/core/sandbox/provider.py (new)\n\n## Notes\n- Reference specs/roadmap/sandbox-mode.md for interface", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-5", "model:sonnet", "complexity:medium", "logic", "release:v0.25"], "dependencies": [{"depends_on_id": "cub-E11", "type": "parent-child"}, {"depends_on_id": "cub-E07", "type": "blocks"}]}
{"id": "cub-083", "title": "Implement DockerProvider for sandbox", "description": "## Context\nImplement Docker-based sandbox provider - the primary sandbox backend.\n\n## Implementation Hints\n**Recommended Model:** opus\n**Estimated Duration:** 2h\n**Approach:** Use Docker CLI via subprocess. Copy project to volume, run cub in container.\n\n## Implementation Steps\n1. Create src/cub/core/sandbox/docker.py with:\n   - DockerProvider class implementing SandboxProvider\n   - start(): create volume, copy project, start container\n   - stop(): stop container\n   - status(): docker inspect\n   - logs(): docker logs\n   - diff(): git diff in container\n   - export(): copy changed files out\n   - cleanup(): remove container and volume\n2. Docker configuration:\n   - Memory/CPU limits\n   - Network isolation option\n   - Security options\n3. Register as 'docker' provider\n\n## Acceptance Criteria\n- [ ] Can start sandbox container\n- [ ] Project copied to container\n- [ ] Can stream logs\n- [ ] Can get diff of changes\n- [ ] Can export changes\n- [ ] Cleanup removes all resources\n- [ ] Resource limits enforced\n\n## Files Likely Involved\n- src/cub/core/sandbox/docker.py (new)\n\n## Notes\n- Reference specs/roadmap/sandbox-mode.md for Docker commands\n- Use docker run --rm for cleanup\n- Consider cub:latest image", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-5", "model:opus", "complexity:high", "logic", "release:v0.25"], "dependencies": [{"depends_on_id": "cub-E11", "type": "parent-child"}, {"depends_on_id": "cub-082", "type": "blocks"}]}
{"id": "cub-084", "title": "Add --sandbox flag to cub run", "description": "## Context\nAdd flag to run cub in sandboxed Docker environment.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Start sandbox, run cub inside, stream output.\n\n## Implementation Steps\n1. Update src/cub/cli/run.py:\n   - Add --sandbox flag\n   - Add --no-network flag\n   - If --sandbox, use DockerProvider\n   - Start sandbox\n   - Stream logs to terminal\n   - On completion, show diff summary\n2. Handle:\n   - Docker not available\n   - Container failures\n   - Interrupt (Ctrl+C)\n\n## Acceptance Criteria\n- [ ] `cub run --sandbox` runs in Docker\n- [ ] Output streamed to terminal\n- [ ] Diff shown on completion\n- [ ] Network isolation with --no-network\n- [ ] Clean error if Docker not available\n\n## Files Likely Involved\n- src/cub/cli/run.py (update)\n\n## Notes\n- Consider --sandbox-keep to preserve container", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-5", "model:sonnet", "complexity:medium", "logic", "release:v0.25"], "dependencies": [{"depends_on_id": "cub-E11", "type": "parent-child"}, {"depends_on_id": "cub-083", "type": "blocks"}]}
{"id": "cub-085", "title": "Implement cub sandbox subcommands", "description": "## Context\nCreate CLI commands for sandbox management.\n\n## Implementation Hints\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Wrap SandboxProvider methods in CLI commands.\n\n## Implementation Steps\n1. Create src/cub/cli/sandbox.py with:\n   - sandbox logs - stream container logs\n   - sandbox status - show sandbox state\n   - sandbox diff - show changes made\n   - sandbox export <path> - export changes\n   - sandbox apply - apply changes to project\n   - sandbox clean - remove sandbox\n2. Format output appropriately\n\n## Acceptance Criteria\n- [ ] `cub sandbox logs` streams logs\n- [ ] `cub sandbox diff` shows changes\n- [ ] `cub sandbox apply` applies changes\n- [ ] `cub sandbox clean` removes sandbox\n- [ ] Clear error if no sandbox running\n\n## Files Likely Involved\n- src/cub/cli/sandbox.py (new)\n- src/cub/cli/__init__.py (register)\n\n## Notes\n- apply copies files from sandbox to project\n- Consider confirmation prompt for apply", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-5", "model:sonnet", "complexity:medium", "ui", "release:v0.25"], "dependencies": [{"depends_on_id": "cub-E11", "type": "parent-child"}, {"depends_on_id": "cub-083", "type": "blocks"}]}
{"id": "cub-086", "title": "Create Docker image for cub sandbox", "description": "## Context\nCreate the Docker image used for sandbox execution.\n\n## Implementation Hints\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Dockerfile with cub and dependencies pre-installed.\n\n## Implementation Steps\n1. Create docker/Dockerfile with:\n   - Base image (python:3.11-slim)\n   - Install system deps (git, jq)\n   - Install cub (pip install)\n   - Install harness CLIs (claude, codex)\n   - Set working directory\n   - Entry point\n2. Create docker-compose.yml for testing\n3. Add to CI for building/pushing image\n\n## Acceptance Criteria\n- [ ] Dockerfile builds successfully\n- [ ] Image contains cub and deps\n- [ ] Can run cub inside container\n- [ ] Image size reasonable (<500MB)\n- [ ] CI builds and pushes image\n\n## Files Likely Involved\n- docker/Dockerfile (new)\n- docker/docker-compose.yml (new)\n- .github/workflows/docker.yml (new)\n\n## Notes\n- Consider multi-stage build for size\n- Tag as cub:latest and cub:v0.25", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-5", "model:haiku", "complexity:low", "setup", "release:v0.25"], "dependencies": [{"depends_on_id": "cub-E11", "type": "parent-child"}, {"depends_on_id": "cub-068", "type": "blocks"}]}
