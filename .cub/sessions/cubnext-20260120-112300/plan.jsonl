{"id": "cub-f7m", "title": "Foundation: Models, Store, and CLI Skeleton", "description": "## Context\nEstablish the core data structures and persistence layer for Toolsmith. This epic provides the foundation that all other components build upon.\n\n## Goals\n- Define Pydantic models for Tool and Catalog\n- Implement ToolsmithStore for JSON persistence\n- Create CLI skeleton with stub commands\n- Achieve test coverage for core components\n\n## Success Criteria\n- [ ] Tool and Catalog models validate correctly\n- [ ] Store can save/load catalog to `.cub/toolsmith/catalog.json`\n- [ ] `cub toolsmith` command group is registered\n- [ ] Unit tests pass for models and store", "status": "open", "priority": 0, "issue_type": "epic", "labels": ["phase-1", "complexity:medium", "setup"]}
{"id": "cub-f7m.1", "title": "Create Tool, ToolType, and Catalog Pydantic models", "description": "## Context\nDefine the core data models that represent tools and the catalog. These models are used throughout Toolsmith for data validation, serialization, and type safety.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Follow existing Cub patterns from `cub/core/captures/models.py`. Use Pydantic v2 with `model_config`, Field validators, and enums for type safety.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/__init__.py` (empty, for package)\n2. Create `src/cub/core/toolsmith/models.py`\n3. Define `ToolType` enum (MCP_SERVER, SKILL)\n4. Define `Tool` model with all fields from architecture\n5. Define `Catalog` model with version, timestamps, and tools list\n6. Add `model_config` for JSON serialization settings\n\n## Acceptance Criteria\n- [ ] `ToolType` enum has `MCP_SERVER` and `SKILL` values\n- [ ] `Tool` model has: id, name, source, source_url, tool_type, description, install_hint, tags, last_seen\n- [ ] `Catalog` model has: version, last_sync, sources_synced, tools\n- [ ] Models can be serialized to/from JSON via `model_dump()` / `model_validate()`\n- [ ] ID validation ensures format `{source}:{slug}`\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/__init__.py` (new)\n- `src/cub/core/toolsmith/models.py` (new)\n\n## Notes\n- Reference `cub/core/captures/models.py` for Pydantic v2 patterns\n- Use `datetime` from stdlib, ensure timezone handling matches Cub conventions\n- Keep models simple - no business logic, just data + validation", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "model"], "dependencies": [{"depends_on_id": "cub-f7m", "type": "parent-child"}]}
{"id": "cub-f7m.2", "title": "Implement ToolsmithStore with load/save/search", "description": "## Context\nThe ToolsmithStore provides persistence for the tool catalog, following the same patterns as CaptureStore. It handles loading, saving, and searching the local catalog.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Follow `cub/core/captures/store.py` patterns. Use pathlib for file operations, implement atomic writes for safety.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/store.py`\n2. Implement `ToolsmithStore.__init__(self, toolsmith_dir: Path)`\n3. Implement `load_catalog() -> Catalog` (return empty catalog if file missing)\n4. Implement `save_catalog(catalog: Catalog)` with atomic write\n5. Implement `search(query: str) -> list[Tool]` with keyword matching\n6. Add `@classmethod default(cls)` factory for `.cub/toolsmith/`\n7. Create `src/cub/core/toolsmith/search.py` for search logic (optional, can be in store)\n\n## Acceptance Criteria\n- [ ] `load_catalog()` returns empty Catalog when file doesn't exist\n- [ ] `load_catalog()` returns populated Catalog when file exists\n- [ ] `save_catalog()` writes valid JSON to `.cub/toolsmith/catalog.json`\n- [ ] `save_catalog()` creates directory if it doesn't exist\n- [ ] `search()` matches query against tool name and description (case-insensitive)\n- [ ] `search()` returns empty list when no matches\n- [ ] `ToolsmithStore.default()` returns store at `.cub/toolsmith/`\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/store.py` (new)\n- `src/cub/core/toolsmith/search.py` (new, optional)\n\n## Notes\n- Use `json.dumps(catalog.model_dump(), indent=2)` for human-readable output\n- For atomic writes: write to temp file, then rename\n- Search should split query into terms and match if ALL terms appear in name OR description", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:sonnet", "complexity:medium", "logic"], "dependencies": [{"depends_on_id": "cub-f7m", "type": "parent-child"}, {"depends_on_id": "cub-f7m.1", "type": "blocks"}]}
{"id": "cub-f7m.3", "title": "Create CLI skeleton and register with main app", "description": "## Context\nCreate the Typer CLI commands for Toolsmith and wire them into the main Cub CLI. Commands will be stubs initially, wired to real implementation in Phase 3.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Follow existing Cub CLI patterns from `cub/cli/`. Create a Typer sub-app and register it in `cub/cli/__init__.py`.\n\n## Implementation Steps\n1. Create `src/cub/cli/toolsmith.py`\n2. Create Typer app: `app = typer.Typer(name=\"toolsmith\", help=\"Discover and catalog tools\")`\n3. Add `sync` command stub with `--source` option\n4. Add `search` command stub with query argument and `--live`, `--source` options\n5. Add `stats` command stub\n6. Register in `src/cub/cli/__init__.py` under appropriate help panel\n7. Verify `cub toolsmith --help` works\n\n## Acceptance Criteria\n- [ ] `cub toolsmith --help` shows available commands\n- [ ] `cub toolsmith sync --help` shows sync options\n- [ ] `cub toolsmith search --help` shows search options\n- [ ] `cub toolsmith stats --help` shows stats description\n- [ ] Commands print \"Not implemented yet\" placeholder\n- [ ] Registered under \"Manage Your Roadmap\" or new panel in CLI\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/cli/toolsmith.py` (new)\n- `src/cub/cli/__init__.py` (modify to register)\n\n## Notes\n- Use `Annotated[str, typer.Argument()]` for modern Typer syntax\n- Add `rich_help_panel` for proper grouping\n- Stub implementations should use `console.print(\"[yellow]Not implemented yet[/yellow]\")`", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "cli"], "dependencies": [{"depends_on_id": "cub-f7m", "type": "parent-child"}]}
{"id": "cub-f7m.4", "title": "Write unit tests for models and store", "description": "## Context\nEnsure the foundation components are solid with comprehensive unit tests. These tests validate models and store behavior before building on top of them.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Follow existing test patterns in `tests/`. Use pytest fixtures, tmp_path for file operations.\n\n## Implementation Steps\n1. Create `tests/test_toolsmith/` directory\n2. Create `tests/test_toolsmith/__init__.py`\n3. Create `tests/test_toolsmith/test_models.py`\n4. Create `tests/test_toolsmith/test_store.py`\n5. Test Tool model validation (valid/invalid IDs, required fields)\n6. Test Catalog model (empty, with tools, serialization roundtrip)\n7. Test ToolsmithStore load/save (empty catalog, populated catalog)\n8. Test ToolsmithStore search (matches, no matches, case insensitivity)\n\n## Acceptance Criteria\n- [ ] Test Tool model with valid data passes\n- [ ] Test Tool model with invalid ID format raises ValidationError\n- [ ] Test Catalog serialization roundtrip preserves data\n- [ ] Test store load returns empty catalog when file missing\n- [ ] Test store save creates file and directory\n- [ ] Test store load after save returns same data\n- [ ] Test search finds tools by name\n- [ ] Test search finds tools by description\n- [ ] Test search is case-insensitive\n- [ ] Test search returns empty list when no matches\n- [ ] All tests pass: `pytest tests/test_toolsmith/ -v`\n\n## Files Likely Involved\n- `tests/test_toolsmith/__init__.py` (new)\n- `tests/test_toolsmith/test_models.py` (new)\n- `tests/test_toolsmith/test_store.py` (new)\n\n## Notes\n- Use `tmp_path` fixture for store tests to avoid polluting real filesystem\n- Create helper fixtures for sample Tool and Catalog objects\n- Test edge cases: empty strings, missing optional fields, Unicode in names", "status": "open", "priority": 0, "issue_type": "task", "labels": ["phase-1", "model:haiku", "complexity:low", "test", "checkpoint"], "dependencies": [{"depends_on_id": "cub-f7m", "type": "parent-child"}, {"depends_on_id": "cub-f7m.2", "type": "blocks"}]}
{"id": "cub-k3p", "title": "Sources: Protocol and 5 Source Adapters", "description": "## Context\nImplement the source abstraction layer and concrete adapters for all 5 curated sources. Each adapter fetches tool metadata from its respective source and transforms it to the Tool model.\n\n## Goals\n- Define ToolSource protocol for pluggable adapters\n- Implement source registry pattern\n- Create adapters for: MCP Official, Smithery, Glama, SkillsMP, ClawdHub\n- Test each adapter with fixtures\n\n## Success Criteria\n- [ ] ToolSource protocol defines fetch_tools() and search_live()\n- [ ] All 5 sources are implemented and registered\n- [ ] Each source can fetch real tools from its endpoint\n- [ ] Tests with fixtures verify parsing logic", "status": "open", "priority": 1, "issue_type": "epic", "labels": ["phase-2", "complexity:high", "api"]}
{"id": "cub-k3p.1", "title": "Define ToolSource protocol and source registry", "description": "## Context\nCreate the abstraction layer for tool sources, following the same pattern as TaskBackend. This enables pluggable source adapters and a registry for discovering available sources.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Follow `cub/core/tasks/backend.py` patterns for Protocol and registry.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/sources/__init__.py`\n2. Create `src/cub/core/toolsmith/sources/base.py`\n3. Define `ToolSource` Protocol with `name`, `fetch_tools()`, `search_live()`\n4. Implement source registry with `register_source()` decorator\n5. Implement `get_source(name)` and `list_sources()` functions\n6. Implement `get_all_sources()` to return all registered sources\n\n## Acceptance Criteria\n- [ ] `ToolSource` Protocol is runtime_checkable\n- [ ] `ToolSource.name` property returns source identifier\n- [ ] `ToolSource.fetch_tools()` returns `list[Tool]`\n- [ ] `ToolSource.search_live(query)` returns `list[Tool]`\n- [ ] `@register_source(name)` decorator registers a source class\n- [ ] `get_source(name)` returns source instance or raises ValueError\n- [ ] `list_sources()` returns list of registered source names\n- [ ] `get_all_sources()` returns list of all source instances\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/sources/__init__.py` (new)\n- `src/cub/core/toolsmith/sources/base.py` (new)\n\n## Notes\n- Use `typing.Protocol` with `@runtime_checkable` decorator\n- Registry pattern: module-level dict `_sources: dict[str, type[ToolSource]]`\n- Sources are instantiated on demand, not at import time", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:haiku", "complexity:low", "logic"], "dependencies": [{"depends_on_id": "cub-k3p", "type": "parent-child"}, {"depends_on_id": "cub-f7m.1", "type": "blocks"}]}
{"id": "cub-k3p.2", "title": "Implement MCP Official source adapter", "description": "## Context\nImplement the first source adapter for the official MCP servers repository. This is likely the simplest source as it's a well-structured GitHub repo with a known format.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Fetch the servers list from GitHub raw content or API. Parse the README or servers.json to extract tool metadata.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/sources/mcp_official.py`\n2. Research the MCP servers repo structure (github.com/modelcontextprotocol/servers)\n3. Implement `MCPOfficialSource` class implementing `ToolSource`\n4. Fetch server list (README parsing or JSON if available)\n5. Transform each entry to `Tool` model\n6. Implement `search_live()` (can filter fetch_tools results)\n7. Create test fixture with sample response\n8. Write tests for parsing logic\n\n## Acceptance Criteria\n- [ ] `MCPOfficialSource` is registered as \"mcp-official\"\n- [ ] `fetch_tools()` returns list of Tool objects from real endpoint\n- [ ] Each Tool has: id, name, source=\"mcp-official\", source_url, tool_type=MCP_SERVER\n- [ ] `search_live()` filters tools by query\n- [ ] Handles network errors gracefully (returns empty list or raises)\n- [ ] Test with fixture verifies parsing of sample response\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/sources/mcp_official.py` (new)\n- `tests/test_toolsmith/test_sources/__init__.py` (new)\n- `tests/test_toolsmith/test_sources/test_mcp_official.py` (new)\n- `tests/test_toolsmith/fixtures/mcp_official_response.json` (new)\n\n## Notes\n- Use httpx for HTTP requests\n- MCP repo may have a servers.json or similar structured file - check first\n- If only README, parse markdown tables or lists\n- Tool ID format: `mcp-official:{server-name}`", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "api", "checkpoint"], "dependencies": [{"depends_on_id": "cub-k3p", "type": "parent-child"}, {"depends_on_id": "cub-k3p.1", "type": "blocks"}]}
{"id": "cub-k3p.3", "title": "Implement Smithery.ai source adapter", "description": "## Context\nImplement the source adapter for Smithery.ai, a community MCP marketplace. This likely requires HTML scraping or discovering an API.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Inspect smithery.ai to find API endpoints or scrape the listing pages. Look for JSON data embedded in pages or XHR requests.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/sources/smithery.py`\n2. Research smithery.ai structure (inspect network requests, look for API)\n3. Implement `SmitherySource` class implementing `ToolSource`\n4. Fetch server list from API or scrape listing pages\n5. Transform each entry to `Tool` model\n6. Implement `search_live()` (use site search if available, else filter)\n7. Create test fixture with sample response\n8. Write tests for parsing logic\n\n## Acceptance Criteria\n- [ ] `SmitherySource` is registered as \"smithery\"\n- [ ] `fetch_tools()` returns list of Tool objects\n- [ ] Each Tool has: id, name, source=\"smithery\", source_url, tool_type=MCP_SERVER\n- [ ] Description and install_hint populated when available\n- [ ] `search_live()` searches tools by query\n- [ ] Handles network errors gracefully\n- [ ] Test with fixture verifies parsing\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/sources/smithery.py` (new)\n- `tests/test_toolsmith/test_sources/test_smithery.py` (new)\n- `tests/test_toolsmith/fixtures/smithery_response.html` or `.json` (new)\n\n## Notes\n- Check for `application/json` responses in network tab\n- If scraping HTML, use simple string parsing or regex - avoid heavy dependencies\n- Tool ID format: `smithery:{server-slug}`\n- Respect rate limits - add delay if needed", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "api"], "dependencies": [{"depends_on_id": "cub-k3p", "type": "parent-child"}, {"depends_on_id": "cub-k3p.1", "type": "blocks"}]}
{"id": "cub-k3p.4", "title": "Implement Glama.ai source adapter", "description": "## Context\nImplement the source adapter for Glama.ai, an MCP directory. Similar approach to Smithery - find API or scrape.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Inspect glama.ai to find API endpoints or scrape the listing pages.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/sources/glama.py`\n2. Research glama.ai structure (inspect network requests, look for API)\n3. Implement `GlamaSource` class implementing `ToolSource`\n4. Fetch server list from API or scrape listing pages\n5. Transform each entry to `Tool` model\n6. Implement `search_live()`\n7. Create test fixture with sample response\n8. Write tests for parsing logic\n\n## Acceptance Criteria\n- [ ] `GlamaSource` is registered as \"glama\"\n- [ ] `fetch_tools()` returns list of Tool objects\n- [ ] Each Tool has: id, name, source=\"glama\", source_url, tool_type=MCP_SERVER\n- [ ] `search_live()` searches tools by query\n- [ ] Handles network errors gracefully\n- [ ] Test with fixture verifies parsing\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/sources/glama.py` (new)\n- `tests/test_toolsmith/test_sources/test_glama.py` (new)\n- `tests/test_toolsmith/fixtures/glama_response.html` or `.json` (new)\n\n## Notes\n- Similar approach to Smithery adapter\n- Tool ID format: `glama:{server-slug}`\n- May share common parsing utilities with other sources", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "api"], "dependencies": [{"depends_on_id": "cub-k3p", "type": "parent-child"}, {"depends_on_id": "cub-k3p.1", "type": "blocks"}]}
{"id": "cub-k3p.5", "title": "Implement SkillsMP source adapter", "description": "## Context\nImplement the source adapter for skillsmp.com, a Claude skills marketplace. This is the first SKILL type source (vs MCP_SERVER).\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Inspect skillsmp.com to find API endpoints or scrape listings.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/sources/skillsmp.py`\n2. Research skillsmp.com structure (inspect network requests, look for API)\n3. Implement `SkillsMPSource` class implementing `ToolSource`\n4. Fetch skill list from API or scrape listing pages\n5. Transform each entry to `Tool` model with tool_type=SKILL\n6. Implement `search_live()`\n7. Create test fixture with sample response\n8. Write tests for parsing logic\n\n## Acceptance Criteria\n- [ ] `SkillsMPSource` is registered as \"skillsmp\"\n- [ ] `fetch_tools()` returns list of Tool objects\n- [ ] Each Tool has: id, name, source=\"skillsmp\", source_url, tool_type=SKILL\n- [ ] `search_live()` searches skills by query\n- [ ] Handles network errors gracefully\n- [ ] Test with fixture verifies parsing\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/sources/skillsmp.py` (new)\n- `tests/test_toolsmith/test_sources/test_skillsmp.py` (new)\n- `tests/test_toolsmith/fixtures/skillsmp_response.html` or `.json` (new)\n\n## Notes\n- First SKILL type source - ensure tool_type is set correctly\n- Tool ID format: `skillsmp:{skill-slug}`\n- Install hint might be `claude skill add {name}` or similar", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "api"], "dependencies": [{"depends_on_id": "cub-k3p", "type": "parent-child"}, {"depends_on_id": "cub-k3p.1", "type": "blocks"}]}
{"id": "cub-k3p.6", "title": "Implement ClawdHub source adapter", "description": "## Context\nImplement the source adapter for ClawdHub, a community GitHub repository for Claude skills.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Parse the ClawdHub GitHub repo structure to find skills. May have a catalog file or need to parse directory structure.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/sources/clawdhub.py`\n2. Research ClawdHub repo structure on GitHub\n3. Implement `ClawdHubSource` class implementing `ToolSource`\n4. Fetch skill list from repo (README, catalog file, or directory listing)\n5. Transform each entry to `Tool` model with tool_type=SKILL\n6. Implement `search_live()`\n7. Create test fixture with sample response\n8. Write tests for parsing logic\n\n## Acceptance Criteria\n- [ ] `ClawdHubSource` is registered as \"clawdhub\"\n- [ ] `fetch_tools()` returns list of Tool objects\n- [ ] Each Tool has: id, name, source=\"clawdhub\", source_url, tool_type=SKILL\n- [ ] `search_live()` searches skills by query\n- [ ] Handles network errors gracefully\n- [ ] Test with fixture verifies parsing\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/sources/clawdhub.py` (new)\n- `tests/test_toolsmith/test_sources/test_clawdhub.py` (new)\n- `tests/test_toolsmith/fixtures/clawdhub_response.json` or `.md` (new)\n\n## Notes\n- Similar to MCP Official - GitHub repo parsing\n- Tool ID format: `clawdhub:{skill-slug}`\n- May use GitHub raw content URLs for simplicity", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-2", "model:sonnet", "complexity:medium", "api"], "dependencies": [{"depends_on_id": "cub-k3p", "type": "parent-child"}, {"depends_on_id": "cub-k3p.1", "type": "blocks"}]}
{"id": "cub-v9s", "title": "Service Layer: Orchestration and CLI Wiring", "description": "## Context\nImplement the ToolsmithService that orchestrates sync and search operations, then wire the CLI commands to use the service.\n\n## Goals\n- Implement ToolsmithService with sync and search logic\n- Handle catalog merging and deduplication\n- Implement live fallback for search\n- Wire CLI commands to service\n- Write integration tests\n\n## Success Criteria\n- [ ] Service can sync all sources and merge into catalog\n- [ ] Service can search with live fallback\n- [ ] CLI commands work end-to-end\n- [ ] Integration tests verify full workflow", "status": "open", "priority": 1, "issue_type": "epic", "labels": ["phase-3", "complexity:high", "logic"]}
{"id": "cub-v9s.1", "title": "Implement ToolsmithService sync logic", "description": "## Context\nThe ToolsmithService orchestrates sync operations across multiple sources and merges results into the catalog. This is the core business logic for catalog management.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Create service class that coordinates store and sources. Handle merging with update-or-insert logic.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/service.py`\n2. Define `SyncResult` model (tools_added, tools_updated, errors)\n3. Define `CatalogStats` model (total_tools, by_source, by_type, last_sync)\n4. Implement `ToolsmithService.__init__(store, sources)`\n5. Implement `sync(source_names=None) -> SyncResult`\n   - Fetch from each source (or specified sources)\n   - Merge into catalog (update existing by ID, add new)\n   - Update sources_synced timestamps\n   - Save catalog\n6. Implement `stats() -> CatalogStats`\n\n## Acceptance Criteria\n- [ ] `ToolsmithService` takes store and sources in constructor\n- [ ] `sync()` with no args syncs all registered sources\n- [ ] `sync([\"smithery\"])` syncs only specified source\n- [ ] Sync updates existing tools (matched by ID) and adds new ones\n- [ ] Sync updates `last_sync` and `sources_synced` timestamps\n- [ ] `SyncResult` reports tools_added, tools_updated, any errors\n- [ ] `stats()` returns catalog statistics\n- [ ] Handles source errors gracefully (continues with other sources)\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/service.py` (new)\n- `src/cub/core/toolsmith/models.py` (add SyncResult, CatalogStats)\n\n## Notes\n- Tool ID is the unique key for merge logic\n- Update `last_seen` timestamp on existing tools during sync\n- Consider adding `tools_removed` for tools no longer in source (future)", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "logic"], "dependencies": [{"depends_on_id": "cub-v9s", "type": "parent-child"}, {"depends_on_id": "cub-f7m.2", "type": "blocks"}, {"depends_on_id": "cub-k3p.1", "type": "blocks"}]}
{"id": "cub-v9s.2", "title": "Implement search with live fallback", "description": "## Context\nAdd search functionality to ToolsmithService with optional live fallback when local search returns no results.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** First search local catalog, then optionally query sources directly if no results.\n\n## Implementation Steps\n1. Add `search(query, live_fallback=True) -> list[Tool]` to ToolsmithService\n2. First, search local catalog via store.search()\n3. If results found, return them\n4. If no results and live_fallback=True:\n   - Query each source's search_live()\n   - Merge results (dedupe by ID)\n   - Optionally add new tools to catalog\n5. Return combined results\n\n## Acceptance Criteria\n- [ ] `search(query)` searches local catalog first\n- [ ] Returns local results if found\n- [ ] With `live_fallback=True` (default), queries sources when local empty\n- [ ] With `live_fallback=False`, only searches local catalog\n- [ ] Live results are deduplicated by tool ID\n- [ ] Handles source errors gracefully (continues with other sources)\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/service.py` (modify)\n\n## Notes\n- Live fallback should be optional to support offline mode\n- Consider caching live results in catalog (with flag to distinguish)\n- Multiple sources may return same tool - dedupe by ID, prefer local", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "logic"], "dependencies": [{"depends_on_id": "cub-v9s", "type": "parent-child"}, {"depends_on_id": "cub-v9s.1", "type": "blocks"}]}
{"id": "cub-v9s.3", "title": "Wire CLI commands to service", "description": "## Context\nConnect the CLI stub commands to the real ToolsmithService implementation. Add proper output formatting.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Replace stubs with service calls. Use Rich for formatted output.\n\n## Implementation Steps\n1. Update `src/cub/cli/toolsmith.py`\n2. Create service instance with default store and all sources\n3. Implement `sync` command:\n   - Call service.sync()\n   - Display progress and results\n4. Implement `search` command:\n   - Call service.search(query, live_fallback=live)\n   - Display results in rich format\n5. Implement `stats` command:\n   - Call service.stats()\n   - Display statistics table\n6. Add `--source` filtering where applicable\n\n## Acceptance Criteria\n- [ ] `cub toolsmith sync` syncs all sources and shows results\n- [ ] `cub toolsmith sync --source smithery` syncs only Smithery\n- [ ] `cub toolsmith search \"browser\"` searches and displays results\n- [ ] `cub toolsmith search \"browser\" --live` forces live search\n- [ ] `cub toolsmith stats` shows catalog statistics\n- [ ] Output uses Rich formatting (tables, colors)\n- [ ] Error messages are user-friendly\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/cli/toolsmith.py` (modify)\n\n## Notes\n- Follow output patterns from other Cub CLI commands\n- Use Rich Table for search results and stats\n- Show progress indicator during sync\n- Include tool count and timing in sync output", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "cli", "checkpoint"], "dependencies": [{"depends_on_id": "cub-v9s", "type": "parent-child"}, {"depends_on_id": "cub-f7m.3", "type": "blocks"}, {"depends_on_id": "cub-v9s.2", "type": "blocks"}]}
{"id": "cub-v9s.4", "title": "Write integration tests for full workflow", "description": "## Context\nWrite integration tests that verify the complete workflow: sync from sources, search catalog, CLI commands.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Use httpx mock or responses library to mock HTTP calls. Test full service flow.\n\n## Implementation Steps\n1. Create `tests/test_toolsmith/test_integration.py`\n2. Create mock responses for each source\n3. Test full sync workflow (all sources)\n4. Test search workflow (local and live fallback)\n5. Test CLI commands with mocked service\n6. Test error handling (source failures)\n\n## Acceptance Criteria\n- [ ] Integration test syncs from mocked sources\n- [ ] Integration test verifies tools appear in catalog after sync\n- [ ] Integration test verifies search finds synced tools\n- [ ] Integration test verifies live fallback works\n- [ ] Integration test verifies partial sync on source failure\n- [ ] CLI command tests verify output format\n- [ ] All tests pass: `pytest tests/test_toolsmith/test_integration.py -v`\n\n## Files Likely Involved\n- `tests/test_toolsmith/test_integration.py` (new)\n- `tests/test_toolsmith/conftest.py` (new, for shared fixtures)\n\n## Notes\n- Use `pytest-httpx` or `respx` for mocking HTTP\n- Create comprehensive fixtures representing real source responses\n- Test both happy path and error cases\n- Consider using `typer.testing.CliRunner` for CLI tests", "status": "open", "priority": 1, "issue_type": "task", "labels": ["phase-3", "model:sonnet", "complexity:medium", "test"], "dependencies": [{"depends_on_id": "cub-v9s", "type": "parent-child"}, {"depends_on_id": "cub-v9s.3", "type": "blocks"}]}
{"id": "cub-q2w", "title": "Polish: Error Handling, Formatting, and Documentation", "description": "## Context\nProduction-ready polish: improve error handling, add retry logic, enhance output formatting, write documentation, and achieve target test coverage.\n\n## Goals\n- Add Rich formatting for CLI output\n- Implement robust error handling\n- Add retry logic with backoff for HTTP requests\n- Add logging for debugging\n- Write user documentation\n- Achieve 80%+ test coverage on core modules\n\n## Success Criteria\n- [ ] CLI output is well-formatted and user-friendly\n- [ ] Network errors are handled gracefully with retries\n- [ ] Logging helps debug issues\n- [ ] Documentation explains usage\n- [ ] Test coverage meets target", "status": "open", "priority": 2, "issue_type": "epic", "labels": ["phase-4", "complexity:medium", "polish"]}
{"id": "cub-q2w.1", "title": "Add Rich formatting for CLI output", "description": "## Context\nEnhance CLI output with Rich tables, colors, and formatting for better user experience.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Use Rich Table, Panel, and styling for structured output.\n\n## Implementation Steps\n1. Update `src/cub/cli/toolsmith.py`\n2. Create Rich Table for search results (columns: name, source, type, description)\n3. Create Rich Table for stats (sources, counts, last sync)\n4. Add color coding (green for success, yellow for warnings, red for errors)\n5. Add Panel for individual tool details in search output\n6. Add progress bar/spinner for sync operation\n\n## Acceptance Criteria\n- [ ] Search results display in formatted table\n- [ ] Tool descriptions are truncated if too long\n- [ ] Stats display in formatted table\n- [ ] Sync shows progress indicator\n- [ ] Success/warning/error messages are color-coded\n- [ ] Output is readable on standard terminal widths\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/cli/toolsmith.py` (modify)\n\n## Notes\n- Follow Rich patterns from other Cub CLI commands\n- Use `console.print()` consistently\n- Test output width handling for long descriptions\n- Consider `--json` flag for machine-readable output (future)", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:haiku", "complexity:low", "cli"], "dependencies": [{"depends_on_id": "cub-q2w", "type": "parent-child"}, {"depends_on_id": "cub-v9s.3", "type": "blocks"}]}
{"id": "cub-q2w.2", "title": "Add error handling for network and parse failures", "description": "## Context\nAdd robust error handling for network failures, parse errors, and other exceptional conditions throughout Toolsmith.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 1.5h\n**Approach:** Define custom exceptions, add try/except blocks, provide user-friendly error messages.\n\n## Implementation Steps\n1. Create `src/cub/core/toolsmith/exceptions.py`\n2. Define custom exceptions: `ToolsmithError`, `SourceError`, `ParseError`, `NetworkError`\n3. Update source adapters to catch and wrap errors\n4. Update service to handle source errors gracefully\n5. Update CLI to display user-friendly error messages\n6. Add `--debug` flag to show full tracebacks\n\n## Acceptance Criteria\n- [ ] Custom exception hierarchy defined\n- [ ] Network errors are caught and wrapped with context\n- [ ] Parse errors include source name and what failed\n- [ ] Service continues with other sources on single source failure\n- [ ] CLI displays user-friendly error messages\n- [ ] `--debug` flag shows full traceback\n- [ ] No unhandled exceptions reach the user\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/exceptions.py` (new)\n- `src/cub/core/toolsmith/sources/*.py` (modify all)\n- `src/cub/core/toolsmith/service.py` (modify)\n- `src/cub/cli/toolsmith.py` (modify)\n\n## Notes\n- Wrap httpx exceptions in NetworkError\n- Include original exception as `__cause__`\n- Log errors at appropriate levels\n- Consider partial success reporting in SyncResult", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:sonnet", "complexity:medium", "logic"], "dependencies": [{"depends_on_id": "cub-q2w", "type": "parent-child"}, {"depends_on_id": "cub-v9s.3", "type": "blocks"}]}
{"id": "cub-q2w.3", "title": "Implement retry logic with exponential backoff", "description": "## Context\nAdd retry logic with exponential backoff for HTTP requests to handle transient failures gracefully.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 1h\n**Approach:** Create a retry decorator or utility function. Use exponential backoff with jitter.\n\n## Implementation Steps\n1. Create retry utility in `src/cub/core/toolsmith/http.py` or similar\n2. Implement retry decorator with configurable attempts, backoff, jitter\n3. Apply to all HTTP-fetching code in source adapters\n4. Add timeout configuration\n5. Log retry attempts\n\n## Acceptance Criteria\n- [ ] Retry utility implements exponential backoff\n- [ ] Default: 3 retries, 1s base delay, 2x multiplier\n- [ ] Jitter added to prevent thundering herd\n- [ ] Retries only on transient errors (5xx, timeout, connection error)\n- [ ] No retry on 4xx errors (permanent failures)\n- [ ] Retry attempts are logged\n- [ ] Configurable via parameters\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/http.py` (new)\n- `src/cub/core/toolsmith/sources/*.py` (modify to use retry)\n\n## Notes\n- Consider using `tenacity` library if available, else implement manually\n- httpx has built-in timeout support - use it\n- Add reasonable default timeout (30s)\n- Consider circuit breaker pattern for future", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:sonnet", "complexity:medium", "logic"], "dependencies": [{"depends_on_id": "cub-q2w", "type": "parent-child"}, {"depends_on_id": "cub-q2w.2", "type": "blocks"}]}
{"id": "cub-q2w.4", "title": "Add logging for debugging", "description": "## Context\nAdd structured logging throughout Toolsmith for debugging and observability.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Use Python logging module, follow Cub logging patterns.\n\n## Implementation Steps\n1. Review existing Cub logging patterns in `cub/utils/logging.py`\n2. Add logger to each Toolsmith module\n3. Log at appropriate levels:\n   - DEBUG: HTTP requests/responses, parsing details\n   - INFO: Sync started/completed, search queries\n   - WARNING: Partial failures, retries\n   - ERROR: Failed operations\n4. Include relevant context (source name, tool count, timing)\n5. Ensure `--debug` flag enables DEBUG level\n\n## Acceptance Criteria\n- [ ] Each module has its own logger\n- [ ] Sync operations log start, progress, completion\n- [ ] HTTP requests log URL and status (at DEBUG)\n- [ ] Errors include relevant context\n- [ ] `--debug` flag enables verbose logging\n- [ ] Log format matches Cub conventions\n- [ ] mypy passes with strict mode\n\n## Files Likely Involved\n- `src/cub/core/toolsmith/service.py` (modify)\n- `src/cub/core/toolsmith/store.py` (modify)\n- `src/cub/core/toolsmith/sources/*.py` (modify all)\n- `src/cub/cli/toolsmith.py` (modify)\n\n## Notes\n- Use `logging.getLogger(__name__)` pattern\n- Don't log sensitive data (though Toolsmith has none)\n- Consider structured logging for future metrics", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:haiku", "complexity:low", "logic"], "dependencies": [{"depends_on_id": "cub-q2w", "type": "parent-child"}, {"depends_on_id": "cub-v9s.1", "type": "blocks"}]}
{"id": "cub-q2w.5", "title": "Write user documentation", "description": "## Context\nWrite user-facing documentation for Toolsmith: usage guide, command reference, troubleshooting.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 1h\n**Approach:** Add section to README.md or create dedicated docs file.\n\n## Implementation Steps\n1. Decide on location: section in README.md vs separate docs/toolsmith.md\n2. Write overview: what Toolsmith does, when to use it\n3. Write command reference: sync, search, stats with examples\n4. Write configuration section (if any config options)\n5. Write troubleshooting section (common errors, solutions)\n6. Add examples with realistic queries\n\n## Acceptance Criteria\n- [ ] Documentation explains Toolsmith purpose\n- [ ] All CLI commands documented with examples\n- [ ] Common use cases covered\n- [ ] Troubleshooting section addresses likely issues\n- [ ] Examples use realistic queries and show expected output\n- [ ] Documentation is discoverable from main README\n\n## Files Likely Involved\n- `README.md` (modify) or `docs/toolsmith.md` (new)\n- `CLAUDE.md` (add Toolsmith notes if relevant)\n\n## Notes\n- Keep documentation concise and practical\n- Include actual command output examples\n- Link to source documentation for each source\n- Consider adding to `cub toolsmith --help` with longer descriptions", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:haiku", "complexity:low", "docs"], "dependencies": [{"depends_on_id": "cub-q2w", "type": "parent-child"}, {"depends_on_id": "cub-v9s.4", "type": "blocks"}]}
{"id": "cub-q2w.6", "title": "Achieve 80%+ test coverage on core modules", "description": "## Context\nEnsure production-quality test coverage on core Toolsmith modules. Target 80%+ coverage on models, store, service.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 2h\n**Approach:** Run coverage report, identify gaps, add tests for uncovered paths.\n\n## Implementation Steps\n1. Run coverage: `pytest tests/test_toolsmith/ --cov=src/cub/core/toolsmith --cov-report=html`\n2. Review coverage report for gaps\n3. Add tests for uncovered branches and edge cases\n4. Focus on: error paths, edge cases, boundary conditions\n5. Ensure models, store, service all exceed 80%\n6. Source adapters can have lower coverage (network-dependent)\n\n## Acceptance Criteria\n- [ ] `cub/core/toolsmith/models.py` >= 80% coverage\n- [ ] `cub/core/toolsmith/store.py` >= 80% coverage\n- [ ] `cub/core/toolsmith/service.py` >= 80% coverage\n- [ ] `cub/core/toolsmith/search.py` >= 80% coverage (if separate)\n- [ ] Error handling paths are tested\n- [ ] Edge cases are tested (empty catalog, no results, etc.)\n- [ ] All tests pass: `pytest tests/test_toolsmith/ -v`\n\n## Files Likely Involved\n- `tests/test_toolsmith/*.py` (modify/add)\n\n## Notes\n- Don't chase 100% coverage - focus on meaningful tests\n- Source adapters may have lower coverage due to HTTP mocking complexity\n- Use `# pragma: no cover` sparingly for truly untestable code\n- Consider property-based testing for models (hypothesis)", "status": "open", "priority": 2, "issue_type": "task", "labels": ["phase-4", "model:sonnet", "complexity:medium", "test", "checkpoint"], "dependencies": [{"depends_on_id": "cub-q2w", "type": "parent-child"}, {"depends_on_id": "cub-v9s.4", "type": "blocks"}]}
