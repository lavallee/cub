

I'll start by claiming the task and exploring the codebase to understand the existing patterns.Now let me check the TaskStatus enum and the `__init__.py` for exports:Now I have everything I need. Let me implement the `DependencyGraph` class and tests.Now let me write the comprehensive tests:Now let me run the tests and type checking:All 39 tests pass. Now let me run type checking and linting:All checks pass. Now close the task and commit:<promise>COMPLETE</promise>

**Summary:** Built the `DependencyGraph` class in `src/cub/core/tasks/graph.py` with all required methods:

- **`direct_unblocks(task_id)`** — reverse edge lookup returning direct dependents
- **`transitive_unblocks(task_id)`** — BFS through reverse edges for all transitively unblocked tasks
- **`root_blockers(limit=5)`** — open tasks sorted by transitive unblock count
- **`chains(limit=5)`** — DFS to find longest dependency paths, deduplicated
- **`would_become_ready(task_id)`** — tasks whose ALL deps would be satisfied if task_id were closed
- **`has_cycle()`** — three-color DFS cycle detection
- **`stats`** property — node count, edge count, max chain depth

Tests: 39 tests across 8 test classes covering empty, single task, linear chain, diamond, forest, cycle, mixed open/closed, and edge cases. All pass, type checking clean, lint clean.