{
  "version": 1,
  "id": "cub-n6x.6",
  "title": "Add build failure detection and retry logic to cub pr",
  "lineage": {
    "spec_file": null,
    "plan_file": null,
    "epic_id": "cub-n6x"
  },
  "task": {
    "title": "Add build failure detection and retry logic to cub pr",
    "description": "The `cub pr` command currently creates pull requests but has no visibility into CI check status or automated recovery from transient failures. This means flaky tests, rate limits, and temporary service issues require manual intervention, interrupting autonomous workflows. Adding automated failure detection and retry logic would enable self-healing PR workflows that handle common transient failures without manual handoff.\n\n**Implementation Steps:**\n1. Create `cub.core.services.pr_monitor` module to implement check polling and failure detection via `gh pr checks`\n2. Add retry configuration model to `cub.core.config` with timeout duration and max retry count parameters\n3. Extend `LaunchService` to support background PR monitoring while harness is active\n4. Implement check state machine: poll \u2192 detect failure \u2192 wait \u2192 retry \u2192 repeat or succeed\n5. Add `--retry-timeout` and `--no-retry` flags to `cub pr` command in `cub.cli.pr`\n6. Integrate check monitoring into session hooks to log retry history to session forensics\n7. Add check status and retry attempts to `cub.core.ledger` models for session ledger recording\n8. Write integration tests for check detection, retry triggering, and rate limit handling",
    "type": "task",
    "priority": 2,
    "labels": [
      "epic:cub-n6x",
      "punchlist"
    ],
    "created_at": "2026-01-29T01:58:07.313550Z",
    "captured_at": "2026-01-29T02:42:37.136565Z"
  },
  "task_changed": null,
  "attempts": [
    {
      "attempt_number": 1,
      "run_id": "cub-20260129-020557",
      "started_at": "2026-01-29T02:42:37.151450",
      "completed_at": "2026-01-29T02:58:55.704816Z",
      "harness": "claude",
      "model": "",
      "success": true,
      "error_category": null,
      "error_summary": null,
      "tokens": {
        "input_tokens": 84,
        "output_tokens": 35421,
        "cache_read_tokens": 5933771,
        "cache_creation_tokens": 90695
      },
      "cost_usd": 4.722269800000002,
      "duration_seconds": 978
    }
  ],
  "outcome": {
    "success": true,
    "partial": false,
    "completed_at": "2026-01-29T02:58:56.055490Z",
    "total_cost_usd": 4.722269800000002,
    "total_attempts": 1,
    "total_duration_seconds": 978,
    "final_model": "",
    "escalated": false,
    "escalation_path": [],
    "files_changed": [],
    "commits": [
      {
        "hash": "e006178b1f8d5a7216c2d751fe3e44f74677c1cc",
        "message": "task(cub-n6x.6): Add build failure detection and retry logic to cub pr",
        "author": "",
        "timestamp": "2026-01-29T02:58:14Z"
      }
    ],
    "approach": "Built a comprehensive CI monitoring system by first mapping the existing codebase architecture (services layer, config patterns, ledger models, and session integration), then implementing a new `PRMonitorService` module with state machine logic for polling CI checks and triggering retries, integrated it into the config and CLI layers, and finally added ledger models and session forensics hooks to track CI events across the execution lifecycle.",
    "decisions": [
      "**Daemon-thread-based monitoring in LaunchService** rather than spawning separate processes, keeping the monitoring lifecycle tied to the harness session and simplifying resource management",
      "**Retry heuristics based on check state classification** (terminal vs. retriable) rather than simple backoff, enabling intelligent recovery from flaky tests, rate limits, and service errors",
      "**CI monitoring models at the ledger layer** (`CICheckRecord`, `CIRetryRecord`, `CIMonitorSummary`) to maintain parity with existing architectural patterns where domain state is modeled explicitly",
      "**Session forensics integration via `ci_retry` and `ci_monitor_complete` events** to capture CI interactions in the same event stream as file writes and git commits, enabling post-hoc analysis and ledger reconciliation",
      "**Pre-existing config precedence pattern** (env vars > project > global > defaults) for retry timeout and max retries, allowing per-project and per-invocation customization without new configuration files"
    ],
    "lessons_learned": [
      "**Architectural patterns matter more than implementation details**: Understanding the existing service layer, config precedence, and ledger model patterns upfront saved significant refactoring\u2014new code should mirror existing patterns rather than invent new approaches",
      "**State machine clarity is critical for retry logic**: Explicitly modeling `CheckState` (Pending, Success, Failure, Retryable) and `RetryReason` (FlakyTest, RateLimit, ServiceError) made the logic testable and self-documenting, avoiding implicit state and temporal bugs",
      "**Ledger integration should happen at multiple layers**: Both the session forensics (event log) and final ledger entry (structured summary) are needed\u2014forensics enable post-hoc debugging while structured summaries enable dashboards and queries",
      "**Test isolation patterns in this codebase use temporary directories and fixture factories**: Following existing patterns (`tmp_path`, factory methods in conftest) ensured tests were fast, repeatable, and didn't interfere with the development environment"
    ]
  },
  "drift": {
    "additions": [],
    "omissions": [],
    "severity": "none"
  },
  "verification": {
    "status": "pending",
    "checked_at": null,
    "tests_passed": null,
    "typecheck_passed": null,
    "lint_passed": null,
    "notes": []
  },
  "workflow": {
    "stage": "dev_complete",
    "stage_updated_at": "2026-01-29T02:58:56.055490Z"
  },
  "state_history": [
    {
      "stage": "dev_complete",
      "at": "2026-01-29T02:42:37.136565Z",
      "by": "cub-run",
      "reason": "Task execution started"
    },
    {
      "stage": "dev_complete",
      "at": "2026-01-29T02:58:56.055490Z",
      "by": "cub-run",
      "reason": "Task closed successfully"
    }
  ],
  "started_at": "2026-01-29T02:42:37.136565Z",
  "completed_at": "2026-01-29T02:58:56.055490Z",
  "tokens": {
    "input_tokens": 84,
    "output_tokens": 35421,
    "cache_read_tokens": 5933771,
    "cache_creation_tokens": 90695
  },
  "cost_usd": 4.722269800000002,
  "duration_seconds": 978,
  "iterations": 1,
  "approach": "Built a comprehensive CI monitoring system by first mapping the existing codebase architecture (services layer, config patterns, ledger models, and session integration), then implementing a new `PRMonitorService` module with state machine logic for polling CI checks and triggering retries, integrated it into the config and CLI layers, and finally added ledger models and session forensics hooks to track CI events across the execution lifecycle.",
  "decisions": [
    "**Daemon-thread-based monitoring in LaunchService** rather than spawning separate processes, keeping the monitoring lifecycle tied to the harness session and simplifying resource management",
    "**Retry heuristics based on check state classification** (terminal vs. retriable) rather than simple backoff, enabling intelligent recovery from flaky tests, rate limits, and service errors",
    "**CI monitoring models at the ledger layer** (`CICheckRecord`, `CIRetryRecord`, `CIMonitorSummary`) to maintain parity with existing architectural patterns where domain state is modeled explicitly",
    "**Session forensics integration via `ci_retry` and `ci_monitor_complete` events** to capture CI interactions in the same event stream as file writes and git commits, enabling post-hoc analysis and ledger reconciliation",
    "**Pre-existing config precedence pattern** (env vars > project > global > defaults) for retry timeout and max retries, allowing per-project and per-invocation customization without new configuration files"
  ],
  "lessons_learned": [
    "**Architectural patterns matter more than implementation details**: Understanding the existing service layer, config precedence, and ledger model patterns upfront saved significant refactoring\u2014new code should mirror existing patterns rather than invent new approaches",
    "**State machine clarity is critical for retry logic**: Explicitly modeling `CheckState` (Pending, Success, Failure, Retryable) and `RetryReason` (FlakyTest, RateLimit, ServiceError) made the logic testable and self-documenting, avoiding implicit state and temporal bugs",
    "**Ledger integration should happen at multiple layers**: Both the session forensics (event log) and final ledger entry (structured summary) are needed\u2014forensics enable post-hoc debugging while structured summaries enable dashboards and queries",
    "**Test isolation patterns in this codebase use temporary directories and fixture factories**: Following existing patterns (`tmp_path`, factory methods in conftest) ensured tests were fast, repeatable, and didn't interfere with the development environment"
  ],
  "files_changed": [],
  "commits": [
    {
      "hash": "e006178b1f8d5a7216c2d751fe3e44f74677c1cc",
      "message": "task(cub-n6x.6): Add build failure detection and retry logic to cub pr",
      "author": "",
      "timestamp": "2026-01-29T02:58:14Z"
    }
  ],
  "spec_file": null,
  "run_log_path": "/home/lavallee/clawdbot/cub/.cub/ledger/by-task/cub-n6x.6",
  "epic_id": "cub-n6x",
  "verification_status": "pending",
  "verification_notes": [],
  "harness_name": "claude",
  "harness_model": "",
  "workflow_stage": null,
  "workflow_stage_updated_at": null
}