---
attempt: 1
harness: claude
model: sonnet
run_id: cub-20260126-123731
started_at: '2026-01-26T17:44:00.826224+00:00'
---

# System Prompt

# Ralph Loop Iteration

You are an autonomous coding agent working through a task backlog.

## Context Files

Study these files to understand the project:
- @AGENT.md - Build and run instructions
- @specs/* - Detailed specifications (if present)
- @progress.txt - Learnings from previous iterations

## Project Context

The current dual-backend situation (beads vs JSON) confuses users and creates maintenance burden. Beads is a complex, actively-developed tool that's been more distraction than aid for cub's target use case. New users hit friction with beads dependency, and task state doesn't persist across git clones without external tooling.

**Who has this problem:** Developers who want to try cub's autonomous coding workflow but get blocked by beads setup or confused by backend options.

### Requirements

### P0 - Must Have

- **JSONL Backend**: New `JsonlBackend` class implementing full `TaskBackend` protocol with beads-compatible schema
- **Sync Branch**: Git-based persistence using `cub-sync` branch, Python-native implementation (no `bd` dependency)
- **"Both" Mode**: Dual read/write to beads + JSONL as default, with divergence detection and warnings
- **Documentation Audit**: README matches `cub --help`, Quick Start works end-to-end, alpha disclaimer prominent
- **CLI Polish**: Helpful `--help` text, actionable error messages, consistent exit codes

### Components

### 1. JsonlBackend

**Purpose:** Native JSONL task storage using beads-compatible schema

**Responsibilities:**
- Read/write tasks from `.cub/tasks.jsonl`
- Implement full `TaskBackend` protocol (13 methods)
- Auto-migrate from old `prd.json` format on first access
- Atomic writes via temp file + rename (same pattern as existing `JsonBackend`)
- Generate task IDs using project prefix + incrementing number

**Dependencies:**
- `cub.core.tasks.models.Task` (existing Pydantic model)
- `cub.core.tasks.backend.TaskBackend` protocol


### Constraints

- No hard constraints identified
- Beads backend will remain available as optional component post-release
- Timeline is flexible but aiming for ~2 weeks to maintain momentum

## Your Workflow

1. **Understand**: Read the CURRENT TASK section below carefully
2. **Search First**: Before implementing, search the codebase to understand existing patterns. Do NOT assume something is not implemented.
3. **Implement**: Complete the task fully. NO placeholders or minimal implementations.
4. **Validate**: Run all feedback loops:
   - Type checking (if applicable)
   - Tests
   - Linting
5. **Complete**: If all checks pass, close the task using the appropriate method shown in CURRENT TASK below, then commit your changes.

## Critical Rules

- **ONE TASK**: Focus only on the task assigned below
- **FULL IMPLEMENTATION**: No stubs, no TODOs, no "implement later"
- **SEARCH BEFORE WRITING**: Use parallel subagents to search the codebase before assuming code doesn't exist
- **FIX WHAT YOU BREAK**: If tests unrelated to your work fail, fix them
- **DOCUMENT DISCOVERIES**: If you find bugs or issues, add them to @fix_plan.md
- **UPDATE AGENT.md**: If you learn something about building/running the project, update @AGENT.md
- **CLOSE THE TASK**: Always mark the task as closed using the method specified in CURRENT TASK

## Parallelism Guidance

- Use parallel subagents for: file searches, reading multiple files
- Use SINGLE sequential execution for: build, test, typecheck
- Before making changes, always search first using subagents

## When You're Done

After successfully completing the task and all checks pass:
1. Close the task using the method shown in CURRENT TASK
2. Commit your changes with format: `type(task-id): description`
3. Append learnings to @progress.txt
4. If ALL tasks are closed, output exactly:

<promise>COMPLETE</promise>

This signals the loop should terminate.

---

Generated by cub stage from plan: 0.30-foundation-phase


# Task Prompt

## CURRENT TASK

Task ID: cub-j1a.3
Type: task
Title: Implement dependency-aware and utility methods

Description:
The `get_ready_tasks` method is critical for `cub run` - it must correctly identify tasks with all dependencies satisfied. Other utility methods round out the protocol.

**Implementation Steps:**
1. Implement `get_ready_tasks(parent, label)` - open tasks with all deps closed
2. Parse `dependencies` array to build blocked-by relationships
3. Implement `get_task_counts()` returning `TaskCounts` model
4. Implement `add_task_note(task_id, note)` appending to notes field
5. Implement `import_tasks(tasks)` for bulk import with ID preservation
6. Sort ready tasks by priority (P0 first)

**Files:** `src/cub/core/tasks/jsonl.py`

## Task Management

This project uses the beads task backend (`bd` CLI).

**Task lifecycle:**
- `bd update cub-j1a.3 --status in_progress` - Claim the task (do this first)
- `bd close cub-j1a.3` - Mark task complete (after all checks pass)
- `bd close cub-j1a.3 -r "reason"` - Close with explanation

**Useful commands:**
- `bd show cub-j1a.3` - View task details and dependencies
- `bd list --status open` - See remaining open tasks
- `bd ready` - See tasks ready to work on (no blockers)

**Important:** Always run feedback loops (tests, typecheck, lint) BEFORE closing the task.

## When Complete

1. Run feedback loops (typecheck, test, lint)
2. Mark the task complete (see Task Management above)
3. Commit: `task(cub-j1a.3): Implement dependency-aware and utility methods`
4. Append learnings to progress.txt