<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROCKY — A Cub Text Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --green: #33ff33;
            --green-dim: #1a8c1a;
            --amber: #ffb833;
            --amber-dim: #8c6600;
            --bg: #0a0a0a;
            --bg-light: #111;
            --text: #33ff33;
            --text-dim: #1a8c1a;
            --honey: #f6b93b;
            --coral: #e17055;
            --cyan: #00d9a5;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* CRT Effect */
        .crt-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.15) 0px,
                rgba(0,0,0,0.15) 1px,
                transparent 1px,
                transparent 3px
            );
        }

        .crt-overlay::after {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.4) 100%);
        }

        /* Status Bar (Sierra-style) */
        .status-bar {
            background: var(--green-dim);
            color: #000;
            padding: 4px 12px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
            font-weight: 700;
            letter-spacing: 0.5px;
            border-bottom: 2px solid var(--green);
        }

        .status-bar .location { }
        .status-bar .tickets { color: #000; }
        .status-bar .time { }

        /* Main Terminal */
        .terminal {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            padding-bottom: 8px;
            scroll-behavior: smooth;
        }

        .terminal::-webkit-scrollbar { width: 8px; }
        .terminal::-webkit-scrollbar-track { background: var(--bg); }
        .terminal::-webkit-scrollbar-thumb { background: var(--green-dim); border-radius: 4px; }

        .output-line {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
            font-size: 14px;
            min-height: 1.5em;
        }

        .output-line.ascii-art {
            line-height: 1.15;
            color: var(--amber);
        }

        .output-line.highlight { color: var(--amber); }
        .output-line.success { color: var(--cyan); }
        .output-line.alert { color: var(--coral); font-weight: 700; }
        .output-line.dim { color: var(--text-dim); }
        .output-line.command-echo { color: var(--amber); }

        /* Command Chips */
        .chips-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0;
        }

        .chip {
            background: transparent;
            border: 1px solid var(--green-dim);
            color: var(--green);
            padding: 4px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.15s;
        }

        .chip:hover {
            background: var(--green);
            color: #000;
            box-shadow: 0 0 10px rgba(51,255,51,0.3);
        }

        /* Input Area */
        .input-area {
            display: flex;
            align-items: center;
            padding: 8px 16px 12px;
            border-top: 1px solid #222;
            flex-shrink: 0;
            background: var(--bg);
        }

        .prompt-text {
            color: var(--amber);
            margin-right: 8px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .input-field {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            outline: none;
            caret-color: var(--green);
        }

        .input-field::placeholder {
            color: var(--text-dim);
            opacity: 0.5;
        }

        /* Title Screen */
        .title-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            animation: fadeIn 1s ease;
        }

        .title-screen .title-art {
            color: var(--amber);
            font-size: 14px;
            line-height: 1.15;
            margin-bottom: 24px;
        }

        .title-screen .subtitle {
            color: var(--green);
            font-size: 14px;
            margin-bottom: 8px;
        }

        .title-screen .press-start {
            color: var(--green);
            font-size: 14px;
            animation: blink 1s step-end infinite;
            margin-top: 32px;
            cursor: pointer;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Victory box */
        .victory-box {
            border: 2px solid var(--amber);
            padding: 16px;
            margin: 8px 0;
            text-align: center;
        }

        .victory-box .output-line { text-align: center; }

        /* Mobile */
        @media (max-width: 600px) {
            .output-line, .chip, .input-field, .prompt-text {
                font-size: 12px;
            }
            .terminal { padding: 8px; }
            .status-bar { font-size: 11px; padding: 3px 8px; }
        }
    </style>
</head>
<body>

<div class="crt-overlay"></div>

<!-- Title Screen -->
<div id="title-screen" class="title-screen">
    <pre class="title-art">
 ██████╗  ██████╗  ██████╗██╗  ██╗██╗   ██╗
 ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝╚██╗ ██╔╝
 ██████╔╝██║   ██║██║     █████╔╝  ╚████╔╝
 ██╔══██╗██║   ██║██║     ██╔═██╗   ╚██╔╝
 ██║  ██║╚██████╔╝╚██████╗██║  ██╗   ██║
 ╚═╝  ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝   ╚═╝
    </pre>
    <div class="subtitle">A CUB TEXT ADVENTURE</div>
    <div class="subtitle dim" style="color: var(--text-dim); font-size:12px; margin-top:4px;">Inspired by the Sierra classics</div>
    <div class="press-start" onclick="startGame()">&gt; PRESS ANY KEY TO START &lt;</div>
</div>

<!-- Game Screen (hidden initially) -->
<div id="game-screen" style="display:none; height:100vh; flex-direction:column;">
    <div class="status-bar">
        <span class="location" id="status-location">THE CUBICLE OF DESPAIR</span>
        <span class="tickets" id="status-tickets">TICKETS: 0/10,000</span>
        <span class="time" id="status-time">TIME: 8:00 AM</span>
    </div>
    <div class="terminal" id="terminal" onclick="focusInput()"></div>
    <div class="input-area">
        <span class="prompt-text" id="prompt-label">&gt;</span>
        <input class="input-field" id="input" type="text" placeholder="Type a command or click a suggestion..." autocomplete="off" spellcheck="false">
    </div>
</div>

<script>
// ─── GAME STATE ─────────────────────────────────────────────────
const state = {
    room: 0,
    step: 0,
    tickets: 0,
    time: { h: 8, m: 0 },
    inventory: [],
    hasLookedDesk: false,
    hasFloppy: false,
    typing: false,
    skipTyping: false,
    inputEnabled: false,
    commandHistory: [],
    historyIndex: -1
};

const terminal = () => document.getElementById('terminal');
const input = () => document.getElementById('input');

function focusInput() { if (state.inputEnabled) input().focus(); }

// ─── OUTPUT HELPERS ─────────────────────────────────────────────
function addLine(text, cls = '') {
    const div = document.createElement('div');
    div.className = 'output-line' + (cls ? ' ' + cls : '');
    div.textContent = text;
    terminal().appendChild(div);
    terminal().scrollTop = terminal().scrollHeight;
    return div;
}

function addHTML(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    terminal().appendChild(div);
    terminal().scrollTop = terminal().scrollHeight;
}

function addChips(commands) {
    const container = document.createElement('div');
    container.className = 'chips-container';
    commands.forEach(cmd => {
        const chip = document.createElement('button');
        chip.className = 'chip';
        chip.textContent = cmd.label || cmd.cmd;
        chip.onclick = () => {
            container.remove();
            executeCommand(cmd.cmd);
        };
        container.appendChild(chip);
    });
    terminal().appendChild(container);
    terminal().scrollTop = terminal().scrollHeight;
}

function clearChips() {
    terminal().querySelectorAll('.chips-container').forEach(c => c.remove());
}

async function typeLines(lines, delay = 20) {
    state.typing = true;
    state.skipTyping = false;
    for (const line of lines) {
        if (state.skipTyping) {
            addLine(line.text, line.cls || '');
            continue;
        }
        const div = addLine('', line.cls || '');
        for (let i = 0; i < line.text.length; i++) {
            if (state.skipTyping) {
                div.textContent = line.text;
                break;
            }
            div.textContent += line.text[i];
            terminal().scrollTop = terminal().scrollHeight;
            await sleep(delay);
        }
    }
    state.typing = false;
    state.skipTyping = false;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function updateStatus() {
    const loc = document.getElementById('status-location');
    const tix = document.getElementById('status-tickets');
    const time = document.getElementById('status-time');
    tix.textContent = `TICKETS: ${state.tickets.toLocaleString()}/10,000`;
    const ampm = state.time.h >= 12 ? 'PM' : 'AM';
    const h = state.time.h > 12 ? state.time.h - 12 : state.time.h;
    const m = String(state.time.m).padStart(2, '0');
    time.textContent = `TIME: ${h}:${m} ${ampm}`;
}

function advanceTime(minutes) {
    state.time.m += minutes;
    while (state.time.m >= 60) {
        state.time.h++;
        state.time.m -= 60;
    }
    updateStatus();
}

function setLocation(name) {
    document.getElementById('status-location').textContent = name;
}

function enableInput() {
    state.inputEnabled = true;
    input().disabled = false;
    input().focus();
}

function disableInput() {
    state.inputEnabled = false;
    input().disabled = true;
}

// ─── ANIMATED COUNTER ───────────────────────────────────────────
async function animateTickets(from, to, durationMs = 2000) {
    const steps = 40;
    const increment = (to - from) / steps;
    const stepDelay = durationMs / steps;
    for (let i = 0; i <= steps; i++) {
        state.tickets = Math.round(from + increment * i);
        updateStatus();
        await sleep(stepDelay);
    }
    state.tickets = to;
    updateStatus();
}

// ─── ROOM SCRIPTS ───────────────────────────────────────────────

async function room0_cubicle() {
    setLocation('THE CUBICLE OF DESPAIR');
    state.room = 0;
    state.step = 0;

    await typeLines([
        { text: '' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '  ACT I: THE SENTENCE', cls: 'highlight' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '' },
        { text: 'You are JAKE PORTER, junior developer at MEGACORP SYNERGIES INC.' },
        { text: '' },
        { text: 'Last Friday you accidentally replied-all to 47,000 people telling' },
        { text: 'them the CEO\'s quarterly vision was "mid."' },
        { text: '' },
        { text: 'You have been sentenced to manually process 10,000 TIKKR tickets' },
        { text: 'by end of day.', cls: 'alert' },
        { text: '' },
        { text: 'Your cubicle contains: a beige PC (circa 1987), a stack of TIKKR' },
        { text: 'printouts reaching the ceiling, a sad fern, and a motivational' },
        { text: 'poster that reads "THERE IS NO I IN SPRINT."' },
        { text: '' },
        { text: 'The Twisted Scissors concert is TONIGHT at 8 PM. You have tickets.', cls: 'highlight' },
        { text: 'You CANNOT miss this.', cls: 'highlight' },
        { text: '' },
    ]);

    addChips([
        { cmd: 'look', label: 'look' },
        { cmd: 'look desk', label: 'look desk' },
        { cmd: 'look fern', label: 'look fern' },
        { cmd: 'help', label: 'help' },
    ]);
    enableInput();
}

async function room1_cubexe() {
    setLocation('A:\\CUB.EXE');
    state.room = 1;
    state.step = 0;
    disableInput();

    await typeLines([
        { text: '' },
        { text: 'You slide the disk into the A:\\ drive. It makes a satisfying', cls: '' },
        { text: 'CHUNK-CHUNK sound.', cls: '' },
        { text: '' },
        { text: 'A:\\> CUB.EXE', cls: 'command-echo' },
        { text: '' },
    ], 15);

    await sleep(500);

    await typeLines([
        { text: ' ██████╗██╗   ██╗██████╗ ', cls: 'ascii-art' },
        { text: '██╔════╝██║   ██║██╔══██╗', cls: 'ascii-art' },
        { text: '██║     ██║   ██║██████╔╝', cls: 'ascii-art' },
        { text: '██║     ██║   ██║██╔══██╗', cls: 'ascii-art' },
        { text: '╚██████╗╚██████╔╝██████╔╝', cls: 'ascii-art' },
        { text: ' ╚═════╝ ╚═════╝ ╚═════╝  v0.30.0', cls: 'ascii-art' },
        { text: '' },
    ], 8);

    await sleep(300);

    await typeLines([
        { text: '"Hello, developer. I see 10,000 unprocessed tickets.', cls: 'success' },
        { text: ' Would you like to automate your existence? (Y/n)"', cls: 'success' },
        { text: '' },
    ]);

    addChips([
        { cmd: 'cub init', label: 'cub init' },
        { cmd: 'Y', label: 'Y' },
    ]);
    enableInput();
}

async function room2_whiteboard() {
    setLocation('THE WHITEBOARD JUNGLE');
    state.room = 2;
    state.step = 0;
    disableInput();
    advanceTime(15);

    await typeLines([
        { text: '' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '  ACT II: THE PLAN', cls: 'highlight' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '' },
        { text: 'You wheel your chair to the team whiteboard. It\'s covered in' },
        { text: 'Post-It notes, half-erased diagrams, and someone wrote' },
        { text: '"MICROSERVICES?" in all caps with three question marks.' },
        { text: '' },
        { text: 'You need a plan. 10,000 tickets won\'t sort themselves.' },
        { text: 'Fortunately, cub has a planning pipeline.' },
        { text: '' },
    ]);

    addChips([
        { cmd: 'cub plan orient', label: 'cub plan orient' },
        { cmd: 'look whiteboard', label: 'look whiteboard' },
    ]);
    enableInput();
}

async function interruption_hr() {
    disableInput();
    advanceTime(15);

    await typeLines([
        { text: '' },
        { text: '╔══════════════════════════════════════════════════════╗', cls: 'alert' },
        { text: '║  MANDATORY HR TRAINING                              ║', cls: 'alert' },
        { text: '║  "Appropriate Use of Reply-All"                     ║', cls: 'alert' },
        { text: '║  Duration: 45 minutes. Attendance is tracked.       ║', cls: 'alert' },
        { text: '╚══════════════════════════════════════════════════════╝', cls: 'alert' },
        { text: '' },
        { text: 'A video begins. A person in a sweater vest explains email' },
        { text: 'etiquette using a hand puppet. You cannot skip this.' },
        { text: '' },
    ]);

    await sleep(1500);

    await typeLines([
        { text: '[TIME PASSES... 45 MINUTES LOST]', cls: 'dim' },
        { text: '' },
    ]);

    advanceTime(45);

    await typeLines([
        { text: 'The puppet made some good points, actually.', cls: 'dim' },
        { text: '' },
    ]);

    // Transition to room 3
    await room3_engine();
}

async function room3_engine() {
    setLocation('THE ENGINE ROOM');
    state.room = 3;
    state.step = 0;
    disableInput();

    await typeLines([
        { text: '' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '  ACT III: THE RUN', cls: 'highlight' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '' },
        { text: 'Back at your desk. The fern is watching you expectantly.' },
        { text: 'Time to stage those tasks and let cub loose.' },
        { text: '' },
    ]);

    addChips([
        { cmd: 'cub stage', label: 'cub stage' },
    ]);
    enableInput();
}

async function interruption_okr() {
    disableInput();

    await typeLines([
        { text: '' },
        { text: '╔══════════════════════════════════════════════════════╗', cls: 'alert' },
        { text: '║  MANDATORY: Q3 OKR Backlog Grooming                 ║', cls: 'alert' },
        { text: '║  Conference Room B                                   ║', cls: 'alert' },
        { text: '║  "Align our north stars and rightsize the backlog"   ║', cls: 'alert' },
        { text: '╚══════════════════════════════════════════════════════╝', cls: 'alert' },
        { text: '' },
        { text: 'You attend. Someone says "synergy" 14 times. The meeting' },
        { text: 'runs 30 minutes over because Dave wants to re-estimate' },
        { text: 'everything using Fib-o-nacci numbers.' },
        { text: '' },
    ]);

    await sleep(1500);

    await typeLines([
        { text: '[TIME PASSES... 90 MINUTES LOST]', cls: 'dim' },
        { text: '' },
    ]);

    advanceTime(90);

    await typeLines([
        { text: 'But wait -- cub was still running in the background!', cls: 'success' },
        { text: '' },
    ]);

    // Tickets jumped while you were away
    const oldTickets = state.tickets;
    await animateTickets(oldTickets, 7200, 2000);

    await typeLines([
        { text: '> cub status', cls: 'command-echo' },
        { text: ' ████████████████░░░░░░░░ 72% (7,200/10,000 tickets)', cls: 'success' },
        { text: ' 38 tasks complete | 4 in progress | 5 ready' },
        { text: '' },
    ]);

    // Transition to room 4
    await room4_final_push();
}

async function room4_final_push() {
    setLocation('THE FINAL PUSH');
    state.room = 4;
    state.step = 0;
    disableInput();

    await typeLines([
        { text: '' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '  ACT IV: THE HOME STRETCH', cls: 'highlight' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '' },
        { text: 'You\'re close. But your manager Brenda wants a STATUS UPDATE.' },
        { text: 'She needs METRICS. She needs DASHBOARDS. She needs PROOF.' },
        { text: '' },
    ]);

    addChips([
        { cmd: 'cub ledger show', label: 'cub ledger show' },
        { cmd: 'cub suggest', label: 'cub suggest' },
    ]);
    enableInput();
}

async function interruption_sync() {
    disableInput();

    await typeLines([
        { text: '' },
        { text: '╔══════════════════════════════════════════════════════╗', cls: 'alert' },
        { text: '║  WEEKLY 1:1 SYNC TOUCHBASE                          ║', cls: 'alert' },
        { text: '║  Your skip-level manager Roger                      ║', cls: 'alert' },
        { text: '║  "Just a quick sync. 30 minutes max. Maybe 45."     ║', cls: 'alert' },
        { text: '╚══════════════════════════════════════════════════════╝', cls: 'alert' },
        { text: '' },
        { text: 'Roger spends 40 minutes showing you photos of his boat.' },
        { text: 'His boat is named "Agile Vessel."' },
        { text: '' },
    ]);

    await sleep(1500);

    await typeLines([
        { text: '[TIME PASSES... 50 MINUTES LOST]', cls: 'dim' },
        { text: '' },
    ]);

    advanceTime(50);
    await animateTickets(state.tickets, 9100, 1500);

    await typeLines([
        { text: 'Concert doors open at 7. Traffic will be bad.', cls: 'highlight' },
        { text: '' },
    ]);

    // Transition to room 5
    await room5_finish();
}

async function room5_finish() {
    setLocation('THE FINISH LINE');
    state.room = 5;
    state.step = 0;
    disableInput();

    await typeLines([
        { text: '' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '  ACT V: VICTORY', cls: 'highlight' },
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '' },
        { text: 'Only 900 tickets left. Time is running out.' },
        { text: 'One more run should do it.' },
        { text: '' },
    ]);

    addChips([
        { cmd: 'cub run', label: 'cub run' },
    ]);
    enableInput();
}

async function showVictory() {
    disableInput();
    advanceTime(30);

    await typeLines([
        { text: '' },
        { text: '> cub status', cls: 'command-echo' },
        { text: ' ████████████████████████ 100% (10,000/10,000 tickets)', cls: 'success' },
        { text: ' 47 tasks complete | 0 in progress | 0 ready', cls: 'success' },
        { text: '' },
    ]);

    await sleep(500);

    await typeLines([
        { text: 'ALL TICKETS PROCESSED.', cls: 'success' },
        { text: '' },
        { text: '> cub ledger stats', cls: 'command-echo' },
        { text: ' Total tasks:     47' },
        { text: ' Total tickets:   10,000' },
        { text: ' Total cost:      $4.23' },
        { text: ' Total time:      2h 15m (of actual compute)' },
        { text: ' Time saved:      ~3 months of manual work' },
        { text: '' },
    ]);

    await sleep(800);

    // Epilogue
    state.time.h = 17; state.time.m = 30;
    updateStatus();
    setLocation('PARKING LOT');

    await typeLines([
        { text: '════════════════════════════════════════════════════════', cls: 'dim' },
        { text: '' },
        { text: 'You grab your jacket. The fern gives you a knowing nod.' },
        { text: 'You submit your TIKKR report. 10,000 tickets: CLOSED.' },
        { text: '' },
        { text: 'As you walk to the parking lot, your phone buzzes.' },
        { text: 'It\'s Brenda: "Great velocity this sprint! Let\'s discuss' },
        { text: 'making you TIKKR Champion at the next all-hands."' },
        { text: '' },
        { text: 'You silence your phone.' },
        { text: '' },
        { text: 'Tonight, you rock.', cls: 'highlight' },
        { text: '' },
    ]);

    await sleep(500);

    // Victory box
    const box = document.createElement('div');
    box.className = 'victory-box';
    box.innerHTML = `
        <div class="output-line ascii-art" style="text-align:center">
 ██████╗  ██████╗  ██████╗██╗  ██╗██╗   ██╗
 ██╔══██╗██╔═══██╗██╔════╝██║ ██╔╝╚██╗ ██╔╝
 ██████╔╝██║   ██║██║     █████╔╝  ╚████╔╝
 ██╔══██╗██║   ██║██║     ██╔═██╗   ╚██╔╝
 ██║  ██║╚██████╔╝╚██████╗██║  ██╗   ██║
 ╚═╝  ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝   ╚═╝</div>
        <div class="output-line highlight" style="text-align:center">&mdash; COMPLETE &mdash;</div>
        <div class="output-line" style="text-align:center">&nbsp;</div>
        <div class="output-line" style="text-align:center">You processed 10,000 tickets in one day.</div>
        <div class="output-line" style="text-align:center">Total cost: $4.23</div>
        <div class="output-line" style="text-align:center">Meetings survived: 3</div>
        <div class="output-line" style="text-align:center">Ferns impressed: 1</div>
        <div class="output-line" style="text-align:center">&nbsp;</div>
        <div class="output-line success" style="text-align:center">Install cub:  curl -fsSL cub.tools | bash</div>
        <div class="output-line success" style="text-align:center">Docs:         <a href="https://docs.cub.tools" style="color:var(--cyan)">https://docs.cub.tools</a></div>
        <div class="output-line" style="text-align:center">&nbsp;</div>
        <div class="output-line highlight" style="text-align:center">SCORE: 10,000/10,000</div>
        <div class="output-line highlight" style="text-align:center">RATING: DEE SNIDER WOULD BE PROUD</div>
    `;
    terminal().appendChild(box);
    terminal().scrollTop = terminal().scrollHeight;

    addChips([
        { cmd: 'restart', label: 'Play Again' },
    ]);
    enableInput();
}

// ─── COMMAND HANDLER ────────────────────────────────────────────

async function executeCommand(rawCmd) {
    if (state.typing) {
        state.skipTyping = true;
        return;
    }
    if (!state.inputEnabled) return;

    const cmd = rawCmd.trim().toLowerCase();
    if (!cmd) return;

    state.commandHistory.push(cmd);
    state.historyIndex = state.commandHistory.length;

    clearChips();
    addLine('> ' + rawCmd.trim(), 'command-echo');
    disableInput();

    // ─── Global commands ─────────────────────
    if (cmd === 'help') {
        await typeLines([
            { text: '' },
            { text: 'ROCKY — A Cub Text Adventure', cls: 'highlight' },
            { text: '' },
            { text: 'Commands you can try:', cls: 'dim' },
            { text: '  look / look <thing>  — Examine your surroundings' },
            { text: '  take <item>          — Pick up an item' },
            { text: '  use <item>           — Use an inventory item' },
            { text: '  inventory             — Check your pockets' },
            { text: '  cub <command>        — Run a cub command' },
            { text: '  help                 — Show this message' },
            { text: '  restart              — Start over' },
            { text: '' },
            { text: 'You can also click the green command chips!', cls: 'dim' },
            { text: '' },
        ]);
        enableInput();
        return;
    }

    if (cmd === 'inventory' || cmd === 'i') {
        if (state.inventory.length === 0) {
            await typeLines([{ text: 'Your pockets are empty. Like your sprint backlog used to be.' }]);
        } else {
            await typeLines([
                { text: 'Inventory:', cls: 'highlight' },
                ...state.inventory.map(item => ({ text: '  - ' + item })),
                { text: '' },
            ]);
        }
        enableInput();
        return;
    }

    if (cmd === 'restart') {
        terminal().innerHTML = '';
        state.room = 0;
        state.step = 0;
        state.tickets = 0;
        state.time = { h: 8, m: 0 };
        state.inventory = [];
        state.hasLookedDesk = false;
        state.hasFloppy = false;
        updateStatus();
        await room0_cubicle();
        return;
    }

    // ─── Room-specific commands ──────────────
    // ROOM 0: Cubicle
    if (state.room === 0) {
        if (cmd === 'look' || cmd === 'look around' || cmd === 'l') {
            await typeLines([
                { text: '' },
                { text: 'A beige cubicle with fabric walls the color of despair. Your desk' },
                { text: 'holds a PC, a coffee mug that says "I SURVIVED THE SPRINT RETRO",' },
                { text: 'and a tower of TIKKR printouts. A sad fern sits in the corner.' },
                { text: '' },
            ]);
            addChips([
                { cmd: 'look desk', label: 'look desk' },
                { cmd: 'look fern', label: 'look fern' },
                { cmd: 'look poster', label: 'look poster' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'look desk' || cmd === 'examine desk') {
            state.hasLookedDesk = true;
            await typeLines([
                { text: '' },
                { text: 'Under a coffee ring you notice a dusty 3.5" floppy disk.' },
                { text: 'The label reads: "CUB v0.30.0 \u2014 AUTONOMOUS TASK ENGINE"', cls: 'highlight' },
                { text: 'Someone has written in marker: "just run it"', cls: 'highlight' },
                { text: '' },
            ]);
            addChips([
                { cmd: 'take floppy', label: 'take floppy' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'look fern' || cmd === 'examine fern') {
            await typeLines([
                { text: '' },
                { text: 'The fern looks at you with quiet judgment. It has seen many' },
                { text: 'developers come and go. It has outlasted three re-orgs and a' },
                { text: 'pivot to blockchain. It believes in you. Probably.' },
                { text: '' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'look poster' || cmd === 'examine poster' || cmd === 'read poster') {
            await typeLines([
                { text: '' },
                { text: '"THERE IS NO I IN SPRINT"' , cls: 'highlight' },
                { text: 'Below it, someone has written in pen: "but there is one in QUIT"' },
                { text: '' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'look pc' || cmd === 'look computer' || cmd === 'examine pc') {
            await typeLines([
                { text: '' },
                { text: 'A beige box with a green monochrome monitor. The A:\\ drive is' },
                { text: 'empty, awaiting input. The hard drive makes ominous clicking' },
                { text: 'sounds, like a tiny woodpecker questioning its life choices.' },
                { text: '' },
            ]);
            if (state.hasFloppy) {
                addChips([{ cmd: 'use floppy', label: 'use floppy' }]);
            }
            enableInput();
            return;
        }
        if (cmd === 'take floppy' || cmd === 'get floppy' || cmd === 'pick up floppy' || cmd === 'take disk' || cmd === 'get disk') {
            if (!state.hasLookedDesk) {
                await typeLines([{ text: 'You rummage around but don\'t see anything interesting. Try looking at the desk first.' }]);
                enableInput();
                return;
            }
            if (state.hasFloppy) {
                await typeLines([{ text: 'You already have the floppy disk.' }]);
                enableInput();
                return;
            }
            state.hasFloppy = true;
            state.inventory.push('Mysterious Floppy Disk (CUB v0.30.0)');
            await typeLines([
                { text: '' },
                { text: 'Added to inventory: MYSTERIOUS FLOPPY DISK', cls: 'success' },
                { text: 'It feels warm. Probably just static. Probably.' },
                { text: '' },
            ]);
            addChips([
                { cmd: 'use floppy', label: 'use floppy' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'use floppy' || cmd === 'insert floppy' || cmd === 'use disk' || cmd === 'insert disk') {
            if (!state.hasFloppy) {
                await typeLines([{ text: 'You don\'t have a floppy disk. Maybe check the desk?' }]);
                addChips([{ cmd: 'look desk', label: 'look desk' }]);
                enableInput();
                return;
            }
            advanceTime(15);
            await room1_cubexe();
            return;
        }
        // Fallthrough
        await typeLines([{ text: 'That doesn\'t work here. Try: look, look desk, take floppy, use floppy' }]);
        enableInput();
        return;
    }

    // ROOM 1: CUB.EXE
    if (state.room === 1) {
        if (cmd === 'cub init' || cmd === 'y' || cmd === 'yes') {
            advanceTime(15);
            await typeLines([
                { text: '' },
                { text: '> cub init', cls: 'command-echo' },
                { text: '' },
                { text: 'Initializing cub in MEGACORP-MONOREPO...', cls: 'dim' },
            ]);
            await sleep(400);
            await typeLines([
                { text: '  Task backend configured (10,000 tickets imported)', cls: 'success' },
            ]);
            await sleep(300);
            await typeLines([
                { text: '  Hooks installed', cls: 'success' },
            ]);
            await sleep(300);
            await typeLines([
                { text: '  Your fern looks healthier already', cls: 'success' },
                { text: '' },
                { text: 'Cub is ready. You have 10,000 tickets and a dream.', cls: 'highlight' },
                { text: '' },
            ]);

            await sleep(500);
            await room2_whiteboard();
            return;
        }
        if (cmd === 'n' || cmd === 'no') {
            await typeLines([
                { text: '' },
                { text: '"Bold choice. Enjoy your 10,000 tickets. Manually."', cls: 'dim' },
                { text: '' },
                { text: 'Just kidding. This is a text adventure. Type "cub init".', cls: 'dim' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub init', label: 'cub init' }]);
            enableInput();
            return;
        }
        await typeLines([{ text: 'Cub is waiting. Type "cub init" to begin.' }]);
        addChips([{ cmd: 'cub init', label: 'cub init' }]);
        enableInput();
        return;
    }

    // ROOM 2: Whiteboard (planning)
    if (state.room === 2) {
        if (cmd === 'look whiteboard' || cmd === 'look' || cmd === 'look around') {
            await typeLines([
                { text: '' },
                { text: 'The whiteboard contains:' },
                { text: '  - "MICROSERVICES???" (underlined three times)' },
                { text: '  - A Venn diagram with no labels' },
                { text: '  - "Dave\'s API" with an arrow pointing to "?????"' },
                { text: '  - A drawing of what might be a system diagram or a cat' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub plan orient', label: 'cub plan orient' }]);
            enableInput();
            return;
        }
        if (cmd === 'cub plan orient' || cmd === 'orient') {
            state.step = 1;
            advanceTime(15);
            await typeLines([
                { text: '' },
                { text: '> cub plan orient', cls: 'command-echo' },
                { text: '' },
                { text: 'Analyzing 10,000 TIKKR tickets...', cls: 'dim' },
            ]);
            await sleep(600);
            await typeLines([
                { text: '' },
                { text: 'Findings:', cls: 'highlight' },
                { text: '  - 3,847 are exact duplicates of "login button is blue"' },
                { text: '  - 2,100 can be auto-triaged by category' },
                { text: '  - 1 says: "As a user I want the button to be more blue' },
                { text: '    but also more green" (marked P0 CRITICAL)' },
                { text: '  - 1 says: "URGENT: fix the thing (no other details)"' },
                { text: '  - 847 are from someone named Dave and are all one word: "bug"' },
                { text: '' },
                { text: 'Orient phase complete. Patterns identified.', cls: 'success' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub plan architect', label: 'cub plan architect' }]);
            enableInput();
            return;
        }
        if (cmd === 'cub plan architect' || cmd === 'architect') {
            if (state.step < 1) {
                await typeLines([{ text: 'Run "cub plan orient" first to analyze the tickets.' }]);
                addChips([{ cmd: 'cub plan orient', label: 'cub plan orient' }]);
                enableInput();
                return;
            }
            state.step = 2;
            advanceTime(10);
            await typeLines([
                { text: '' },
                { text: '> cub plan architect', cls: 'command-echo' },
                { text: '' },
                { text: 'Designing batch-processing strategy...', cls: 'dim' },
            ]);
            await sleep(500);
            await typeLines([
                { text: '' },
                { text: 'Architecture:', cls: 'highlight' },
                { text: '  Phase 1: Deduplicate (close 3,847 identical tickets)' },
                { text: '  Phase 2: Auto-triage (categorize 2,100 by keywords)' },
                { text: '  Phase 3: Interpret ambiguous tickets (AI-assisted)' },
                { text: '  Phase 4: Batch-resolve by category' },
                { text: '  Phase 5: Handle Dave\'s tickets (just close them)' },
                { text: '' },
                { text: 'Architect phase complete. Strategy designed.', cls: 'success' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub plan itemize', label: 'cub plan itemize' }]);
            enableInput();
            return;
        }
        if (cmd === 'cub plan itemize' || cmd === 'itemize') {
            if (state.step < 2) {
                await typeLines([{ text: 'Run the earlier planning phases first.' }]);
                enableInput();
                return;
            }
            advanceTime(10);
            await typeLines([
                { text: '' },
                { text: '> cub plan itemize', cls: 'command-echo' },
                { text: '' },
                { text: 'Breaking strategy into agent-sized tasks...', cls: 'dim' },
            ]);
            await sleep(500);
            await typeLines([
                { text: '' },
                { text: '47 tasks created:', cls: 'success' },
                { text: '  MEGA-001  Batch-close duplicate tickets' },
                { text: '  MEGA-002  Auto-triage by category' },
                { text: '  MEGA-003  Fix "the thing" (interpret ambiguous)' },
                { text: '  MEGA-004  Resolve login-button-color tickets' },
                { text: '  MEGA-005  Handle Dave\'s "bug" tickets' },
                { text: '  ... (42 more)' },
                { text: '' },
                { text: 'Itemize phase complete. Ready to stage.', cls: 'success' },
                { text: '' },
            ]);

            await sleep(500);
            // HR interruption
            await interruption_hr();
            return;
        }
        await typeLines([{ text: 'Try: cub plan orient, cub plan architect, cub plan itemize' }]);
        addChips([
            state.step === 0 ? { cmd: 'cub plan orient', label: 'cub plan orient' } :
            state.step === 1 ? { cmd: 'cub plan architect', label: 'cub plan architect' } :
            { cmd: 'cub plan itemize', label: 'cub plan itemize' }
        ]);
        enableInput();
        return;
    }

    // ROOM 3: Engine Room (staging + running)
    if (state.room === 3) {
        if (cmd === 'cub stage' || cmd === 'stage') {
            state.step = 1;
            advanceTime(5);
            await typeLines([
                { text: '' },
                { text: '> cub stage', cls: 'command-echo' },
                { text: '' },
                { text: 'Importing 47 tasks from plan...', cls: 'dim' },
            ]);
            await sleep(500);
            await typeLines([
                { text: '  47 tasks staged and ready', cls: 'success' },
                { text: '' },
            ]);
            addChips([
                { cmd: 'cub task ready', label: 'cub task ready' },
                { cmd: 'cub status', label: 'cub status' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'cub task ready' || cmd === 'task ready') {
            if (state.step < 1) {
                await typeLines([{ text: 'Stage tasks first with "cub stage".' }]);
                addChips([{ cmd: 'cub stage', label: 'cub stage' }]);
                enableInput();
                return;
            }
            await typeLines([
                { text: '' },
                { text: '> cub task ready', cls: 'command-echo' },
                { text: '' },
                { text: ' ID        Title                           Status', cls: 'dim' },
                { text: ' MEGA-001  Batch-close duplicate tickets   ready' },
                { text: ' MEGA-002  Auto-triage by category         ready' },
                { text: ' MEGA-003  Fix "the thing" (interpret)     ready' },
                { text: ' MEGA-004  Resolve login-button-color      ready' },
                { text: ' MEGA-005  Handle Dave\'s "bug" tickets     ready' },
                { text: ' ... (42 more)', cls: 'dim' },
                { text: '' },
            ]);
            addChips([
                { cmd: 'cub status', label: 'cub status' },
                { cmd: 'cub run', label: 'cub run' },
            ]);
            enableInput();
            return;
        }
        if (cmd === 'cub status' || cmd === 'status') {
            if (state.step < 1) {
                await typeLines([{ text: 'Stage tasks first with "cub stage".' }]);
                addChips([{ cmd: 'cub stage', label: 'cub stage' }]);
                enableInput();
                return;
            }
            await typeLines([
                { text: '' },
                { text: '> cub status', cls: 'command-echo' },
                { text: '' },
                { text: ` ░░░░░░░░░░░░░░░░░░░░░░░░ ${Math.round(state.tickets/100)}% (${state.tickets.toLocaleString()}/10,000 tickets)` },
                { text: ' 47 tasks ready | 0 in progress | 0 complete' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub run', label: 'cub run' }]);
            enableInput();
            return;
        }
        if (cmd === 'cub run' || cmd === 'run') {
            if (state.step < 1) {
                await typeLines([{ text: 'Stage tasks first with "cub stage".' }]);
                addChips([{ cmd: 'cub stage', label: 'cub stage' }]);
                enableInput();
                return;
            }
            advanceTime(30);
            await typeLines([
                { text: '' },
                { text: '> cub run', cls: 'command-echo' },
                { text: '' },
                { text: 'Cub is loose. Stand back.', cls: 'success' },
                { text: '' },
                { text: '[MONTAGE SEQUENCE]', cls: 'highlight' },
                { text: '' },
            ]);

            // Animated montage
            const tasks = [
                { name: 'MEGA-001: Closed 3,847 duplicate tickets', from: 0, to: 3847 },
                { name: 'MEGA-002: Auto-triaged 2,100 by category', from: 3847, to: 5947 },
                { name: 'MEGA-003: Interpreted "the thing" as login bug', from: 5947, to: 5948 },
            ];

            for (const task of tasks) {
                addLine(`  Processing: ${task.name}...`, 'dim');
                await animateTickets(task.from, task.to, 1200);
                const lastLine = terminal().lastElementChild;
                lastLine.textContent = `  ${task.name}`;
                lastLine.className = 'output-line success';
                await sleep(300);
            }

            await typeLines([
                { text: '  ... (processing continues autonomously)', cls: 'dim' },
                { text: '' },
            ]);

            await sleep(500);
            // OKR interruption
            await interruption_okr();
            return;
        }
        await typeLines([{ text: 'Try: cub stage, cub task ready, cub status, cub run' }]);
        enableInput();
        return;
    }

    // ROOM 4: Final Push (ledger + suggest)
    if (state.room === 4) {
        if (cmd === 'cub ledger show' || cmd === 'ledger show' || cmd === 'cub ledger') {
            state.step = 1;
            await typeLines([
                { text: '' },
                { text: '> cub ledger show', cls: 'command-echo' },
                { text: '' },
                { text: ' Session     Task       Duration  Tokens    Cost', cls: 'dim' },
                { text: ' sess-001    MEGA-001   4m 30s    45,231   $0.12' },
                { text: ' sess-002    MEGA-002   3m 15s    38,100   $0.09' },
                { text: ' sess-003    MEGA-003   1m 02s    12,400   $0.03' },
                { text: ' sess-004    MEGA-004   2m 48s    31,200   $0.08' },
                { text: ' ...         ...        ...       ...      ...', cls: 'dim' },
                { text: ' Total: 38 tasks | $2.47 spent | 7,200 tickets resolved', cls: 'highlight' },
                { text: '' },
                { text: 'Brenda nods approvingly. "Let\'s circle back on this."' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub suggest', label: 'cub suggest' }]);
            enableInput();
            return;
        }
        if (cmd === 'cub suggest' || cmd === 'suggest') {
            state.step = 2;
            await typeLines([
                { text: '' },
                { text: '> cub suggest', cls: 'command-echo' },
                { text: '' },
                { text: ' Recommended: Continue running \u2014 9 tasks remain', cls: 'success' },
                { text: ' ETA: ~45 minutes to completion' },
                { text: ' Risk: Low \u2014 all remaining tasks are straightforward' },
                { text: '' },
                { text: 'Brenda is satisfied. She retreats to her office.' },
                { text: '' },
            ]);

            if (state.step >= 1) {
                await sleep(500);
                // 1:1 interruption then finish
                await interruption_sync();
                return;
            }
            enableInput();
            return;
        }
        if (cmd === 'cub status' || cmd === 'status') {
            await typeLines([
                { text: '' },
                { text: '> cub status', cls: 'command-echo' },
                { text: ` ████████████████░░░░░░░░ 72% (${state.tickets.toLocaleString()}/10,000 tickets)` },
                { text: ' 38 tasks complete | 4 in progress | 5 ready' },
                { text: '' },
            ]);
            addChips([
                { cmd: 'cub ledger show', label: 'cub ledger show' },
                { cmd: 'cub suggest', label: 'cub suggest' },
            ]);
            enableInput();
            return;
        }
        await typeLines([{ text: 'Try: cub ledger show, cub suggest, cub status' }]);
        addChips([
            { cmd: 'cub ledger show', label: 'cub ledger show' },
            { cmd: 'cub suggest', label: 'cub suggest' },
        ]);
        enableInput();
        return;
    }

    // ROOM 5: Finish Line
    if (state.room === 5) {
        if (cmd === 'cub run' || cmd === 'cub run --once' || cmd === 'run') {
            advanceTime(20);
            await typeLines([
                { text: '' },
                { text: '> cub run', cls: 'command-echo' },
                { text: '' },
                { text: 'Processing remaining tasks...', cls: 'success' },
                { text: '' },
            ]);

            const finalTasks = [
                { name: 'MEGA-045: Resolved edge cases', from: 9100, to: 9500 },
                { name: 'MEGA-046: Final batch cleanup', from: 9500, to: 9850 },
                { name: 'MEGA-047: Verification pass', from: 9850, to: 10000 },
            ];

            for (const task of finalTasks) {
                addLine(`  Processing: ${task.name}...`, 'dim');
                await animateTickets(task.from, task.to, 1000);
                const lastLine = terminal().lastElementChild;
                lastLine.textContent = `  ${task.name}`;
                lastLine.className = 'output-line success';
                await sleep(400);
            }

            await sleep(500);
            await showVictory();
            return;
        }
        if (cmd === 'cub status' || cmd === 'status') {
            await typeLines([
                { text: '' },
                { text: '> cub status', cls: 'command-echo' },
                { text: ` ██████████████████████░░ 91% (${state.tickets.toLocaleString()}/10,000 tickets)`, cls: '' },
                { text: ' 44 tasks complete | 0 in progress | 3 ready' },
                { text: '' },
                { text: 'Almost there. Run cub one more time.', cls: 'highlight' },
                { text: '' },
            ]);
            addChips([{ cmd: 'cub run', label: 'cub run' }]);
            enableInput();
            return;
        }
        await typeLines([{ text: 'You\'re so close! Type "cub run" to finish this.' }]);
        addChips([{ cmd: 'cub run', label: 'cub run' }]);
        enableInput();
        return;
    }

    // Default fallback
    await typeLines([{ text: 'I don\'t understand that command. Type "help" for options.' }]);
    enableInput();
}

// ─── INPUT HANDLING ─────────────────────────────────────────────

function startGame() {
    document.getElementById('title-screen').style.display = 'none';
    const gameScreen = document.getElementById('game-screen');
    gameScreen.style.display = 'flex';
    updateStatus();
    room0_cubicle();
}

document.addEventListener('keydown', (e) => {
    // Title screen: any key starts
    if (document.getElementById('title-screen').style.display !== 'none') {
        startGame();
        return;
    }

    // Skip typing animation on click/key
    if (state.typing) {
        state.skipTyping = true;
        return;
    }

    const inputEl = input();

    // History navigation
    if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (state.historyIndex > 0) {
            state.historyIndex--;
            inputEl.value = state.commandHistory[state.historyIndex];
        }
        return;
    }
    if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (state.historyIndex < state.commandHistory.length - 1) {
            state.historyIndex++;
            inputEl.value = state.commandHistory[state.historyIndex];
        } else {
            state.historyIndex = state.commandHistory.length;
            inputEl.value = '';
        }
        return;
    }

    if (e.key === 'Enter' && state.inputEnabled) {
        const val = inputEl.value;
        inputEl.value = '';
        executeCommand(val);
    }
});

// Click terminal to focus input
document.addEventListener('click', (e) => {
    if (state.typing) {
        state.skipTyping = true;
        return;
    }
});
</script>

</body>
</html>
