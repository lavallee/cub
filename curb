#!/usr/bin/env bash
#
# curb - Claude Under Ralph + Beads
#
# Autonomous AI coding agent harness that drives Claude Code in a loop
# to build software from a prd.json backlog with beads-style task tracking.
#
# Usage:
#   curb              # Run loop until all tasks complete
#   curb --once       # Run single iteration
#   curb --status     # Show current task status
#   curb --ready      # Show ready tasks
#   curb --plan       # Run in planning mode (generate fix_plan.md)
#   curb --budget 1000000  # Set token budget for run
#   curb --debug      # Enable debug logging (can combine with other flags)
#
set -euo pipefail

# Version information
CURB_VERSION="1.0.0"

CURB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${CURB_PROJECT_DIR:-$(pwd)}"

# Source task management library
source "${CURB_DIR}/lib/tasks.sh"
# Source harness abstraction layer
source "${CURB_DIR}/lib/harness.sh"
# Source XDG directory helpers
source "${CURB_DIR}/lib/xdg.sh"
# Source configuration management
source "${CURB_DIR}/lib/config.sh"
# Source logger
source "${CURB_DIR}/lib/logger.sh"
# Source git operations
source "${CURB_DIR}/lib/git.sh"
# Source state verification
source "${CURB_DIR}/lib/state.sh"
# Source budget tracking
source "${CURB_DIR}/lib/budget.sh"
# Source hooks framework
source "${CURB_DIR}/lib/hooks.sh"
# Source session management
source "${CURB_DIR}/lib/session.sh"
# Source artifacts management
source "${CURB_DIR}/lib/artifacts.sh"
# Source failure handling
source "${CURB_DIR}/lib/failure.sh"

# Load configuration early
config_load

# Version subcommand
cmd_version() {
    echo "curb v${CURB_VERSION}"
    return 0
}

# Show help for init subcommand
cmd_init_help() {
    cat <<'EOF'
curb init [--global] [<directory>]

Initialize curb in a project or globally.

USAGE:
  curb init              Initialize in current directory
  curb init --global    Set up global configuration
  curb init <dir>       Initialize in specific directory

OPTIONS:
  --global              Set up global configuration (~/.config/curb)
                        Creates config templates and hook directories.
                        Only needs to run once per system.

  <directory>           Directory to initialize (default: current dir)
                        Creates prd.json, PROMPT.md, AGENT.md, etc.

WHAT IT CREATES:
  prd.json              Task backlog in JSON format
  PROMPT.md             System prompt template
  AGENT.md              Build/run instructions
  progress.txt          Progress tracking (auto-updated)
  fix_plan.md           Issue tracking (auto-updated)
  .gitignore            With curb patterns

GLOBAL SETUP:
  ~/.config/curb/config.json       Configuration defaults
  ~/.config/curb/hooks/            Hook directories

EXAMPLES:
  # Initialize in current directory
  curb init

  # Initialize specific project
  curb init ~/my-project

  # Set up system-wide defaults
  curb init --global

  # Then initialize a project
  curb init ~/my-project

SEE ALSO:
  curb --help       Show all commands
  curb status       Check project status
EOF
}

# Init subcommand - initialize a project
cmd_init() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_init_help
        return 0
    fi

    # Parse flags
    local global_init=false
    if [[ "${1:-}" == "--global" ]]; then
        global_init=true
        shift
    fi

    local target_dir="${1:-.}"

    # ============================================================================
    # Global initialization (--global flag)
    # ============================================================================
    if [[ "$global_init" == "true" ]]; then
        log_info "Initializing global curb configuration"
        echo ""

        # Check dependencies
        log_info "Checking dependencies..."
        local missing_deps=()

        # Check for jq
        if ! command -v jq >/dev/null 2>&1; then
            missing_deps+=("jq")
            _log_error_console "Missing dependency: jq"
            echo "  Install with: brew install jq (macOS) or apt-get install jq (Linux)"
        else
            log_success "Found jq"
        fi

        # Check for at least one harness
        local harness_found=false
        if command -v claude >/dev/null 2>&1; then
            log_success "Found claude harness"
            harness_found=true
        fi
        if command -v codex >/dev/null 2>&1; then
            log_success "Found codex harness"
            harness_found=true
        fi

        if [[ "$harness_found" == "false" ]]; then
            missing_deps+=("harness (claude or codex)")
            _log_error_console "No harness found (need claude or codex)"
            echo "  Install Claude Code: https://claude.com/claude-code"
            echo "  Or Codex: npm install -g @anthropic/codex"
        fi

        # Exit if dependencies missing
        if [[ ${#missing_deps[@]} -gt 0 ]]; then
            echo ""
            _log_error_console "Missing required dependencies. Please install them and try again."
            return 1
        fi

        echo ""
        log_info "Creating global directory structure..."

        # Create XDG directories
        curb_ensure_dirs

        local config_dir
        config_dir="$(curb_config_dir)"
        local config_file="${config_dir}/config.json"
        local hooks_dir="${config_dir}/hooks"

        log_success "Created ${config_dir}"
        log_success "Created $(curb_logs_dir)"
        log_success "Created $(curb_cache_dir)"

        # Create config file with sensible defaults
        log_info "Creating default configuration..."

        if [[ -f "$config_file" ]]; then
            log_warn "Config file already exists at ${config_file}"
            log_warn "Skipping config creation (remove file to recreate)"
        else
            cat > "$config_file" <<'EOF'
{
  "harness": {
    "default": "auto",
    "priority": ["claude", "gemini", "codex", "opencode"]
  },
  "budget": {
    "default": 1000000,
    "warn_at": 0.8
  },
  "loop": {
    "max_iterations": 100
  },
  "clean_state": {
    "require_commit": true,
    "require_tests": false
  },
  "hooks": {
    "enabled": true
  }
}
EOF
            log_success "Created ${config_file}"
        fi

        # Create hook directories
        log_info "Creating hook directories..."

        local hook_types=("pre-loop" "pre-task" "post-task" "on-error" "post-loop")
        for hook_type in "${hook_types[@]}"; do
            local hook_dir="${hooks_dir}/${hook_type}.d"
            if [[ ! -d "$hook_dir" ]]; then
                mkdir -p "$hook_dir"
                log_success "Created ${hook_dir}"
            else
                log_warn "${hook_dir} already exists"
            fi
        done

        echo ""
        log_success "Global curb configuration complete!"
        echo ""
        echo "Configuration:"
        echo "  Config file:  ${config_file}"
        echo "  Hooks:        ${hooks_dir}"
        echo "  Logs:         $(curb_logs_dir)"
        echo ""
        echo "Next steps:"
        echo "  1. Review and customize ${config_file}"
        echo "  2. Add custom hooks to ${hooks_dir}/<hook-type>.d/"
        echo "  3. Initialize a project with: curb init <project-dir>"
        echo "  4. Start building: cd <project-dir> && curb"
        echo ""
        echo "Configuration options:"
        echo "  harness.default       - Default harness to use (auto|claude|codex)"
        echo "  harness.priority      - Order to try harnesses when auto"
        echo "  budget.default        - Default token budget per run"
        echo "  loop.max_iterations   - Maximum iterations before stopping"
        echo "  clean_state.require_commit - Require harness to commit changes"
        echo ""

        return 0
    fi

    # ============================================================================
    # Project initialization (default behavior)
    # ============================================================================

    # Get project name from directory
    local project_name
    project_name=$(basename "$(cd "$target_dir" && pwd)")
    local prefix
    prefix=$(echo "$project_name" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' | head -c 8)
    [[ -z "$prefix" ]] && prefix="prd"

    log_info "Initializing curb in: ${target_dir}"
    log_info "Project prefix: ${prefix}"

    cd "$target_dir" || return 1

    # Create specs directory
    if [[ ! -d "specs" ]]; then
        mkdir -p specs
        log_success "Created specs/"
    fi

    # Create prd.json if not exists
    if [[ ! -f "prd.json" ]]; then
        cat > prd.json <<EOF
{
  "projectName": "${project_name}",
  "branchName": "feature/${project_name}",
  "prefix": "${prefix}",
  "tasks": [
    {
      "id": "${prefix}-init",
      "type": "task",
      "title": "Project initialization",
      "description": "Set up the initial project structure and configuration",
      "acceptanceCriteria": [
        "Project builds successfully",
        "Basic structure in place",
        "typecheck passes",
        "tests pass (or test framework configured)"
      ],
      "priority": "P0",
      "status": "open",
      "dependsOn": [],
      "notes": ""
    }
  ]
}
EOF
        log_success "Created prd.json with initial task"
    else
        log_warn "prd.json already exists, skipping"
    fi

    # Create PROMPT.md
    if [[ ! -f "PROMPT.md" ]]; then
        cp "${CURB_DIR}/templates/PROMPT.md" PROMPT.md
        log_success "Created PROMPT.md"
    else
        log_warn "PROMPT.md already exists, skipping"
    fi

    # Create AGENT.md
    if [[ ! -f "AGENT.md" ]]; then
        cp "${CURB_DIR}/templates/AGENT.md" AGENT.md
        log_success "Created AGENT.md"
    else
        log_warn "AGENT.md already exists, skipping"
    fi

    # Create AGENTS.md symlink for Codex compatibility
    # Codex CLI looks for AGENTS.md in the project root
    if [[ ! -f "AGENTS.md" && ! -L "AGENTS.md" ]]; then
        ln -s AGENT.md AGENTS.md
        log_success "Created AGENTS.md symlink (for Codex compatibility)"
    elif [[ -L "AGENTS.md" ]]; then
        log_warn "AGENTS.md symlink already exists, skipping"
    else
        log_warn "AGENTS.md already exists as file, skipping symlink"
    fi

    # Create progress.txt
    if [[ ! -f "progress.txt" ]]; then
        cat > progress.txt <<EOF
# Progress Log
Started: $(date -u +"%Y-%m-%d")

## Codebase Patterns
<!-- Agent adds discovered patterns here for future iterations -->

## Key Files
<!-- Important files to be aware of -->

---
EOF
        log_success "Created progress.txt"
    else
        log_warn "progress.txt already exists, skipping"
    fi

    # Create fix_plan.md
    if [[ ! -f "fix_plan.md" ]]; then
        cat > fix_plan.md <<EOF
# Fix Plan

Discovered issues and planned improvements.
Agent maintains this file during development.

## High Priority

## Medium Priority

## Low Priority

## Completed
EOF
        log_success "Created fix_plan.md"
    else
        log_warn "fix_plan.md already exists, skipping"
    fi

    # Create .gitignore additions
    if [[ -f ".gitignore" ]]; then
        if ! grep -q "# Curb" .gitignore 2>/dev/null; then
            cat >> .gitignore <<EOF

# Curb
*.curb.tmp
EOF
            log_success "Updated .gitignore"
        fi
    else
        cat > .gitignore <<EOF
# Curb
*.curb.tmp
EOF
        log_success "Created .gitignore"
    fi

    echo ""
    log_success "Curb initialized!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit prd.json to add your tasks (use ChatPRD template output)"
    echo "  2. Add specifications to specs/"
    echo "  3. Update AGENT.md with build instructions"
    echo "  4. Run 'curb status' to see task summary"
    echo "  5. Run 'curb' to start the autonomous loop"
    echo ""
    echo "Useful commands:"
    echo "  curb status        Show task progress"
    echo "  curb run --ready   Show ready tasks"
    echo "  curb run --once    Run single iteration"
    echo "  curb run --plan    Run planning mode"
    echo "  curb --harness codex Use OpenAI Codex instead of Claude"
    echo ""

    return 0
}

# Show help for run subcommand
cmd_run_help() {
    cat <<'EOF'
curb run [<options>]

Run the autonomous coding loop to complete tasks.

USAGE:
  curb run              Run continuous loop (default behavior)
  curb run --once       Run exactly one iteration then exit
  curb run --ready      Show ready (unblocked) tasks without running
  curb run --plan       Run planning mode to analyze codebase

EXECUTION OPTIONS:
  --once, -1            Run single iteration then exit
  --ready, -r           List tasks ready to work on
  --plan, -p            Generate fix_plan.md with code analysis
  --push                Push completed work to remote (experimental)

FILTERING:
  --epic <id>           Only work on tasks in this epic
  --label <name>        Only work on tasks with this label

MODEL & HARNESS:
  --model <name>        Claude model: opus, sonnet, haiku
  --harness <name>      AI harness: claude, codex, gemini, opencode

RELIABILITY:
  --require-clean       Force clean git state before starting
  --no-require-clean    Disable clean state check

BUDGET & LIMITS:
  --budget <tokens>     Token budget limit (e.g., 1000000)
  --name <name>         Session name for tracking

DEBUG:
  --debug, -d           Show detailed execution logs
  --stream              Stream harness output in real-time

EXAMPLES:
  # Run continuous loop
  curb run

  # Run once with budget limit
  curb run --once --budget 1000000

  # View ready tasks without running
  curb run --ready

  # Work on specific epic only
  curb run --epic backend-v2

  # Use Sonnet with live output
  curb run --model sonnet --stream

  # Run with detailed debugging
  curb run --once --debug

SEE ALSO:
  curb --help       Show all commands
  curb status       Check current progress
  curb artifacts    Access task output files
EOF
}

# Run subcommand - run the main loop
cmd_run() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_run_help
        return 0
    fi

    # Parse run-specific flags
    local args=()
    local run_once=false
    local run_plan=false
    local run_ready=false

    # Local copies of flag variables (can be overridden per-run)
    local cmd_epic="${EPIC}"
    local cmd_label="${LABEL}"
    local cmd_model="${MODEL}"
    local cmd_budget="${BUDGET}"
    local cmd_require_clean="${REQUIRE_CLEAN}"
    local cmd_session_name="${SESSION_NAME}"
    local cmd_push=false

    for arg in "$@"; do
        case "$arg" in
            --once|-1)
                run_once=true
                ;;
            --plan|-p)
                run_plan=true
                ;;
            --ready|-r)
                run_ready=true
                ;;
            --push)
                cmd_push=true
                ;;
            --require-clean)
                cmd_require_clean="true"
                export CURB_REQUIRE_CLEAN="true"
                log_info "Clean state enforcement enabled via CLI flag"
                ;;
            --no-require-clean)
                cmd_require_clean="false"
                export CURB_REQUIRE_CLEAN="false"
                log_info "Clean state enforcement disabled via CLI flag"
                ;;
            --model=*)
                cmd_model="${arg#--model=}"
                export CURB_MODEL="$cmd_model"
                ;;
            --model)
                _next_is_model=true
                ;;
            --epic=*)
                cmd_epic="${arg#--epic=}"
                export CURB_EPIC="$cmd_epic"
                ;;
            --epic)
                _next_is_epic=true
                ;;
            --label=*)
                cmd_label="${arg#--label=}"
                export CURB_LABEL="$cmd_label"
                ;;
            --label)
                _next_is_label=true
                ;;
            --budget=*)
                cmd_budget="${arg#--budget=}"
                export CURB_BUDGET="$cmd_budget"
                ;;
            --budget)
                _next_is_budget=true
                ;;
            --name=*)
                cmd_session_name="${arg#--name=}"
                export CURB_SESSION_NAME="$cmd_session_name"
                ;;
            --name)
                _next_is_name=true
                ;;
            *)
                # Handle deferred flag values
                if [[ "${_next_is_model:-}" == "true" ]]; then
                    cmd_model="$arg"
                    export CURB_MODEL="$cmd_model"
                    _next_is_model=false
                elif [[ "${_next_is_epic:-}" == "true" ]]; then
                    cmd_epic="$arg"
                    export CURB_EPIC="$cmd_epic"
                    _next_is_epic=false
                elif [[ "${_next_is_label:-}" == "true" ]]; then
                    cmd_label="$arg"
                    export CURB_LABEL="$cmd_label"
                    _next_is_label=false
                elif [[ "${_next_is_budget:-}" == "true" ]]; then
                    cmd_budget="$arg"
                    export CURB_BUDGET="$cmd_budget"
                    _next_is_budget=false
                elif [[ "${_next_is_name:-}" == "true" ]]; then
                    cmd_session_name="$arg"
                    export CURB_SESSION_NAME="$cmd_session_name"
                    _next_is_name=false
                else
                    args+=("$arg")
                fi
                ;;
        esac
    done

    # Clean up flag parsing state
    unset _next_is_model
    unset _next_is_epic
    unset _next_is_label
    unset _next_is_budget
    unset _next_is_name

    # Update global variables if they were set via cmd_run flags
    EPIC="$cmd_epic"
    LABEL="$cmd_label"
    MODEL="$cmd_model"
    BUDGET="$cmd_budget"
    REQUIRE_CLEAN="$cmd_require_clean"
    SESSION_NAME="$cmd_session_name"
    PUSH="$cmd_push"

    # Initialize budget if provided via CLI, environment, or config
    # Get budget from: CLI flag > environment > config file
    local budget_limit="${BUDGET:-$(config_get_or "budget.limit" "")}"
    if [[ -n "$budget_limit" ]]; then
        if budget_init "$budget_limit"; then
            log_info "Budget initialized: ${budget_limit} tokens"
        else
            log_warn "Failed to initialize budget with value: ${budget_limit}"
        fi
    fi

    # Load iteration limits from config
    local max_task_iterations
    max_task_iterations=$(config_get_or "guardrails.max_task_iterations" "3")
    if budget_set_max_task_iterations "$max_task_iterations"; then
        log_debug "Max task iterations: ${max_task_iterations}"
    else
        log_warn "Failed to set max task iterations"
    fi

    local max_run_iterations
    max_run_iterations=$(config_get_or "guardrails.max_run_iterations" "50")
    if budget_set_max_run_iterations "$max_run_iterations"; then
        log_debug "Max run iterations: ${max_run_iterations}"
    else
        log_warn "Failed to set max run iterations"
    fi

    validate_project

    # Execute based on mode
    if [[ "$run_ready" == "true" ]]; then
        show_ready
    elif [[ "$run_plan" == "true" ]]; then
        run_planning
    elif [[ "$run_once" == "true" ]]; then
        run_iteration
    else
        run_loop
    fi
}

# Show help for status subcommand
cmd_status_help() {
    cat <<'EOF'
curb status [--json]

Display current task progress and status summary.

USAGE:
  curb status           Show formatted status summary
  curb status --json    Output status as machine-readable JSON

OUTPUT:
  When run without --json:
    - Task counts (total, closed, in progress, open)
    - Progress bar showing percentage complete
    - Current session information (if running)
    - Most recent run details

  When run with --json:
    - Machine-readable JSON with task counts
    - Current session object (if initialized)
    - Most recent run information

EXAMPLES:
  # Show human-readable status
  curb status

  # Check progress before running
  curb status

  # Get JSON for scripting
  curb status --json | jq '.task_counts'

  # Monitor while loop runs in background
  watch -n 5 'curb status'

SEE ALSO:
  curb run --ready    List tasks ready to work on
  curb --help         Show all commands
  curb artifacts      Access task output files
EOF
}

# Status subcommand - show task status
cmd_status() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_status_help
        return 0
    fi

    local json_output=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            *)
                _log_error_console "Unknown flag: $1"
                _log_error_console "Usage: curb status [--json]"
                return 1
                ;;
        esac
    done

    # In JSON mode, suppress logging during validation
    if [[ "$json_output" == "true" ]]; then
        validate_project >/dev/null 2>&1
        show_status_json
    else
        validate_project
        show_status
    fi
}

# Show help for explain subcommand
cmd_explain_help() {
    cat <<'EOF'
curb explain <task-id>

Show detailed information about a specific task, including failure
reasons and blocking dependencies.

USAGE:
  curb explain <task-id>    Display full task details

OUTPUT INCLUDES:
  - Task ID and title
  - Task type (task, feature, bugfix, etc)
  - Current status (open, in_progress, closed, failed)
  - Priority level
  - Full description
  - Acceptance criteria
  - Dependencies (tasks that must be completed first)
  - Labels and other metadata

FOR FAILED TASKS:
  - Exit code from last execution
  - Failure mode (stop, move-on, retry)
  - Timestamp of failure
  - Error output (if captured)
  - Suggestions for resolution

FOR BLOCKED TASKS:
  - List of blocking dependencies with their status
  - Suggestions for unblocking

EXAMPLES:
  # View task details
  curb explain curb-018

  # Investigate why a task failed
  curb explain curb-041

  # Check what's blocking a task
  curb explain feature-42

  # Look up a task's requirements
  curb explain backend-001

SEE ALSO:
  curb status       Check overall progress
  curb run --ready  List ready tasks
  curb artifacts    Access task output files
  curb --help       Show all commands
EOF
}

# Explain subcommand - show details about a task or session
cmd_explain() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_explain_help
        return 0
    fi

    local target="${1:-}"
    if [[ -z "$target" ]]; then
        _log_error_console "Usage: curb explain <task-id>"
        return 1
    fi

    # Check if it's a task ID or session ID
    local backend=$(get_backend "${PROJECT_DIR}")

    # Try to get task first
    local prd="${PROJECT_DIR}/prd.json"
    local task
    task=$(get_task "$prd" "$target" 2>/dev/null) || true

    if [[ -n "$task" && "$task" != "null" ]]; then
        # Found a task - show task details
        local task_id=$(echo "$task" | jq -r '.id')
        local task_status=$(echo "$task" | jq -r '.status')

        echo "$task" | jq -r '
            "Task: \(.id)",
            "Title: \(.title)",
            "Type: \(.type // "task")",
            "Status: \(.status)",
            "Priority: \(.priority // "normal")",
            "",
            "Description:",
            "\(.description)",
            "",
            (if .acceptanceCriteria then "Acceptance Criteria:\n- " + (.acceptanceCriteria | join("\n- ")) else "" end),
            (if .dependsOn and (.dependsOn | length > 0) then "\nDepends on: " + (.dependsOn | join(", ")) else "" end),
            (if .labels and (.labels | length > 0) then "\nLabels: " + (.labels | join(", ")) else "" end)
        '

        # Show failure reason if task failed
        if [[ "$task_status" == "failed" ]]; then
            echo ""
            echo -e "${RED}=== Failure Information ===${NC}"

            # Look for failure.json in artifacts
            local artifacts_base="${PROJECT_DIR}/.curb/runs"
            local failure_file=""
            if [[ -d "$artifacts_base" ]]; then
                failure_file=$(find "$artifacts_base" -path "*/tasks/${task_id}/failure.json" 2>/dev/null | head -n 1)
            fi

            if [[ -n "$failure_file" && -f "$failure_file" ]]; then
                local exit_code=$(jq -r '.exit_code // "unknown"' "$failure_file" 2>/dev/null)
                local mode=$(jq -r '.mode // "unknown"' "$failure_file" 2>/dev/null)
                local timestamp=$(jq -r '.timestamp // "unknown"' "$failure_file" 2>/dev/null)
                local output=$(jq -r '.output // ""' "$failure_file" 2>/dev/null)

                echo "Exit code: ${exit_code}"
                echo "Failure mode: ${mode}"
                echo "Timestamp: ${timestamp}"
                if [[ -n "$output" && "$output" != "null" && "$output" != "" ]]; then
                    echo ""
                    echo "Error output:"
                    echo "$output"
                fi
            else
                echo "No detailed failure information available."
                echo "The task may have failed before artifacts were created."
            fi

            # Provide suggestions
            echo ""
            echo -e "${YELLOW}Suggestions:${NC}"
            echo "  - Review task artifacts: curb artifacts ${task_id}"
            echo "  - Reset to open and retry: update status to 'open' in task source"
            echo "  - Check logs for more details"
        fi

        # Check for blocking dependencies
        local depends_on=$(echo "$task" | jq -r '.dependsOn // [] | .[]' 2>/dev/null)
        if [[ -n "$depends_on" ]]; then
            local blocking_deps=()
            while IFS= read -r dep_id; do
                if [[ -n "$dep_id" ]]; then
                    # Check if dependency is closed
                    local dep_task
                    dep_task=$(get_task "$prd" "$dep_id" 2>/dev/null)
                    if [[ -n "$dep_task" && "$dep_task" != "null" ]]; then
                        local dep_status=$(echo "$dep_task" | jq -r '.status')
                        if [[ "$dep_status" != "closed" ]]; then
                            blocking_deps+=("${dep_id} (${dep_status})")
                        fi
                    else
                        blocking_deps+=("${dep_id} (not found)")
                    fi
                fi
            done <<< "$depends_on"

            if [[ ${#blocking_deps[@]} -gt 0 ]]; then
                echo ""
                echo -e "${YELLOW}=== Blocking Dependencies ===${NC}"
                echo "This task is blocked by the following dependencies:"
                for blocking in "${blocking_deps[@]}"; do
                    echo "  - ${blocking}"
                done
                echo ""
                echo -e "${YELLOW}Suggestions:${NC}"
                echo "  - Complete blocking tasks first"
                echo "  - Use 'curb explain <dep-id>' to investigate blockers"
            fi
        fi

        # Show artifacts path if available
        local artifacts_base="${PROJECT_DIR}/.curb/runs"
        if [[ -d "$artifacts_base" ]]; then
            local task_dir=$(find "$artifacts_base" -path "*/tasks/${task_id}" -type d 2>/dev/null | head -n 1)
            if [[ -n "$task_dir" && -d "$task_dir" ]]; then
                echo ""
                echo "Artifacts: ${task_dir}"
            fi
        fi
    else
        # Not a task, maybe a session? (future implementation)
        _log_error_console "Task not found: ${target}"
        _log_error_console "Tip: Run 'curb status' to see available tasks"
        return 1
    fi
}

# Show help for artifacts subcommand
cmd_artifacts_help() {
    cat <<'EOF'
curb artifacts [<task-id>]

Access and navigate to task artifact directories and output files.

USAGE:
  curb artifacts              List recent tasks with artifact paths
  curb artifacts <task-id>    Show path to specific task artifacts
  curb artifacts <prefix>     Find tasks by ID prefix (partial match)

TASK ARTIFACTS INCLUDE:
  - task.json              Task metadata and status
  - summary.md             Execution summary
  - changes.patch          Git diff of changes made
  - logs/                  Detailed execution logs
  - run.json               Run-level information

EXAMPLES:
  # List all recent tasks
  curb artifacts

  # Get path to specific task (useful for scripts)
  curb artifacts curb-018
  # Output: .curb/runs/panda-20260110-141339/tasks/curb-018

  # Use in shell command
  cd $(curb artifacts curb-018)
  cat summary.md

  # Find by prefix (shows matches if ambiguous)
  curb artifacts curb-01

  # View recent task summary
  cat $(curb artifacts curb-017)/summary.md

  # Examine git changes made by task
  patch -p1 -R < $(curb artifacts curb-016)/changes.patch

  # Find task logs
  ls $(curb artifacts curb-015)/logs/

SEE ALSO:
  curb status      Check task progress
  curb --help      Show all commands
EOF
}

# Artifacts subcommand - manage artifacts
cmd_artifacts() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_artifacts_help
        return 0
    fi

    local artifacts_base=".curb/runs"

    # If no arguments given, list recent tasks with paths
    if [[ $# -eq 0 ]]; then
        if [[ ! -d "$artifacts_base" ]]; then
            log_info "No artifacts found"
            return 0
        fi

        log_info "Recent tasks:"
        # Find all task directories, sort by modification time (newest first)
        find "$artifacts_base" -maxdepth 3 -type d -name "curb-*" | sort -r | while read -r task_dir; do
            if [[ -f "$task_dir/task.json" ]]; then
                local task_id=$(basename "$task_dir")
                echo "  ${task_id}: ${task_dir}"
            fi
        done
        return 0
    fi

    # Find a task by task_id (supports prefix matching)
    local search_id="$1"
    local artifacts_base=".curb/runs"

    if [[ ! -d "$artifacts_base" ]]; then
        _log_error_console "No artifacts found (no runs yet)"
        return 1
    fi

    # Search for matching task_id across all runs
    # Support both exact and prefix matches
    local matches=()
    while IFS= read -r task_dir; do
        if [[ -f "$task_dir/task.json" ]]; then
            local task_id=$(basename "$task_dir")
            # Check for exact match first, or prefix match
            if [[ "$task_id" == "$search_id" ]] || [[ "$task_id" == "$search_id"* ]]; then
                matches+=("$task_dir")
            fi
        fi
    done < <(find "$artifacts_base" -maxdepth 3 -type d -name "curb-*" 2>/dev/null)

    if [[ ${#matches[@]} -eq 0 ]]; then
        _log_error_console "Task not found: ${search_id}"
        _log_error_console "Tip: Run 'curb artifacts' to see available tasks"
        return 1
    fi

    if [[ ${#matches[@]} -eq 1 ]]; then
        # Single match - print the path
        echo "${matches[0]}"
        return 0
    fi

    # Multiple matches - show them and ask user to be more specific
    _log_error_console "Ambiguous task ID '${search_id}' matches ${#matches[@]} tasks:"
    for match in "${matches[@]}"; do
        _log_error_console "  $(basename "$match"): ${match}"
    done
    _log_error_console "Please use a more specific prefix"
    return 1
}

# Show help for agent-close subcommand
cmd_agent_close_help() {
    cat <<'EOF'
curb agent-close <task-id>

Mark a task as closed (complete). This command is backend-aware and works
with both beads and prd.json backends.

USAGE:
  curb agent-close <task-id>    Mark the specified task as closed

DESCRIPTION:
  This command is designed to be called by the AI agent during task
  completion. It automatically detects the task backend (beads or json)
  and uses the appropriate method to close the task.

  For beads backend:  Runs 'bd close <task-id>'
  For json backend:   Updates prd.json to set status="closed"

EXAMPLES:
  curb agent-close curb-018
  curb agent-close link-030

SEE ALSO:
  curb agent-verify   Verify a task is properly closed
  curb status         Check overall progress
  curb explain        Show task details
EOF
}

# Agent-close subcommand - close a task (backend-aware)
cmd_agent_close() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_agent_close_help
        return 0
    fi

    local task_id="${1:-}"
    if [[ -z "$task_id" ]]; then
        _log_error_console "Usage: curb agent-close <task-id>"
        return 1
    fi

    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    if [[ "$backend" == "beads" ]]; then
        log_info "Closing task $task_id via beads..."
        if bd close "$task_id" 2>&1; then
            log_success "Task $task_id closed"
            return 0
        else
            _log_error_console "Failed to close task $task_id"
            return 1
        fi
    else
        log_info "Closing task $task_id in prd.json..."
        if json_update_task_status "$prd" "$task_id" "closed"; then
            log_success "Task $task_id closed"
            return 0
        else
            _log_error_console "Failed to close task $task_id"
            return 1
        fi
    fi
}

# Show help for agent-verify subcommand
cmd_agent_verify_help() {
    cat <<'EOF'
curb agent-verify <task-id>

Verify that a task is properly marked as closed. This command is backend-aware
and works with both beads and prd.json backends.

USAGE:
  curb agent-verify <task-id>    Check if the task status is "closed"

DESCRIPTION:
  This command verifies that a task has been properly closed. It's designed
  to be called by the AI agent after closing a task to confirm the operation
  succeeded.

  Returns exit code 0 if task is closed, 1 otherwise.

EXAMPLES:
  curb agent-verify curb-018
  curb agent-verify link-030

  # In scripts:
  if curb agent-verify curb-018; then
    echo "Task is closed"
  else
    echo "Task is NOT closed"
  fi

SEE ALSO:
  curb agent-close    Close a task
  curb status         Check overall progress
  curb explain        Show task details
EOF
}

# Agent-verify subcommand - verify a task is closed
cmd_agent_verify() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_agent_verify_help
        return 0
    fi

    local task_id="${1:-}"
    if [[ -z "$task_id" ]]; then
        _log_error_console "Usage: curb agent-verify <task-id>"
        return 1
    fi

    local prd="${PROJECT_DIR}/prd.json"

    if verify_task_closed "$prd" "$task_id"; then
        log_success "Task $task_id is closed"
        return 0
    else
        _log_error_console "Task $task_id is NOT closed"
        return 1
    fi
}

# Show help for doctor subcommand
cmd_doctor_help() {
    cat <<'EOF'
curb doctor [options]

Diagnose and optionally fix common curb issues.

USAGE:
  curb doctor              Run diagnostics
  curb doctor --verbose    Show detailed diagnostic info
  curb doctor --fix        Automatically fix detected issues
  curb doctor --dry-run    Show what --fix would do

CHECKS:
  - Environment: jq, harness availability, beads (if used)
  - Project structure: prd.json/.beads, PROMPT.md, AGENT.md
  - Git state: uncommitted files categorized as:
    * session files (progress.txt, fix_plan.md) - safe to commit
    * source code - needs review before committing
    * cruft (.bak, .tmp, .DS_Store, etc.) - safe to clean
    * config files - needs careful review
  - Task state: tasks stuck in "in_progress"

FIX ACTIONS:
  --fix will:
  - Commit session files with "chore: commit session files"
  - Suggest adding cruft patterns to .gitignore
  - Report source/config files that need manual review

EXAMPLES:
  # Run diagnostics
  curb doctor

  # See what would be fixed
  curb doctor --dry-run

  # Auto-fix session files
  curb doctor --fix

SEE ALSO:
  curb init      Initialize project
  curb status    Check task progress
  curb --help    Show all commands
EOF
}

# Doctor helper: check marks for output
_doctor_ok() {
    echo -e "${GREEN}[OK]${NC} $1"
}

_doctor_warn() {
    echo -e "${YELLOW}[!!]${NC} $1"
}

_doctor_info() {
    echo -e "${BLUE}[--]${NC} $1"
}

_doctor_fail() {
    echo -e "${RED}[XX]${NC} $1"
}

# Doctor helper: check environment
_doctor_check_env() {
    local issues=0
    echo ""
    echo "Environment:"

    # Check jq
    if command -v jq &>/dev/null; then
        local jq_version
        jq_version=$(jq --version 2>/dev/null | sed 's/jq-//')
        _doctor_ok "jq installed (v${jq_version})"
    else
        _doctor_fail "jq not installed (required)"
        ((issues++))
    fi

    # Check for at least one harness
    local harness_found=false
    if command -v claude &>/dev/null; then
        _doctor_ok "claude harness available"
        harness_found=true
    fi
    if command -v codex &>/dev/null; then
        _doctor_ok "codex harness available"
        harness_found=true
    fi
    if command -v gemini &>/dev/null; then
        _doctor_ok "gemini harness available"
        harness_found=true
    fi
    if command -v opencode &>/dev/null; then
        _doctor_ok "opencode harness available"
        harness_found=true
    fi

    if [[ "$harness_found" == "false" ]]; then
        _doctor_fail "No AI harness found (need claude, codex, gemini, or opencode)"
        ((issues++))
    fi

    # Check beads (optional)
    if command -v bd &>/dev/null; then
        _doctor_ok "beads (bd) installed"
    else
        _doctor_info "beads (bd) not installed (optional)"
    fi

    return $issues
}

# Doctor helper: check project structure
_doctor_check_project() {
    local issues=0
    echo ""
    echo "Project Structure:"

    # Check for task backend
    if [[ -d "${PROJECT_DIR}/.beads" ]]; then
        local task_count
        task_count=$(bd list --json 2>/dev/null | jq 'length' 2>/dev/null || echo "?")
        _doctor_ok ".beads/ directory found (${task_count} tasks)"
    elif [[ -f "${PROJECT_DIR}/prd.json" ]]; then
        local task_count
        task_count=$(jq '.tasks | length' "${PROJECT_DIR}/prd.json" 2>/dev/null || echo "?")
        _doctor_ok "prd.json found (${task_count} tasks)"
    else
        _doctor_warn "No task backend found (need prd.json or .beads/)"
        ((issues++))
    fi

    # Check PROMPT.md
    if [[ -f "${PROJECT_DIR}/PROMPT.md" ]]; then
        _doctor_ok "PROMPT.md found"
    else
        _doctor_warn "PROMPT.md not found (run 'curb init')"
        ((issues++))
    fi

    # Check AGENT.md
    if [[ -f "${PROJECT_DIR}/AGENT.md" ]]; then
        _doctor_ok "AGENT.md found"
    else
        _doctor_warn "AGENT.md not found (run 'curb init')"
        ((issues++))
    fi

    # Check .curb/ directory
    if [[ -d "${PROJECT_DIR}/.curb" ]]; then
        _doctor_ok ".curb/ directory exists"
    else
        _doctor_info ".curb/ directory not found (will be created on first run)"
    fi

    return $issues
}

# Doctor helper: check git state
_doctor_check_git() {
    local verbose="${1:-false}"
    local issues=0
    echo ""
    echo "Git State:"

    # Check if in git repo
    if ! git_in_repo; then
        _doctor_info "Not a git repository"
        return 0
    fi

    _doctor_ok "Git repository detected"

    # Check for uncommitted changes
    local changes_json
    changes_json=$(git_categorize_changes)

    if [[ "$changes_json" == *'"error"'* ]]; then
        _doctor_fail "Error categorizing changes"
        return 1
    fi

    # Extract counts
    local session_count source_count cruft_count config_count unknown_count
    session_count=$(echo "$changes_json" | jq '.session | length')
    source_count=$(echo "$changes_json" | jq '.source | length')
    cruft_count=$(echo "$changes_json" | jq '.cruft | length')
    config_count=$(echo "$changes_json" | jq '.config | length')
    unknown_count=$(echo "$changes_json" | jq '.unknown | length')

    local total_count=$((session_count + source_count + cruft_count + config_count + unknown_count))

    if [[ $total_count -eq 0 ]]; then
        _doctor_ok "Working directory clean"
        return 0
    fi

    _doctor_warn "Uncommitted changes detected (${total_count} files)"
    ((issues++))

    # Show session files
    if [[ $session_count -gt 0 ]]; then
        echo ""
        echo "  Session files (safe to commit with --fix):"
        echo "$changes_json" | jq -r '.session[]' | while read -r file; do
            local status
            status=$(git status --porcelain "$file" 2>/dev/null | cut -c1-2)
            echo "    ${status} ${file}"
        done
    fi

    # Show source files
    if [[ $source_count -gt 0 ]]; then
        echo ""
        echo "  Source files (needs review):"
        echo "$changes_json" | jq -r '.source[]' | while read -r file; do
            local status
            status=$(git status --porcelain "$file" 2>/dev/null | cut -c1-2)
            echo "    ${status} ${file}"
        done
    fi

    # Show cruft files
    if [[ $cruft_count -gt 0 ]]; then
        echo ""
        echo "  Cruft files (safe to clean):"
        echo "$changes_json" | jq -r '.cruft[]' | while read -r file; do
            local status
            status=$(git status --porcelain "$file" 2>/dev/null | cut -c1-2)
            echo "    ${status} ${file}"
        done
    fi

    # Show config files
    if [[ $config_count -gt 0 ]]; then
        echo ""
        echo "  Config files (review carefully):"
        echo "$changes_json" | jq -r '.config[]' | while read -r file; do
            local status
            status=$(git status --porcelain "$file" 2>/dev/null | cut -c1-2)
            echo "    ${status} ${file}"
        done
    fi

    # Show unknown files
    if [[ $unknown_count -gt 0 ]]; then
        echo ""
        echo "  Other files:"
        echo "$changes_json" | jq -r '.unknown[]' | while read -r file; do
            local status
            status=$(git status --porcelain "$file" 2>/dev/null | cut -c1-2)
            echo "    ${status} ${file}"
        done
    fi

    # Store for fix phase
    _DOCTOR_CHANGES_JSON="$changes_json"

    return $issues
}

# Doctor helper: check task state
_doctor_check_tasks() {
    local issues=0
    echo ""
    echo "Task State:"

    local backend
    backend=$(get_backend "${PROJECT_DIR}" 2>/dev/null)

    if [[ -z "$backend" ]]; then
        _doctor_info "No task backend configured"
        return 0
    fi

    local prd="${PROJECT_DIR}/prd.json"

    # Check for tasks stuck in in_progress
    local in_progress_task
    in_progress_task=$(get_in_progress_task "$prd" 2>/dev/null)

    if [[ -n "$in_progress_task" && "$in_progress_task" != "null" ]]; then
        local task_id task_title
        task_id=$(echo "$in_progress_task" | jq -r '.id')
        task_title=$(echo "$in_progress_task" | jq -r '.title')

        _doctor_warn "Task stuck in 'in_progress': ${task_id}"
        echo "      Title: ${task_title}"
        echo "      Consider: curb agent-close ${task_id} (if complete)"
        echo "      Or reset to open status"
        ((issues++))
    else
        _doctor_ok "No tasks stuck in 'in_progress'"
    fi

    # Show task summary
    local counts
    counts=$(get_task_counts "$prd" 2>/dev/null)
    if [[ -n "$counts" ]]; then
        local total open closed
        total=$(echo "$counts" | jq '.total // 0')
        open=$(echo "$counts" | jq '.open // 0')
        closed=$(echo "$counts" | jq '.closed // 0')
        _doctor_info "Tasks: ${closed}/${total} closed, ${open} open"
    fi

    return $issues
}

# Doctor helper: apply fixes
_doctor_fix() {
    local dry_run="${1:-false}"
    local fixed=0

    echo ""
    if [[ "$dry_run" == "true" ]]; then
        echo "Dry run - showing what would be fixed:"
    else
        echo "Applying fixes:"
    fi

    # Fix session files
    if [[ -n "${_DOCTOR_CHANGES_JSON:-}" ]]; then
        local session_files
        session_files=$(echo "$_DOCTOR_CHANGES_JSON" | jq -r '.session[]' 2>/dev/null)

        if [[ -n "$session_files" ]]; then
            if [[ "$dry_run" == "true" ]]; then
                echo "  Would commit session files:"
                echo "$session_files" | while read -r file; do
                    echo "    - $file"
                done
            else
                echo "  Committing session files..."
                echo "$session_files" | while read -r file; do
                    git add "$file" 2>/dev/null
                done
                if git commit -m "chore: commit session files from previous run

Auto-committed by 'curb doctor --fix'" >/dev/null 2>&1; then
                    log_success "  Session files committed"
                    ((fixed++))
                else
                    _doctor_info "  No session files to commit (already clean)"
                fi
            fi
        fi

        # Suggest cruft cleanup
        local cruft_files
        cruft_files=$(echo "$_DOCTOR_CHANGES_JSON" | jq -r '.cruft[]' 2>/dev/null)

        if [[ -n "$cruft_files" ]]; then
            echo ""
            echo "  Cruft files detected. Consider:"
            echo "    - Adding patterns to .gitignore"
            echo "    - Running: git clean -fd (to remove untracked)"
            echo "  Files:"
            echo "$cruft_files" | while read -r file; do
                echo "    - $file"
            done
        fi

        # Note about source files
        local source_files
        source_files=$(echo "$_DOCTOR_CHANGES_JSON" | jq -r '.source[]' 2>/dev/null)

        if [[ -n "$source_files" ]]; then
            echo ""
            echo "  Source files need manual review:"
            echo "$source_files" | while read -r file; do
                echo "    - $file"
            done
            echo "  If these are leftover from a previous run, commit them:"
            echo "    git add -A && git commit -m 'chore: commit leftover changes'"
        fi
    fi

    return $fixed
}

# Doctor subcommand - diagnose and fix issues
cmd_doctor() {
    # Check for --help first
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cmd_doctor_help
        return 0
    fi

    local verbose=false
    local fix=false
    local dry_run=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                verbose=true
                shift
                ;;
            --fix)
                fix=true
                shift
                ;;
            --dry-run)
                dry_run=true
                fix=true  # dry-run implies showing fixes
                shift
                ;;
            *)
                _log_error_console "Unknown flag: $1"
                _log_error_console "Run 'curb doctor --help' for usage"
                return 1
                ;;
        esac
    done

    echo ""
    echo "curb doctor - Diagnostic Report"
    echo "================================"

    local total_issues=0

    # Run all checks
    _doctor_check_env
    ((total_issues += $?))

    _doctor_check_project
    ((total_issues += $?))

    _doctor_check_git "$verbose"
    ((total_issues += $?))

    _doctor_check_tasks
    ((total_issues += $?))

    # Apply fixes if requested
    if [[ "$fix" == "true" ]]; then
        _doctor_fix "$dry_run"
    fi

    # Summary
    echo ""
    echo "================================"
    if [[ $total_issues -eq 0 ]]; then
        log_success "All checks passed!"
    else
        _doctor_warn "${total_issues} issue(s) detected"
        if [[ "$fix" != "true" ]]; then
            echo ""
            echo "Run 'curb doctor --fix' to auto-fix some issues"
            echo "Run 'curb doctor --dry-run' to preview fixes"
        fi
    fi

    return 0
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Debug mode (set via --debug flag)
DEBUG="${CURB_DEBUG:-false}"
# Stream mode (set via --stream flag)
STREAM="${CURB_STREAM:-false}"
# Backend mode (set via --backend flag or CURB_BACKEND env)
# Values: "auto", "beads", "json"
BACKEND="${CURB_BACKEND:-auto}"
# Harness (set via --harness flag, HARNESS env, or config file)
# Values: "auto", "claude", "codex", "opencode", "gemini"
# Priority: CLI flag > env var > config harness.priority > default (claude > opencode > codex > gemini)
HARNESS="${HARNESS:-$(config_get_or "harness.default" "auto")}"
# Model (set via --model flag or CURB_MODEL env)
# Values: "opus", "sonnet", "haiku" (only applies to claude harness)
MODEL="${CURB_MODEL:-}"
# Epic filter (set via --epic flag or CURB_EPIC env)
EPIC="${CURB_EPIC:-}"
# Label filter (set via --label flag or CURB_LABEL env)
LABEL="${CURB_LABEL:-}"
# Budget (set via --budget flag, CURB_BUDGET env, or config file)
BUDGET="${CURB_BUDGET:-}"
# Require clean state (set via --require-clean flag or config)
# Empty means use config default, "true"/"false" overrides config
REQUIRE_CLEAN="${CURB_REQUIRE_CLEAN:-}"
# Session name (set via --name flag or CURB_SESSION_NAME env)
SESSION_NAME="${CURB_SESSION_NAME:-}"
# Push flag (set via --push flag)
# Values: "true" or "false"
PUSH="${CURB_PUSH:-false}"

log_info() { echo -e "${BLUE}[curb]${NC} $1"; }
log_success() { echo -e "${GREEN}[curb]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[curb]${NC} $1"; }
_log_error_console() { echo -e "${RED}[curb]${NC} $1" >&2; }
log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${DIM}${CYAN}[debug]${NC}${DIM} $1${NC}" >&2
    fi
}

# Deprecation warning helper
warn_deprecated_flag() {
    local old_flag="$1"
    local new_syntax="$2"

    # Check if deprecation warnings are suppressed
    if [[ "${CURB_NO_DEPRECATION_WARNINGS:-}" == "1" ]]; then
        return 0
    fi

    echo -e "${YELLOW}[curb]${NC} Warning: ${old_flag} is deprecated, use: ${new_syntax}" >&2
}

# Check dependencies
check_deps() {
    local missing=()
    command -v jq >/dev/null 2>&1 || missing+=("jq")

    # Check for at least one harness
    if ! harness_available; then
        missing+=("harness (claude or codex)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        _log_error_console "Missing dependencies: ${missing[*]}"
        exit 1
    fi

    # Log which harness is active
    local current_harness
    current_harness=$(harness_get)
    log_debug "Harness: ${current_harness}"

    # Log harness capabilities in debug mode
    if [[ "$DEBUG" == "true" ]]; then
        log_debug "Harness capabilities:"
        if harness_supports "streaming"; then
            log_debug "  - streaming: yes"
        else
            log_debug "  - streaming: no (will use non-streaming mode)"
        fi
        if harness_supports "token_reporting"; then
            log_debug "  - token_reporting: yes"
        else
            log_debug "  - token_reporting: no (will estimate from cost)"
        fi
        if harness_supports "system_prompt"; then
            log_debug "  - system_prompt: yes"
        else
            log_debug "  - system_prompt: no (will combine prompts)"
        fi
        if harness_supports "auto_mode"; then
            log_debug "  - auto_mode: yes"
        else
            log_debug "  - auto_mode: no (may require manual approval)"
        fi
    fi
}

# Validate project structure
validate_project() {
    log_debug "Validating project structure in ${PROJECT_DIR}"

    # Detect and initialize task backend
    # Note: tasks.sh is already sourced at top of script, defining _TASK_BACKEND global
    # detect_backend echoes the result AND sets _TASK_BACKEND, but command substitution
    # runs in subshell, so we explicitly set the global after getting the value
    local detected_backend
    detected_backend=$(detect_backend "${PROJECT_DIR}")
    _TASK_BACKEND="$detected_backend"  # Explicitly set global to persist across function calls
    log_debug "Task backend: ${detected_backend}"

    if [[ "$detected_backend" == "beads" ]]; then
        log_info "Using beads backend"
        # Beads doesn't need prd.json
    else
        log_info "Using JSON backend (prd.json)"
        if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
            _log_error_console "No prd.json found in ${PROJECT_DIR}"
            log_info "Run 'curb-init' to scaffold a new project"
            exit 1
        fi
        log_debug "Found prd.json ($(wc -c < "${PROJECT_DIR}/prd.json") bytes)"
    fi

    if [[ ! -f "${PROJECT_DIR}/PROMPT.md" ]]; then
        log_warn "No PROMPT.md found, using default template"
        cp "${CURB_DIR}/templates/PROMPT.md" "${PROJECT_DIR}/PROMPT.md"
    fi
    log_debug "Found PROMPT.md ($(wc -l < "${PROJECT_DIR}/PROMPT.md") lines)"

    if [[ ! -f "${PROJECT_DIR}/AGENT.md" ]]; then
        log_warn "No AGENT.md found, using default template"
        cp "${CURB_DIR}/templates/AGENT.md" "${PROJECT_DIR}/AGENT.md"
    fi
    log_debug "Found AGENT.md ($(wc -l < "${PROJECT_DIR}/AGENT.md") lines)"
    log_debug "Project validation complete"
}

# Show task status summary
show_status() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    echo ""
    log_info "Task Status Summary"
    echo "===================="

    local counts
    counts=$(get_task_counts "$prd")
    local total=$(echo "$counts" | jq -r '.total')
    local closed=$(echo "$counts" | jq -r '.closed')
    local in_progress=$(echo "$counts" | jq -r '.in_progress')
    local open=$(echo "$counts" | jq -r '.open')

    echo -e "Total:       ${total}"
    echo -e "Closed:      ${GREEN}${closed}${NC}"
    echo -e "In Progress: ${YELLOW}${in_progress}${NC}"
    echo -e "Open:        ${open}"
    echo ""

    # Progress bar
    if [[ "$total" -gt 0 ]]; then
        local pct=$((closed * 100 / total))
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        printf "Progress: ["
        printf "%0.s#" $(seq 1 $filled 2>/dev/null) || true
        printf "%0.s-" $(seq 1 $empty 2>/dev/null) || true
        printf "] %d%%\n" "$pct"
    fi

    # Show current session if running
    if session_is_initialized; then
        local session_name
        session_name=$(session_get_name 2>/dev/null || echo "unknown")
        local session_id
        session_id=$(session_get_id 2>/dev/null || echo "unknown")
        echo ""
        log_info "Current Session"
        echo "===================="
        echo "Name: ${session_name}"
        echo "ID:   ${session_id}"
    fi

    # Show most recent run
    local artifacts_base="${PROJECT_DIR}/.curb/runs"
    if [[ -d "$artifacts_base" ]]; then
        local most_recent_run
        most_recent_run=$(ls -t "$artifacts_base" 2>/dev/null | head -n 1)
        if [[ -n "$most_recent_run" ]]; then
            echo ""
            log_info "Most Recent Run"
            echo "===================="
            echo "Run ID: ${most_recent_run}"
            if [[ -f "$artifacts_base/$most_recent_run/run.json" ]]; then
                local started_at
                started_at=$(jq -r '.started_at // "unknown"' "$artifacts_base/$most_recent_run/run.json" 2>/dev/null || echo "unknown")
                local status
                status=$(jq -r '.status // "unknown"' "$artifacts_base/$most_recent_run/run.json" 2>/dev/null || echo "unknown")
                echo "Started: ${started_at}"
                echo "Status:  ${status}"
                echo "Path:    ${artifacts_base}/${most_recent_run}"
            fi
        fi
    fi
}

# Show status in JSON format
show_status_json() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    local counts
    counts=$(get_task_counts "$prd")

    # Build JSON output
    local session_name="null"
    local session_id="null"
    if session_is_initialized; then
        session_name="\"$(session_get_name 2>/dev/null || echo "unknown")\""
        session_id="\"$(session_get_id 2>/dev/null || echo "unknown")\""
    fi

    local most_recent_run="null"
    local artifacts_base="${PROJECT_DIR}/.curb/runs"
    if [[ -d "$artifacts_base" ]]; then
        local run_dir
        run_dir=$(ls -t "$artifacts_base" 2>/dev/null | head -n 1)
        if [[ -n "$run_dir" ]]; then
            local started_at="unknown"
            local status="unknown"
            local run_path="${artifacts_base}/${run_dir}"
            if [[ -f "$run_path/run.json" ]]; then
                started_at=$(jq -r '.started_at // "unknown"' "$run_path/run.json" 2>/dev/null || echo "unknown")
                status=$(jq -r '.status // "unknown"' "$run_path/run.json" 2>/dev/null || echo "unknown")
            fi
            most_recent_run=$(jq -n \
                --arg id "$run_dir" \
                --arg started "$started_at" \
                --arg status "$status" \
                --arg path "$run_path" \
                '{id: $id, started_at: $started, status: $status, path: $path}')
        fi
    fi

    # Output JSON
    jq -n \
        --argjson counts "$counts" \
        --argjson session_name "$session_name" \
        --argjson session_id "$session_id" \
        --argjson most_recent_run "$most_recent_run" \
        '{
            task_counts: $counts,
            current_session: (if $session_name != null then {name: $session_name, id: $session_id} else null end),
            most_recent_run: $most_recent_run
        }'
}

# Show ready tasks
show_ready() {
    local prd="${PROJECT_DIR}/prd.json"
    local backend=$(get_backend "${PROJECT_DIR}")

    # Validate JSON before processing (only for json backend)
    if [[ "$backend" == "json" ]]; then
        if ! jq empty "$prd" 2>/dev/null; then
            _log_error_console "Invalid JSON in prd.json"
            return 1
        fi
    fi

    log_info "Ready Tasks (unblocked, status=open)"
    if [[ -n "$EPIC" ]]; then
        log_info "  Epic filter: $EPIC"
    fi
    if [[ -n "$LABEL" ]]; then
        log_info "  Label filter: $LABEL"
    fi
    echo "======================================"

    local ready=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")

    if [[ -z "$ready" || "$ready" == "null" || "$ready" == "[]" ]]; then
        log_warn "No ready tasks found"
        return
    fi

    echo "$ready" | jq -r '.[] | "[\(.priority)] \(.id): \(.title)"'
}

# Generate the system prompt (static instructions from PROMPT.md)
generate_system_prompt() {
    cat "${PROJECT_DIR}/PROMPT.md"
}

# Generate the task prompt (just the current task details - kept short for stdin)
generate_task_prompt() {
    local task_json="$1"

    # Extract task details
    local task_id=$(echo "$task_json" | jq -r '.id')
    local task_title=$(echo "$task_json" | jq -r '.title')
    local task_type=$(echo "$task_json" | jq -r '.type')
    local task_desc=$(echo "$task_json" | jq -r '.description')
    local task_criteria=$(echo "$task_json" | jq -r '.acceptanceCriteria // [] | join("\n- ")')

    # Parse acceptance criteria from description (markdown checkboxes)
    local desc_criteria=""
    desc_criteria=$(parse_acceptance_criteria "$task_desc" 2>/dev/null || true)

    # Check for failure context (for retry mode)
    local failure_context=""
    failure_context=$(failure_get_context "$task_id" 2>/dev/null)

    # Generate focused task prompt (minimal - just the task)
    cat <<EOF
## CURRENT TASK

Task ID: ${task_id}
Type: ${task_type}
Title: ${task_title}

Description:
${task_desc}
EOF

    # Include acceptance criteria section
    # Prioritize explicit acceptanceCriteria array, but also include parsed checkboxes
    if [[ -n "$task_criteria" && "$task_criteria" != "-" ]]; then
        cat <<EOF

Acceptance Criteria:
- ${task_criteria}
EOF
    elif [[ -n "$desc_criteria" ]]; then
        cat <<EOF

Acceptance Criteria (from description checkboxes):
EOF
        echo "$desc_criteria" | while IFS= read -r criterion; do
            echo "- $criterion"
        done
    fi

    # Add failure context if this is a retry
    if [[ -n "$failure_context" ]]; then
        cat <<EOF

## RETRY CONTEXT

${failure_context}
EOF
    fi

    # Add completion instructions (backend-aware)
    local backend=$(get_backend)
    if [[ "$backend" == "beads" ]]; then
        cat <<EOF

When complete:
1. Run feedback loops (typecheck, test, lint)
2. Mark task complete: bd close ${task_id}
3. Commit: ${task_type}(${task_id}): ${task_title}
4. Append learnings to progress.txt

Note: This project uses the beads task backend. Use 'bd' commands for task management:
- bd close ${task_id}  - Mark this task complete
- bd show ${task_id}   - Check task status
- bd list              - See all tasks
EOF
    else
        cat <<EOF

When complete:
1. Run feedback loops (typecheck, test, lint)
2. Update prd.json: set status to "closed" for ${task_id}
3. Commit: ${task_type}(${task_id}): ${task_title}
4. Append learnings to progress.txt
EOF
    fi
}

# Run a single iteration
run_iteration() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting iteration"

    # Check run iteration limit before starting task
    if ! budget_check_run_iterations; then
        local current=$(budget_get_run_iterations)
        local max=$(budget_get_max_run_iterations)
        log_warn "Run iteration limit exceeded (${current}/${max})"
        log_info "Stopping run due to iteration limit"
        return 1
    fi

    # Initialize session if not already initialized
    if ! session_is_initialized; then
        log_debug "Initializing session..."
        if [[ -n "$SESSION_NAME" ]]; then
            session_init --name "$SESSION_NAME"
        else
            session_init
        fi

        if [[ $? -ne 0 ]]; then
            log_warn "Failed to initialize session"
        else
            local session_name
            session_name=$(session_get_name)
            local session_id
            session_id=$(session_get_id)
            log_debug "Session: ${session_name} (${session_id})"
        fi
    fi

    # Initialize logger if not already initialized
    if [[ -z "$(logger_get_file)" ]]; then
        local project_name
        project_name=$(basename "$PROJECT_DIR")
        local session_id
        session_id=$(session_get_id)

        if logger_init "$project_name" "$session_id"; then
            log_debug "Logger initialized: $(logger_get_file)"
        else
            log_warn "Failed to initialize logger"
        fi
    fi

    # Initialize artifacts for this run if not already initialized
    if session_is_initialized; then
        local run_dir
        run_dir=$(artifacts_get_run_dir 2>/dev/null)
        if [[ -n "$run_dir" ]] && [[ ! -f "${run_dir}/run.json" ]]; then
            log_debug "Initializing artifacts..."
            if artifacts_init_run; then
                local artifacts_path
                artifacts_path=$(artifacts_get_run_dir)
                log_debug "Artifacts initialized: ${artifacts_path}"
            else
                log_warn "Failed to initialize artifacts"
            fi
        fi
    fi

    # Initialize git run branch if in a git repository (only if not already initialized)
    if git_in_repo; then
        local current_branch
        current_branch=$(git_get_run_branch 2>/dev/null)
        if [[ -z "$current_branch" ]]; then
            log_debug "Initializing git run branch..."
            local session_name
            session_name=$(session_get_name)
            if git_init_run_branch "$session_name"; then
                local branch_name
                branch_name=$(git_get_run_branch)
                log_info "Git branch: ${branch_name}"
            else
                log_warn "Failed to initialize git run branch"
            fi
        fi
    else
        log_debug "Not in a git repository, skipping git operations"
    fi

    # Check for in-progress tasks first (resume interrupted work)
    # Respects --epic and --label filters
    local current_task
    log_debug "Checking for in-progress tasks..."
    current_task=$(get_in_progress_task "$prd" "$EPIC" "$LABEL")
    log_debug "In-progress query result: ${current_task:0:100}..."

    if [[ -n "$current_task" && "$current_task" != "null" ]]; then
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')

        # Verify the in-progress task is not blocked
        if is_task_ready "$prd" "$task_id"; then
            log_warn "Resuming in-progress task: ${task_id}"
            log_info "  ${task_type}: ${task_title}"
            log_debug "Task JSON: $current_task"
        else
            log_warn "In-progress task ${task_id} is blocked, resetting to open"
            update_task_status "$prd" "$task_id" "open"
            current_task=""
        fi
    fi

    # Find next ready task if no valid in-progress task
    if [[ -z "$current_task" || "$current_task" == "null" ]]; then
        # Find next ready task
        log_debug "No in-progress tasks, finding ready tasks..."
        log_debug "Current _TASK_BACKEND: ${_TASK_BACKEND}"
        local ready_tasks
        ready_tasks=$(get_ready_tasks "$prd" "$EPIC" "$LABEL")
        log_debug "Ready tasks result: ${ready_tasks:0:200}..."

        if [[ -z "$ready_tasks" || "$ready_tasks" == "[]" ]]; then
            # Check if we're done
            local open_count=$(get_remaining_count "$prd")
            log_debug "Open task count: ${open_count}"
            if [[ "$open_count" -eq 0 ]]; then
                log_success "All tasks complete!"
                return 0
            else
                _log_error_console "No ready tasks but ${open_count} tasks not closed. Check dependencies."
                return 1
            fi
        fi

        # Pick highest priority ready task
        current_task=$(echo "$ready_tasks" | jq 'first')
        local task_id=$(echo "$current_task" | jq -r '.id')
        local task_title=$(echo "$current_task" | jq -r '.title')
        local task_type=$(echo "$current_task" | jq -r '.type')
        local task_priority=$(echo "$current_task" | jq -r '.priority')

        log_info "Selected task: ${task_id} [${task_priority}]"
        log_info "  ${task_type}: ${task_title}"
        log_debug "Task JSON: $current_task"

        # Mark as in_progress (with assignee for beads backend)
        log_debug "Claiming task..."
        local session_name
        session_name=$(session_get_name)
        claim_task "$prd" "$task_id" "$session_name"
        log_debug "Task claimed"
    fi

    # Check for model: label and set CURB_MODEL if harness is claude
    local harness=$(harness_get)
    if [[ "$harness" == "claude" ]]; then
        local task_model
        task_model=$(echo "$current_task" | jq -r '.labels // [] | .[] | select(startswith("model:")) | split(":")[1]' 2>/dev/null | head -1)
        if [[ -n "$task_model" ]]; then
            log_info "  Model from label: ${task_model}"
            export CURB_MODEL="$task_model"
        fi
    fi

    # Generate prompts
    log_debug "Generating prompts..."
    local system_prompt
    system_prompt=$(generate_system_prompt)
    local task_prompt
    task_prompt=$(generate_task_prompt "$current_task")

    local sys_bytes=$(echo "$system_prompt" | wc -c)
    local task_bytes=$(echo "$task_prompt" | wc -c)
    log_debug "System prompt: ${sys_bytes} bytes (via --append-system-prompt)"
    log_debug "Task prompt: ${task_bytes} bytes (via stdin)"

    # Show prompts in debug mode
    if [[ "$DEBUG" == "true" ]]; then
        echo ""
        log_debug "=== SYSTEM PROMPT ==="
        echo -e "${DIM}$system_prompt${NC}" >&2
        log_debug "=== TASK PROMPT ==="
        echo -e "${DIM}$task_prompt${NC}" >&2
        log_debug "===================="
        echo ""
    fi

    log_info "Running ${harness}..."
    echo ""

    if [[ "$DEBUG" == "true" ]]; then
        # Pre-flight check
        log_debug "Pre-flight: ${harness} version"
        local version_output
        version_output=$(harness_version 2>&1) && log_debug "Version: ${version_output}" || log_debug "WARNING: version check failed"
        log_debug "Binary: $(which ${harness})"
    fi

    # Extract task details for logging
    local task_id=$(echo "$current_task" | jq -r '.id')
    local task_title=$(echo "$current_task" | jq -r '.title')
    local task_priority=$(echo "$current_task" | jq -r '.priority // "normal"')

    # Check task iteration limit before attempting task
    if ! budget_check_task_iterations "$task_id"; then
        local current=$(budget_get_task_iterations "$task_id")
        local max=$(budget_get_max_task_iterations)
        log_warn "Task ${task_id} iteration limit exceeded (${current}/${max})"
        log_info "Marking task as failed and moving on"
        update_task_status "$prd" "$task_id" "failed"
        return 1
    fi

    # Start task artifacts
    if session_is_initialized; then
        log_debug "Starting task artifacts for ${task_id}..."
        if artifacts_start_task "$task_id" "$task_title" "$task_priority"; then
            local artifacts_path
            artifacts_path=$(artifacts_get_path "$task_id")
            log_debug "Task artifacts: ${artifacts_path}"
        else
            log_warn "Failed to start task artifacts"
        fi
    fi

    # Log acceptance criteria for this task
    if [[ "$DEBUG" == "true" ]]; then
        verify_acceptance_criteria "$task_id" "$prd" 2>/dev/null | while IFS= read -r line; do
            log_debug "$line"
        done
    fi

    # Increment task iteration counter
    budget_increment_task_iterations "$task_id"
    local task_iteration=$(budget_get_task_iterations "$task_id")
    local max_task=$(budget_get_max_task_iterations)
    local run_iteration=$(budget_get_run_iterations)
    local max_run=$(budget_get_max_run_iterations)
    log_info "Task ${task_id} iteration ${task_iteration}/${max_task} (run ${run_iteration}/${max_run})"

    # Log task start
    log_task_start "$task_id" "$task_title" "$harness"

    # Run pre-task hooks
    log_debug "Running pre-task hooks..."
    hooks_set_task_context "$task_id" "$task_title"
    hooks_run "pre-task"
    log_debug "Pre-task hooks complete"

    # Run harness with the prompt via abstraction layer
    local start_time=$(date +%s)
    local exit_code=0
    log_debug "Execution start: $(date)"

    if [[ "$DEBUG" == "true" ]]; then
        # Save prompts to temp files for manual testing
        local tmp_sys=$(mktemp)
        local tmp_task=$(mktemp)
        echo "$system_prompt" > "$tmp_sys"
        echo "$task_prompt" > "$tmp_task"
        log_debug "System prompt: ${tmp_sys}"
        log_debug "Task prompt: ${tmp_task}"
        log_debug ">>> Prompts saved for debugging"
        log_debug ""
        log_debug "--- HARNESS START (${harness}) ---"
    fi

    # Set up harness output logging to artifacts
    local harness_log_file="${TMPDIR:-/tmp}/curb_harness_log_$$"
    export CURB_HARNESS_LOG="$harness_log_file"

    # Invoke harness via abstraction layer
    if [[ "$STREAM" == "true" ]]; then
        log_info "Streaming ${harness} output..."
        harness_invoke_streaming "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    else
        harness_invoke "$system_prompt" "$task_prompt" "$DEBUG"
        exit_code=$?
    fi

    # Capture harness output to artifacts
    if session_is_initialized && [[ -f "$harness_log_file" ]]; then
        log_debug "Capturing harness output to artifacts..."
        if artifacts_capture_harness_output "$task_id" "$harness_log_file" "$task_iteration"; then
            log_debug "Harness output captured"
        else
            log_warn "Failed to capture harness output"
        fi
        rm -f "$harness_log_file"
    fi
    unset CURB_HARNESS_LOG

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "--- HARNESS END (${harness}) ---"

        # Cleanup on success, keep on failure
        if [[ $exit_code -eq 0 ]]; then
            rm -f "$tmp_sys" "$tmp_task"
        else
            log_debug "Keeping prompt files for debugging"
            log_debug "  System: ${tmp_sys}"
            log_debug "  Task: ${tmp_task}"
        fi
    fi

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    log_debug "Execution end: $(date)"
    log_debug "Duration: ${duration} seconds"
    log_debug "Exit code: ${exit_code}"

    # Extract token usage from harness
    local tokens_used=0
    tokens_used=$(harness_get_total_tokens)
    log_debug "Tokens used: ${tokens_used}"

    # Record token usage in budget if budget is initialized
    local budget_remaining=""
    local budget_total=""
    if [[ -f "${TMPDIR:-/tmp}/curb_budget_limit_$$" ]]; then
        log_debug "Recording ${tokens_used} tokens to budget"
        budget_record "$tokens_used"
        budget_remaining=$(budget_remaining)
        budget_total=$(budget_get_limit)
        log_debug "Budget: ${budget_remaining} remaining of ${budget_total}"

        # Check if warning threshold has been crossed
        local warn_at
        warn_at=$(config_get_or "budget.warn_at" "80")
        if budget_check_warning "$warn_at"; then
            : # No warning triggered
        else
            # Warning was just triggered - log it once
            if [[ "$budget_total" -gt 0 ]]; then
                local used=$(budget_get_used)
                local percentage=$((used * 100 / budget_total))
                log_warn "Budget warning: approaching limit (${percentage}% used, ${budget_remaining} tokens remaining)"
            fi
        fi
    fi

    # Log task end with budget information
    if [[ -n "$budget_remaining" && -n "$budget_total" ]]; then
        log_task_end "$task_id" "$exit_code" "$duration" "$tokens_used" "$budget_remaining" "$budget_total"
    else
        log_task_end "$task_id" "$exit_code" "$duration" "$tokens_used"
    fi

    if [[ $exit_code -ne 0 ]]; then
        log_warn "Claude Code exited with code ${exit_code}"
        log_debug "Non-zero exit may indicate: timeout, error, or user interrupt"
        # Log error to structured logger
        log_error "Harness exited with non-zero code" "{\"task_id\": \"$task_id\", \"exit_code\": $exit_code, \"harness\": \"$harness\"}"

        # Run on-error hooks
        log_debug "Running on-error hooks..."
        hooks_set_task_context "$task_id" "$task_title" "$exit_code"
        hooks_run "on-error"
        log_debug "On-error hooks complete"
    else
        log_debug "Claude Code completed successfully"

        # Auto-commit session files (progress.txt, fix_plan.md) if modified
        # This handles cases where the agent modifies these files but forgets to commit
        if git_in_repo; then
            log_debug "Checking for uncommitted session files..."
            if git_commit_session_files "$task_id"; then
                log_debug "Session files committed (if any)"
            else
                log_warn "Failed to commit session files"
            fi

            # Auto-commit remaining changes if configured (default: true)
            # This handles cases where the agent completes work but forgets to commit
            local auto_commit
            auto_commit=$(config_get_or "clean_state.auto_commit" "true")
            if [[ "$auto_commit" == "true" ]]; then
                log_debug "Checking for uncommitted changes to auto-commit..."
                if git_commit_remaining_changes "$task_id" "$task_title"; then
                    log_debug "Remaining changes committed (if any)"
                else
                    log_warn "Failed to auto-commit remaining changes"
                fi
            fi
        fi

        # Verify clean state after successful harness run
        log_debug "Checking repository state..."
        if ! state_ensure_clean "$REQUIRE_CLEAN"; then
            log_warn "State check failed: uncommitted changes detected"
            exit_code=1
        else
            log_debug "Repository state is clean"
        fi

        # Run tests if configured
        if [[ $exit_code -eq 0 ]]; then
            log_debug "Running tests if configured..."
            if ! state_run_tests; then
                log_warn "Test run failed"
                exit_code=1
            else
                log_debug "Tests passed or not required"
            fi
        fi

        # Auto-close task if configured and all checks passed
        # This is a safety net for when the agent forgets to close the task
        if [[ $exit_code -eq 0 ]]; then
            local auto_close
            auto_close=$(config_get_or "task.auto_close" "true")
            if [[ "$auto_close" == "true" ]]; then
                log_debug "Checking if task needs auto-closing..."
                if ! verify_task_closed "$prd" "$task_id" 2>/dev/null; then
                    log_info "Auto-closing task $task_id (agent did not close it)..."
                    if auto_close_task "$prd" "$task_id"; then
                        log_success "Task $task_id auto-closed successfully"
                    else
                        log_warn "Failed to auto-close task $task_id"
                    fi
                else
                    log_debug "Task $task_id already closed by agent"
                fi
            fi
        fi
    fi

    # Handle task failure if exit_code is non-zero
    if [[ $exit_code -ne 0 ]]; then
        log_debug "Task failed with exit code ${exit_code}, invoking failure handler..."

        # Get failure mode from config
        local failure_mode
        failure_mode=$(failure_get_mode)
        log_debug "Failure mode: ${failure_mode}"

        # Collect harness output for failure context (if available)
        local harness_output=""
        # Note: harness output is not captured in current implementation
        # Future enhancement: capture last N lines of harness output

        # Call appropriate failure handler based on mode
        local failure_result=0
        case "$failure_mode" in
            stop)
                failure_handle_stop "$task_id" "$exit_code" "$harness_output"
                failure_result=$?
                ;;
            move-on)
                failure_handle_move_on "$task_id" "$exit_code" "$harness_output"
                failure_result=$?
                ;;
            retry)
                failure_handle_retry "$task_id" "$exit_code" "$harness_output"
                failure_result=$?
                ;;
            triage)
                log_warn "Triage mode not yet implemented, falling back to move-on"
                failure_handle_move_on "$task_id" "$exit_code" "$harness_output"
                failure_result=$?
                ;;
            *)
                log_warn "Unknown failure mode '${failure_mode}', falling back to move-on"
                failure_handle_move_on "$task_id" "$exit_code" "$harness_output"
                failure_result=$?
                ;;
        esac

        log_debug "Failure handler returned: ${failure_result}"

        # Check failure handler result
        # Return codes: 0=continue, 2=halt, 3=retry
        if [[ $failure_result -eq 2 ]]; then
            # Stop mode - halt the run
            log_info "Failure handler requested run halt"
            # Run post-task hooks before halting
            log_debug "Running post-task hooks..."
            hooks_set_task_context "$task_id" "$task_title" "$exit_code"
            hooks_run "post-task"
            log_debug "Post-task hooks complete"
            # Return special code to signal halt to main loop
            return 2
        elif [[ $failure_result -eq 3 ]]; then
            # Retry mode - retry the task
            log_info "Failure handler requested task retry"
            # Run post-task hooks
            log_debug "Running post-task hooks..."
            hooks_set_task_context "$task_id" "$task_title" "$exit_code"
            hooks_run "post-task"
            log_debug "Post-task hooks complete"
            # Return special code to signal retry to main loop
            return 3
        fi
        # Otherwise fall through to normal post-task flow (move-on)
    fi

    # Run post-task hooks (always run, regardless of success/failure)
    log_debug "Running post-task hooks..."
    hooks_set_task_context "$task_id" "$task_title" "$exit_code"
    hooks_run "post-task"
    log_debug "Post-task hooks complete"

    # Capture artifacts after task completion
    if session_is_initialized; then
        log_debug "Capturing task artifacts..."

        # Capture git diff
        if artifacts_capture_diff "$task_id"; then
            log_debug "Captured git diff to changes.patch"
        else
            log_warn "Failed to capture git diff"
        fi

        # Finalize task with status and summary
        local task_status
        if [[ $exit_code -eq 0 ]]; then
            task_status="completed"
        else
            task_status="failed"
        fi

        # Get iteration counts for summary
        local task_iter=$(budget_get_task_iterations "$task_id")
        local max_task_iter=$(budget_get_max_task_iterations)
        local run_iter=$(budget_get_run_iterations)
        local max_run_iter=$(budget_get_max_run_iterations)

        local summary_text="Task execution completed with exit code ${exit_code}. Duration: ${duration}s. Tokens used: ${tokens_used}. Task iteration: ${task_iter}/${max_task_iter}. Run iteration: ${run_iter}/${max_run_iter}."
        if artifacts_finalize_task "$task_id" "$task_status" "$exit_code" "$summary_text"; then
            local artifacts_path
            artifacts_path=$(artifacts_get_path "$task_id")
            log_info "Artifacts saved: ${artifacts_path}"
        else
            log_warn "Failed to finalize task artifacts"
        fi
    fi

    # Commit changes if task was successful and we're in a git repository
    if [[ $exit_code -eq 0 ]] && git_in_repo; then
        log_debug "Committing task changes..."
        if git_commit_task "$task_id" "$task_title" "$summary_text"; then
            log_info "Changes committed to git"

            # Push to remote if --push flag was set
            if [[ "$PUSH" == "true" ]]; then
                log_debug "Pushing branch to remote..."
                if git_push_branch; then
                    log_info "Branch pushed to remote"
                else
                    log_warn "Failed to push branch to remote"
                fi
            else
                log_debug "Skipping push (--push flag not set)"
            fi
        else
            log_warn "Failed to commit changes (this is not an error if there were no changes)"
        fi
    fi

    # Increment run iteration counter after completing task
    budget_increment_run_iterations
    local run_iteration=$(budget_get_run_iterations)
    local max_run=$(budget_get_max_run_iterations)
    log_debug "Run iteration ${run_iteration}/${max_run} complete"

    # Commit curb artifacts (.beads/ and .curb/) if there are changes
    # These are committed separately after the harness's work is complete
    if git_in_repo; then
        log_debug "Committing curb artifacts if needed..."
        git_commit_curb_artifacts "$task_id"
    fi

    return $exit_code
}

# Run planning mode
run_planning() {
    local prd="${PROJECT_DIR}/prd.json"
    log_debug "Starting planning mode"

    log_info "Running in planning mode..."

    local plan_prompt
    plan_prompt=$(cat <<'EOF'
Study @specs/* for specifications.
Study @prd.json for the current task backlog.
Study the existing source code.

Your task is to analyze the codebase and update @fix_plan.md:

1. Use subagents to study existing source code and compare against specifications
2. Search for TODO comments, placeholder implementations, and missing functionality
3. Create/update fix_plan.md with a prioritized bullet list of items to implement
4. For each item, note:
   - What needs to be done
   - Which files are affected
   - Dependencies on other items
5. If you discover missing specifications, document them

Think hard. Be thorough. Use many parallel subagents for research.
EOF
)

    if [[ "$DEBUG" == "true" ]]; then
        log_debug "Plan prompt: $(echo "$plan_prompt" | wc -l) lines"
        log_debug "=== PLAN PROMPT ==="
        echo -e "${DIM}$plan_prompt${NC}" >&2
        log_debug "==================="
    fi

    local start_time=$(date +%s)
    log_debug "Execution start: $(date)"

    echo "$plan_prompt" | claude -p --dangerously-skip-permissions

    local exit_code=$?
    local end_time=$(date +%s)
    log_debug "Execution end: $(date), duration: $((end_time - start_time))s, exit: ${exit_code}"
}

# Main loop
run_loop() {
    local max_iterations="${CURB_MAX_ITERATIONS:-$(config_get_or "loop.max_iterations" "100")}"
    local iteration=0

    # Initialize session with optional name override
    if [[ -n "$SESSION_NAME" ]]; then
        session_init --name "$SESSION_NAME"
    else
        session_init
    fi

    if [[ $? -ne 0 ]]; then
        log_warn "Failed to initialize session"
    else
        local session_name
        session_name=$(session_get_name)
        local session_id
        session_id=$(session_get_id)
        log_info "Session: ${session_name} (${session_id})"
    fi

    # Initialize logger with project name and session ID
    local project_name
    project_name=$(basename "$PROJECT_DIR")
    local session_id
    session_id=$(session_get_id)

    if logger_init "$project_name" "$session_id"; then
        log_debug "Logger initialized: $(logger_get_file)"
    else
        log_warn "Failed to initialize logger"
    fi

    # Initialize artifacts for this run
    if artifacts_init_run; then
        local artifacts_path
        artifacts_path=$(artifacts_get_run_dir)
        log_debug "Artifacts initialized: ${artifacts_path}"
    else
        log_warn "Failed to initialize artifacts"
    fi

    # Initialize git run branch if in a git repository
    if git_in_repo; then
        log_debug "Initializing git run branch..."
        local session_name
        session_name=$(session_get_name)
        if git_init_run_branch "$session_name"; then
            local branch_name
            branch_name=$(git_get_run_branch)
            log_info "Git branch: ${branch_name}"
        else
            log_warn "Failed to initialize git run branch"
        fi
    else
        log_debug "Not in a git repository, skipping git operations"
    fi

    log_info "Starting curb loop (max ${max_iterations} iterations)"
    log_debug "Max iterations: ${max_iterations}"
    log_debug "Loop starting at: $(date)"
    echo ""

    # Run pre-loop hooks
    log_debug "Running pre-loop hooks..."
    hooks_set_session_context "$session_id" "$(harness_get)"
    hooks_run "pre-loop"
    log_debug "Pre-loop hooks complete"

    while [[ $iteration -lt $max_iterations ]]; do
        iteration=$((iteration + 1))
        log_info "=== Iteration ${iteration} ==="
        log_debug "--- Iteration ${iteration} start: $(date) ---"

        # Check if all tasks complete
        local prd="${PROJECT_DIR}/prd.json"
        log_debug "Querying remaining tasks..."
        local remaining=$(get_remaining_count "$prd")
        log_debug "Remaining tasks: ${remaining}"

        if [[ "$remaining" -eq 0 ]]; then
            log_success "All tasks complete! Exiting loop."
            show_status
            # Run post-loop hooks
            log_debug "Running post-loop hooks..."
            hooks_run "post-loop"
            log_debug "Post-loop hooks complete"
            return 0
        fi

        # Run single iteration
        log_debug "Calling run_iteration..."
        run_iteration
        local iteration_result=$?

        if [[ $iteration_result -eq 2 ]]; then
            # Failure handler requested halt
            log_warn "Failure handler requested run halt"
            show_status
            # Run post-loop hooks
            log_debug "Running post-loop hooks..."
            hooks_run "post-loop"
            log_debug "Post-loop hooks complete"
            return 2
        elif [[ $iteration_result -eq 3 ]]; then
            # Failure handler requested retry
            log_info "Failure handler requested retry - will retry task in next iteration"
            # Don't increment iteration counter for retry
            iteration=$((iteration - 1))
        elif [[ $iteration_result -ne 0 ]]; then
            # Other non-zero exit (normal failure with move-on)
            log_warn "Iteration failed, continuing..."
            log_debug "run_iteration returned ${iteration_result}"
        fi

        echo ""
        log_info "Iteration ${iteration} complete. ${remaining} tasks remaining."
        log_debug "--- Iteration ${iteration} end: $(date) ---"
        echo ""

        # Check budget after iteration if budget is initialized
        if [[ -f "${TMPDIR:-/tmp}/curb_budget_limit_$$" ]]; then
            if ! budget_check; then
                local used=$(budget_get_used)
                local limit=$(budget_get_limit)
                echo ""
                log_success "Budget exceeded (used ${used} of ${limit} tokens)"
                log_info "Stopping gracefully due to budget limit"
                show_status
                # Run post-loop hooks
                log_debug "Running post-loop hooks..."
                hooks_run "post-loop"
                log_debug "Post-loop hooks complete"
                return 0
            fi
        fi

        # Brief pause between iterations to allow for interruption
        log_debug "Sleeping 2 seconds before next iteration..."
        sleep 2
    done

    log_warn "Reached max iterations (${max_iterations})"
    log_debug "Loop terminated at: $(date)"
    show_status
    # Run post-loop hooks
    log_debug "Running post-loop hooks..."
    hooks_run "post-loop"
    log_debug "Post-loop hooks complete"
    return 1
}

# Main entry point
main() {
    # Parse global flags (affect entire system) and separate run-specific flags
    local args=()
    for arg in "$@"; do
        if [[ "$arg" == "--debug" || "$arg" == "-d" ]]; then
            DEBUG="true"
            log_debug "Debug mode enabled"
            log_debug "CURB_DIR=${CURB_DIR}"
            log_debug "PROJECT_DIR=${PROJECT_DIR}"
            log_debug "Shell: $SHELL (bash ${BASH_VERSION})"
            log_debug "Date: $(date)"
        elif [[ "$arg" == "--stream" ]]; then
            STREAM="true"
            log_info "Stream mode enabled - showing harness activity"
        elif [[ "$arg" == "--backend="* ]]; then
            BACKEND="${arg#--backend=}"
            export CURB_BACKEND="$BACKEND"
        elif [[ "$arg" == "--backend" ]]; then
            # Next arg is the backend value - handle in next iteration
            _next_is_backend=true
            continue
        elif [[ "${_next_is_backend:-}" == "true" ]]; then
            BACKEND="$arg"
            export CURB_BACKEND="$BACKEND"
            _next_is_backend=false
        elif [[ "$arg" == "--harness="* ]]; then
            HARNESS="${arg#--harness=}"
            export HARNESS
        elif [[ "$arg" == "--harness" ]]; then
            # Next arg is the harness value - handle in next iteration
            _next_is_harness=true
            continue
        elif [[ "${_next_is_harness:-}" == "true" ]]; then
            HARNESS="$arg"
            export HARNESS
            _next_is_harness=false
        else
            # Pass all other args through (including run-specific flags)
            args+=("$arg")
        fi
    done
    unset _next_is_backend
    unset _next_is_harness

    check_deps
    log_debug "Dependencies checked: jq and harness found"

    # Subcommand dispatcher (check for subcommands before legacy flags)
    # Process first non-flag argument as potential subcommand
    local first_arg="${args[0]:-}"

    # Check if first arg is a subcommand (not a flag)
    if [[ -n "$first_arg" && ! "$first_arg" =~ ^- ]]; then
        case "$first_arg" in
            init)
                # Pass remaining args to cmd_init
                cmd_init "${args[@]:1}"
                return $?
                ;;
            run)
                # Run the main loop with remaining args
                cmd_run "${args[@]:1}"
                return $?
                ;;
            status)
                # Show task status
                cmd_status "${args[@]:1}"
                return $?
                ;;
            explain)
                # Explain a task or session
                cmd_explain "${args[@]:1}"
                return $?
                ;;
            artifacts)
                # Manage artifacts
                cmd_artifacts "${args[@]:1}"
                return $?
                ;;
            agent-close)
                # Close a task (agent helper command)
                cmd_agent_close "${args[@]:1}"
                return $?
                ;;
            agent-verify)
                # Verify a task is closed (agent helper command)
                cmd_agent_verify "${args[@]:1}"
                return $?
                ;;
            doctor)
                # Diagnose and fix common issues
                cmd_doctor "${args[@]:1}"
                return $?
                ;;
            version)
                # Show version
                cmd_version
                return $?
                ;;
            help)
                # Show help (fall through to --help handling below)
                args=("--help")
                ;;
            *)
                # Unknown subcommand - show error and help
                # (only show error for non-flag arguments)
                if [[ ! "$first_arg" =~ ^- ]]; then
                    _log_error_console "Unknown subcommand: ${first_arg}"
                    echo ""
                    args=("--help")
                fi
                ;;
        esac
    fi

    # Legacy flag parsing (for backwards compatibility)
    case "${args[0]:-}" in
        --status|-s)
            warn_deprecated_flag "--status" "curb status"
            cmd_status "${args[@]:1}"
            ;;
        --ready|-r)
            warn_deprecated_flag "--ready" "curb run --ready"
            cmd_run --ready "${args[@]:1}"
            ;;
        --once|-1)
            warn_deprecated_flag "--once" "curb run --once"
            cmd_run --once "${args[@]:1}"
            ;;
        --plan|-p)
            warn_deprecated_flag "--plan" "curb run --plan"
            cmd_run --plan "${args[@]:1}"
            ;;
        --test|-t)
            log_info "Testing Claude Code invocation..."
            log_debug "Binary: $(which claude)"
            log_debug "Version: $(claude --version 2>&1)"
            echo ""
            log_info "Test 1: Simple echo pipe"
            log_debug "Command: echo 'Say hello' | claude -p"
            if echo "Say hello" | claude -p; then
                log_success "Test 1 passed"
            else
                _log_error_console "Test 1 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 2: Heredoc pipe"
            log_debug "Command: claude -p <<< 'Say goodbye'"
            if claude -p <<< "Say goodbye"; then
                log_success "Test 2 passed"
            else
                _log_error_console "Test 2 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 3: Multi-line prompt"
            local test_prompt="You are a helpful assistant.

Say 'curb test successful' and nothing else."
            log_debug "Command: echo \"\$test_prompt\" | claude -p"
            if echo "$test_prompt" | claude -p; then
                log_success "Test 3 passed"
            else
                _log_error_console "Test 3 failed (exit: $?)"
            fi
            echo ""
            log_success "All tests complete"
            ;;
        --migrate-to-beads)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "Migrating from prd.json to beads..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "false"
            ;;
        --migrate-to-beads-dry-run)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "DRY RUN: Showing what would be migrated..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "true"
            ;;
        --dump-prompt)
            validate_project
            local prd="${PROJECT_DIR}/prd.json"
            local current_task
            current_task=$(get_in_progress_task "$prd")
            if [[ -z "$current_task" || "$current_task" == "null" ]]; then
                current_task=$(get_ready_tasks "$prd" | jq 'first')
            fi
            if [[ "$current_task" == "null" || -z "$current_task" ]]; then
                _log_error_console "No tasks available"
                exit 1
            fi
            local sys_file="${PROJECT_DIR}/curb_system_prompt.txt"
            local task_file="${PROJECT_DIR}/curb_task_prompt.txt"
            generate_system_prompt > "$sys_file"
            generate_task_prompt "$current_task" > "$task_file"
            log_success "Prompts dumped:"
            log_info "  System: ${sys_file} ($(wc -c < "$sys_file") bytes)"
            log_info "  Task:   ${task_file} ($(wc -c < "$task_file") bytes)"
            log_info ""
            log_info "To test manually:"
            log_info "  claude -p --append-system-prompt \"\$(cat ${sys_file})\" < ${task_file}"
            ;;
        --help|-h)
            cat <<EOF
curb v${CURB_VERSION} - Claude Under Ralph + Beads

Autonomous AI coding agent that drives harnesses in a loop to complete
tasks from a project backlog.

SUBCOMMANDS:
  curb init [--global] [<dir>]  Initialize project or system
  curb run [<options>]           Run the main loop (default)
  curb status [--json]           Show task progress
  curb explain <task-id>         Show task details
  curb artifacts [<task-id>]     List task outputs
  curb agent-close <task-id>     Close a task (for agent use)
  curb agent-verify <task-id>    Verify task is closed
  curb doctor [--fix]            Diagnose and fix issues
  curb version                   Show version

QUICK START:
  curb init                      Initialize in current directory
  curb run                       Start the main loop
  curb status                    Check progress
  curb run --ready               List tasks to work on

USE --help WITH ANY SUBCOMMAND:
  curb init --help               Init subcommand help
  curb run --help                Run subcommand help
  curb status --help             Status subcommand help
  curb explain --help            Explain subcommand help
  curb artifacts --help          Artifacts subcommand help

EXECUTION MODES:
  curb                           Run continuous loop
  curb run --once                Single iteration then exit
  curb run --ready               List ready tasks
  curb run --plan                Analyze code and plan

CORE FLAGS (work with run):
  --harness <name>               Use specific harness (auto, claude, codex,
                                 gemini, opencode)
  --model <name>                 Claude model (opus, sonnet, haiku)
  --budget <tokens>              Set token budget (e.g., 1000000)
  --name <name>                  Session name for tracking

FILTERING:
  --epic <id>                    Work on tasks in epic
  --label <name>                 Work on tasks with label

RELIABILITY:
  --require-clean                Enforce clean git state
  --no-require-clean             Disable clean state check

DEBUGGING:
  --debug, -d                    Show detailed logs
  --stream                       Stream harness output
  --backend <mode>               Task backend (auto, beads, json)

UTILITY:
  --test                         Test harness invocation
  --dump-prompt                  Export task prompts
  --migrate-to-beads             Convert prd.json to beads
  --migrate-to-beads-dry-run     Preview migration

EXAMPLES:
  curb                           Start main loop
  curb run --once                Single iteration
  curb status                    Show progress
  curb run --ready               List tasks
  curb run --epic backend-v2     Work on epic
  curb run --once --debug        Debug one iteration
  curb run --model sonnet        Use Sonnet model
  curb artifacts curb-018        Get task output
  curb explain curb-018          See task details
  curb init ~/my-project         Initialize project
  curb init --global             Setup system config

ENVIRONMENT VARIABLES:
  CURB_PROJECT_DIR               Project directory (default: pwd)
  CURB_MAX_ITERATIONS            Max loop iterations (default: 100)
  CURB_DEBUG                     Set to "true" for debug
  CURB_BACKEND                   Task backend (auto/beads/json)
  CURB_BUDGET                    Token budget
  CURB_REQUIRE_CLEAN             Clean state enforcement
  HARNESS                        Harness to use
  CURB_MODEL                     Claude model
  CURB_EPIC                      Epic filter
  CURB_LABEL                     Label filter

PROJECT FILES:
  prd.json                       Task backlog (json backend)
  .beads/                        Task tracking (beads backend)
  PROMPT.md                      System prompt template
  AGENT.md                       Build/run instructions
  specs/                         Specification files
  progress.txt                   Progress log
  fix_plan.md                    Issue tracking

LEARN MORE:
  README.md                      Overview and features
  CONFIG.md                      Configuration options
  CONTRIBUTING.md                Development guidelines

INSTALLATION:
  Beads (optional):
    brew install steveyegge/beads/bd
    npm install -g @beads/bd
    go install github.com/steveyegge/beads/cmd/bd@latest
EOF
            ;;
        --version)
            echo "curb v${CURB_VERSION}"
            ;;
        *)
            # Default: run the main loop with all args
            cmd_run "${args[@]}"
            ;;
    esac
}

main "$@"
