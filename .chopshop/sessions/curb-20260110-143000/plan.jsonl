{"id":"curb-E01","title":"Foundation: Session + Artifacts","description":"Phase 1 epic covering session identity and artifact bundle system. Goal: Observable runs with structured output.","status":"open","priority":0,"issue_type":"epic","labels":["phase-1"]}
{"id":"curb-E02","title":"CLI Restructuring","description":"Phase 2 epic covering subcommand interface migration. Goal: Consistent subcommand interface.","status":"open","priority":0,"issue_type":"epic","labels":["phase-2"]}
{"id":"curb-E03","title":"Git Workflow","description":"Phase 3 epic covering branch-per-run and commit-per-task workflow. Goal: Reviewable changes as primary output.","status":"open","priority":0,"issue_type":"epic","labels":["phase-3"]}
{"id":"curb-E04","title":"Guardrails + Safety","description":"Phase 4 epic covering iteration limits and safe defaults. Goal: Prevent runaway loops and protect secrets.","status":"open","priority":1,"issue_type":"epic","labels":["phase-4"]}
{"id":"curb-E05","title":"Failure Handling","description":"Phase 5 epic covering configurable failure modes. Goal: Flexible response to task failures.","status":"open","priority":1,"issue_type":"epic","labels":["phase-5"]}
{"id":"curb-E06","title":"Polish","description":"Phase 6 epic covering default hooks, debug enhancements, and documentation. Goal: Production-ready 1.0 release.","status":"open","priority":2,"issue_type":"epic","labels":["phase-6"]}
{"id":"curb-001","title":"Create lib/session.sh with animal wordlist","description":"## Context\nSession identity allows concurrent curb instances to be distinguished. The animal wordlist provides friendly, memorable names.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 25m\n**Approach:** Create a Bash array with ~100 animal names. Keep it simple - no external dependencies.\n\n## Implementation Steps\n1. Create lib/session.sh with standard header\n2. Define ANIMAL_NAMES array with ~100 animals (fox, owl, bear, wolf, etc.)\n3. Add session_random_name() function that picks randomly from array\n4. Source xdg.sh for any path helpers needed\n\n## Acceptance Criteria\n- [ ] lib/session.sh exists with proper header\n- [ ] ANIMAL_NAMES array contains ~100 unique animals\n- [ ] session_random_name returns a valid animal name\n- [ ] No external dependencies beyond bash builtins\n\n## Files Likely Involved\n- lib/session.sh (new)\n\n## Notes\nUse $RANDOM % array_length for selection. Animals should be lowercase, single words.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:haiku","complexity:low","setup"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"}]}
{"id":"curb-002","title":"Implement session_init and session_get_* functions","description":"## Context\nSession functions manage the session lifecycle - initialization with optional name override, and getters for session properties.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Store session state in global variables. Generate timestamp-based session ID.\n\n## Implementation Steps\n1. Add global variables: _SESSION_NAME, _SESSION_ID, _SESSION_STARTED_AT\n2. Implement session_init() that accepts optional --name parameter\n3. Generate session ID as {name}-{YYYYMMDD-HHMMSS}\n4. Implement session_get_name, session_get_id, session_get_run_id\n5. Add session_is_initialized check\n\n## Acceptance Criteria\n- [ ] session_init with no args generates random animal name\n- [ ] session_init --name fox uses provided name\n- [ ] session_get_id returns format like 'fox-20260110-143022'\n- [ ] Calling getters before init returns error\n\n## Files Likely Involved\n- lib/session.sh\n\n## Notes\nUse date +%Y%m%d-%H%M%S for timestamp. Store started_at in ISO 8601 format.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-001","type":"blocks"}]}
{"id":"curb-003","title":"Create lib/artifacts.sh with directory structure helpers","description":"## Context\nArtifact bundles provide observability into each task's execution. This task sets up the module and directory creation helpers.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Use .curb/runs/<run-id>/tasks/<task-id>/ structure. Create directories with secure permissions (700).\n\n## Implementation Steps\n1. Create lib/artifacts.sh with standard header\n2. Source session.sh and xdg.sh\n3. Define _ARTIFACTS_BASE_DIR (defaults to .curb/runs)\n4. Add artifacts_get_run_dir() returning path for current run\n5. Add artifacts_get_task_dir(task_id) returning path for task\n6. Add artifacts_ensure_dirs(task_id) to create directory structure\n7. Set permissions to 700 for directories\n\n## Acceptance Criteria\n- [ ] lib/artifacts.sh exists with proper header\n- [ ] artifacts_get_run_dir returns .curb/runs/{session-id}\n- [ ] artifacts_get_task_dir returns .curb/runs/{session-id}/tasks/{task-id}\n- [ ] artifacts_ensure_dirs creates nested structure\n- [ ] Directories created with 700 permissions\n\n## Files Likely Involved\n- lib/artifacts.sh (new)\n- lib/session.sh (source)\n\n## Notes\nUse mkdir -p -m 700 for secure directory creation.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-002","type":"blocks"}]}
{"id":"curb-004","title":"Implement artifacts_init_run and artifacts_start_task","description":"## Context\nThese functions initialize the run-level and task-level artifact structures, writing initial metadata files.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Write JSON metadata using jq. Capture config snapshot at run start.\n\n## Implementation Steps\n1. Implement artifacts_init_run() that creates run directory and run.json\n2. run.json should contain: run_id, session_name, started_at, config snapshot, status='in_progress'\n3. Implement artifacts_start_task(task_id, task_title, priority) \n4. Create task directory and task.json with initial metadata\n5. task.json should contain: task_id, title, priority, status='in_progress', started_at, iterations=0\n\n## Acceptance Criteria\n- [ ] artifacts_init_run creates run.json with correct schema\n- [ ] artifacts_start_task creates task.json with correct schema\n- [ ] JSON is valid (parseable by jq)\n- [ ] Timestamps are ISO 8601 format\n\n## Files Likely Involved\n- lib/artifacts.sh\n\n## Notes\nUse jq -n for creating JSON. Include config from config_get_all if available.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-003","type":"blocks"}]}
{"id":"curb-005","title":"Implement artifacts_capture_* functions","description":"## Context\nCapture functions record different types of artifacts during task execution: plans, commands, and diffs.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Append to files for commands (JSONL), overwrite for plan/diff. Use git diff for changes.\n\n## Implementation Steps\n1. Implement artifacts_capture_plan(task_id, plan_content) - writes plan.md\n2. Implement artifacts_capture_command(task_id, cmd, exit_code, output, duration) - appends to commands.jsonl\n3. Implement artifacts_capture_diff(task_id) - runs git diff and writes changes.patch\n4. Set file permissions to 600\n5. Handle empty diffs gracefully (write empty file or skip)\n\n## Acceptance Criteria\n- [ ] artifacts_capture_plan writes markdown to plan.md\n- [ ] artifacts_capture_command appends valid JSONL to commands.jsonl\n- [ ] artifacts_capture_diff captures staged and unstaged changes\n- [ ] Files created with 600 permissions\n- [ ] Functions are idempotent (can be called multiple times)\n\n## Files Likely Involved\n- lib/artifacts.sh\n\n## Notes\nFor git diff, use 'git diff HEAD' to capture all uncommitted changes. Include timestamp in command entries.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-004","type":"blocks"}]}
{"id":"curb-006","title":"Implement artifacts_finalize_task and summary generation","description":"## Context\nFinalization updates task.json with final status and generates a human-readable summary.md.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Update task.json in place with jq. Generate markdown summary from collected data.\n\n## Implementation Steps\n1. Implement artifacts_finalize_task(task_id, status, exit_code, summary_text)\n2. Update task.json: set status, completed_at, exit_code, increment iterations\n3. Generate summary.md with: task title, status, duration, files changed, summary text\n4. Implement artifacts_get_path(task_id) returning full path to task artifacts\n5. Update run.json counters (tasks_completed or tasks_failed)\n\n## Acceptance Criteria\n- [ ] task.json updated with final status and completed_at\n- [ ] summary.md contains readable task summary\n- [ ] run.json task counters are incremented\n- [ ] artifacts_get_path returns correct absolute path\n\n## Files Likely Involved\n- lib/artifacts.sh\n\n## Notes\nCalculate duration from started_at to completed_at. Use jq for JSON updates.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-005","type":"blocks"}]}
{"id":"curb-007","title":"Add curb version subcommand","description":"## Context\nThe version subcommand is a quick win that establishes the dispatcher pattern for later subcommands.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 15m\n**Approach:** Add minimal dispatcher that checks first arg. Version just prints CURB_VERSION.\n\n## Implementation Steps\n1. At top of curb script (after sourcing libs), check if $1 is a subcommand\n2. Add case statement: 'version' calls cmd_version\n3. Implement cmd_version() that prints 'curb version $CURB_VERSION'\n4. Fall through to existing flag parsing for backwards compatibility\n\n## Acceptance Criteria\n- [ ] 'curb version' prints version string\n- [ ] Existing flag-based invocations still work\n- [ ] Exit code is 0 for version command\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nThis establishes the pattern for adding more subcommands in Phase 2.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:haiku","complexity:low","setup","quick-win"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"}]}
{"id":"curb-008","title":"Write BATS tests for lib/session.sh","description":"## Context\nTest coverage ensures session management works correctly and catches regressions.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 25m\n**Approach:** Follow existing test patterns in tests/. Test both happy paths and error cases.\n\n## Implementation Steps\n1. Create tests/session.bats\n2. Test session_random_name returns valid animal\n3. Test session_init with no args\n4. Test session_init --name custom\n5. Test session_get_* functions return expected formats\n6. Test calling getters before init fails\n\n## Acceptance Criteria\n- [ ] tests/session.bats exists\n- [ ] All session functions have test coverage\n- [ ] Tests pass: bats tests/session.bats\n- [ ] Error cases are tested\n\n## Files Likely Involved\n- tests/session.bats (new)\n- lib/session.sh\n\n## Notes\nLook at existing tests for patterns. Use setup/teardown for test isolation.","status":"open","priority":1,"issue_type":"task","labels":["phase-1","model:haiku","complexity:low","test"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-002","type":"blocks"}]}
{"id":"curb-009","title":"Write BATS tests for lib/artifacts.sh","description":"## Context\nTest coverage for artifact system ensures bundles are created correctly.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Use temp directories for test isolation. Verify file contents with jq.\n\n## Implementation Steps\n1. Create tests/artifacts.bats\n2. Test artifacts_init_run creates run.json\n3. Test artifacts_start_task creates task directory and task.json\n4. Test artifacts_capture_* functions create correct files\n5. Test artifacts_finalize_task updates JSON correctly\n6. Test artifacts_get_path returns correct paths\n7. Verify JSON validity with jq\n\n## Acceptance Criteria\n- [ ] tests/artifacts.bats exists\n- [ ] All artifacts functions have test coverage\n- [ ] Tests verify JSON structure with jq\n- [ ] Tests use isolated temp directories\n\n## Files Likely Involved\n- tests/artifacts.bats (new)\n- lib/artifacts.sh\n\n## Notes\nUse mktemp -d for test directories. Clean up in teardown.","status":"open","priority":1,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","test"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-006","type":"blocks"}]}
{"id":"curb-010","title":"Integrate session and artifacts into main loop","description":"## Context\nIntegration connects the new modules to the existing main loop, enabling artifact generation during runs.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Add session_init at run start, artifacts calls around task execution.\n\n## Implementation Steps\n1. Source lib/session.sh and lib/artifacts.sh in curb\n2. Add --name flag parsing for session name override\n3. Call session_init at start of run (after config_load)\n4. Call artifacts_init_run after session_init\n5. Call artifacts_start_task before each task execution\n6. Call artifacts_capture_* during task execution\n7. Call artifacts_finalize_task after task completion\n8. Log session name and artifact paths\n\n## Acceptance Criteria\n- [ ] Session initialized at run start\n- [ ] --name flag works to override session name\n- [ ] Artifact bundle created for each task\n- [ ] Session name appears in logs\n- [ ] Artifacts contain expected files\n\n## Files Likely Involved\n- curb (main script)\n- lib/session.sh\n- lib/artifacts.sh\n\n## Notes\nCapture plan from harness output. Capture diff before and after task.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-006","type":"blocks"},{"depends_on_id":"curb-007","type":"blocks"}]}
{"id":"curb-011","title":"CHECKPOINT: Verify artifact bundle generation end-to-end","description":"## Context\nValidation checkpoint to ensure Phase 1 deliverables work correctly before proceeding.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Run curb on a test project and manually verify artifacts.\n\n## Implementation Steps\n1. Run full test suite: bats tests/\n2. Run curb on tests/e2e/project with a simple task\n3. Verify .curb/runs/<run-id>/ directory created\n4. Verify run.json contains correct metadata\n5. Verify tasks/<task-id>/ contains all artifact files\n6. Verify task.json, plan.md, changes.patch, commands.jsonl, summary.md exist\n7. Document any issues found\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Artifact bundle directory structure is correct\n- [ ] All artifact files contain valid content\n- [ ] Session name appears in run.json\n- [ ] No regressions in existing functionality\n\n## Files Likely Involved\n- All Phase 1 files\n- tests/e2e/\n\n## Notes\nThis is a validation checkpoint. Fix any issues before proceeding to Phase 2.","status":"open","priority":0,"issue_type":"task","labels":["phase-1","model:sonnet","complexity:medium","checkpoint"],"dependencies":[{"depends_on_id":"curb-E01","type":"parent-child"},{"depends_on_id":"curb-010","type":"blocks"}]}
{"id":"curb-012","title":"Create subcommand dispatcher in curb entry point","description":"## Context\nThe dispatcher routes subcommands to handler functions, enabling the new CLI structure.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Use case statement at script start. Preserve backwards compatibility with flags.\n\n## Implementation Steps\n1. Define list of valid subcommands: init, run, status, explain, artifacts, version\n2. Add dispatcher function that checks if $1 matches a subcommand\n3. Route to cmd_* functions for each subcommand\n4. If no subcommand match, fall through to legacy flag parsing\n5. Pass remaining args to subcommand handlers\n6. Handle --help at dispatcher level\n\n## Acceptance Criteria\n- [ ] 'curb run' invokes cmd_run\n- [ ] 'curb init' invokes cmd_init\n- [ ] 'curb status' invokes cmd_status\n- [ ] Unknown subcommands show help\n- [ ] Legacy flags still work (backwards compatibility)\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nKeep dispatcher simple. Complex logic belongs in cmd_* functions.","status":"open","priority":0,"issue_type":"task","labels":["phase-2","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-007","type":"blocks"}]}
{"id":"curb-013","title":"Extract main loop logic into cmd_run function","description":"## Context\nMoving the main loop into cmd_run enables the subcommand interface while preserving all existing functionality.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Wrap existing main logic in cmd_run(). Parse run-specific flags inside.\n\n## Implementation Steps\n1. Create cmd_run() function\n2. Move existing main loop logic into cmd_run\n3. Parse run-specific flags: --once, --epic, --label, --harness, --model, --budget, --name, --push, --stream, --debug\n4. Keep flag parsing compatible with legacy invocation\n5. Ensure all existing functionality works via 'curb run'\n\n## Acceptance Criteria\n- [ ] 'curb run' executes the main loop\n- [ ] All existing flags work with 'curb run'\n- [ ] 'curb run --once' runs single iteration\n- [ ] 'curb run --epic X' filters by epic\n- [ ] No behavior changes from previous implementation\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nThis is a refactor, not a rewrite. Preserve exact behavior.","status":"open","priority":0,"issue_type":"task","labels":["phase-2","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-012","type":"blocks"}]}
{"id":"curb-014","title":"Move curb-init logic into cmd_init","description":"## Context\nConsolidating curb-init into curb init simplifies the CLI and reduces maintenance burden.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Copy curb-init logic into cmd_init, update paths, keep curb-init as thin wrapper.\n\n## Implementation Steps\n1. Create cmd_init() function in curb\n2. Copy initialization logic from curb-init\n3. Handle --global flag for global init\n4. Handle path argument for project init\n5. Update curb-init to be a thin wrapper that calls 'curb init'\n6. Add deprecation notice to curb-init\n\n## Acceptance Criteria\n- [ ] 'curb init' works for project initialization\n- [ ] 'curb init --global' works for global initialization\n- [ ] curb-init still works but shows deprecation notice\n- [ ] All init functionality preserved\n\n## Files Likely Involved\n- curb (main script)\n- curb-init\n\n## Notes\nKeep curb-init working for backwards compatibility but mark deprecated.","status":"open","priority":0,"issue_type":"task","labels":["phase-2","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-012","type":"blocks"}]}
{"id":"curb-015","title":"Implement cmd_status (migrate from --status flag)","description":"## Context\nMigrating --status to 'curb status' subcommand for CLI consistency.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Extract existing status logic, add --json output option.\n\n## Implementation Steps\n1. Create cmd_status() function\n2. Move existing --status logic into cmd_status\n3. Add --json flag for machine-readable output\n4. Show: current session (if running), last run, task counts, recent artifacts\n5. Format output nicely for terminal\n\n## Acceptance Criteria\n- [ ] 'curb status' shows current/last run status\n- [ ] 'curb status --json' outputs valid JSON\n- [ ] Shows task completion counts\n- [ ] Shows path to recent artifacts\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nLook at existing --status implementation for baseline.","status":"open","priority":1,"issue_type":"task","labels":["phase-2","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-012","type":"blocks"}]}
{"id":"curb-016","title":"Implement cmd_artifacts to show task artifact paths","description":"## Context\nThe artifacts command helps users quickly find artifact bundles for specific tasks.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Simple lookup in .curb/runs/ directories.\n\n## Implementation Steps\n1. Create cmd_artifacts(task_id) function\n2. Search .curb/runs/*/tasks/ for matching task_id\n3. Print full path to task artifact directory\n4. If no task_id given, list recent tasks with paths\n5. Handle case where task not found\n\n## Acceptance Criteria\n- [ ] 'curb artifacts <task-id>' prints path to artifacts\n- [ ] 'curb artifacts' lists recent tasks\n- [ ] Helpful error message if task not found\n- [ ] Works with partial task IDs (prefix match)\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nUse find or glob to search artifact directories.","status":"open","priority":1,"issue_type":"task","labels":["phase-2","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-012","type":"blocks"},{"depends_on_id":"curb-006","type":"blocks"}]}
{"id":"curb-017","title":"Add deprecation warnings for legacy flag syntax","description":"## Context\nDeprecation warnings help users migrate to the new subcommand syntax gradually.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Detect legacy flags in dispatcher, warn, then execute.\n\n## Implementation Steps\n1. In dispatcher, detect legacy flag patterns (--status, --ready, --plan)\n2. Print deprecation warning to stderr with migration hint\n3. Map legacy flags to new subcommands internally\n4. Continue execution normally\n5. Add CURB_NO_DEPRECATION_WARNINGS env var to suppress\n\n## Acceptance Criteria\n- [ ] 'curb --status' warns and runs status\n- [ ] Warning message includes new syntax hint\n- [ ] Warning goes to stderr, not stdout\n- [ ] CURB_NO_DEPRECATION_WARNINGS=1 suppresses warnings\n- [ ] Functionality still works correctly\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nFormat: 'Warning: --status is deprecated, use: curb status'","status":"open","priority":1,"issue_type":"task","labels":["phase-2","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-013","type":"blocks"}]}
{"id":"curb-018","title":"Update help text for subcommand CLI","description":"## Context\nHelp text needs to reflect the new subcommand structure for discoverability.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 25m\n**Approach:** Update show_help() function with subcommand documentation.\n\n## Implementation Steps\n1. Update main help to show subcommand list\n2. Add per-subcommand help: 'curb run --help', 'curb init --help'\n3. Show examples for common workflows\n4. Document all flags for each subcommand\n5. Keep help concise but complete\n\n## Acceptance Criteria\n- [ ] 'curb --help' shows subcommand overview\n- [ ] 'curb run --help' shows run-specific options\n- [ ] 'curb init --help' shows init-specific options\n- [ ] Examples included for common use cases\n- [ ] Help fits in standard terminal (80 cols)\n\n## Files Likely Involved\n- curb (main script)\n\n## Notes\nFollow existing help format conventions.","status":"open","priority":1,"issue_type":"task","labels":["phase-2","model:haiku","complexity:low","docs"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-014","type":"blocks"}]}
{"id":"curb-019","title":"Write BATS tests for CLI dispatcher and routing","description":"## Context\nTest coverage ensures the new CLI structure works correctly.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Test each subcommand routes correctly, test backwards compatibility.\n\n## Implementation Steps\n1. Create tests/cli.bats (or extend existing)\n2. Test each subcommand invokes correct handler\n3. Test --help at various levels\n4. Test deprecation warnings appear for legacy flags\n5. Test unknown subcommands show help\n6. Test backwards compatibility with legacy invocations\n\n## Acceptance Criteria\n- [ ] All subcommands tested\n- [ ] Help output tested\n- [ ] Deprecation warnings tested\n- [ ] Backwards compatibility tested\n- [ ] Tests pass: bats tests/cli.bats\n\n## Files Likely Involved\n- tests/cli.bats (new or extended)\n- curb\n\n## Notes\nUse bats assertions to check output and exit codes.","status":"open","priority":1,"issue_type":"task","labels":["phase-2","model:sonnet","complexity:medium","test"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-014","type":"blocks"}]}
{"id":"curb-020","title":"CHECKPOINT: Verify all subcommands work correctly","description":"## Context\nValidation checkpoint for Phase 2 CLI restructuring.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Manual testing of all subcommands plus full test suite.\n\n## Implementation Steps\n1. Run full test suite\n2. Manually test: curb version, curb init, curb run --once, curb status, curb artifacts\n3. Test deprecation warnings appear\n4. Test --help for each subcommand\n5. Verify curb-init still works (deprecated)\n6. Document any issues\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] All subcommands work as expected\n- [ ] Deprecation warnings working\n- [ ] Help text accurate\n- [ ] Backwards compatibility maintained\n\n## Files Likely Involved\n- All Phase 2 files\n\n## Notes\nPhase 2 checkpoint. Fix issues before proceeding.","status":"open","priority":0,"issue_type":"task","labels":["phase-2","model:sonnet","complexity:medium","checkpoint"],"dependencies":[{"depends_on_id":"curb-E02","type":"parent-child"},{"depends_on_id":"curb-019","type":"blocks"}]}
{"id":"curb-021","title":"Create lib/git.sh and extract git functions from state.sh","description":"## Context\nSeparating git operations into dedicated module improves organization and enables new git workflow features.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Extract existing git functions, add new ones for workflow support.\n\n## Implementation Steps\n1. Create lib/git.sh with standard header\n2. Move git-related functions from state.sh\n3. Keep state.sh functions that call git.sh for compatibility\n4. Add git_in_repo() check function\n5. Add git_get_current_branch() function\n6. Add git_is_clean() function (from state.sh)\n7. Source git.sh in curb main script\n\n## Acceptance Criteria\n- [ ] lib/git.sh exists with extracted functions\n- [ ] state.sh still works (calls git.sh internally)\n- [ ] No behavior changes to existing git checks\n- [ ] git_in_repo, git_get_current_branch, git_is_clean work\n\n## Files Likely Involved\n- lib/git.sh (new)\n- lib/state.sh (modify)\n- curb\n\n## Notes\nThis is a refactor. Don't break existing state.sh callers.","status":"open","priority":0,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-011","type":"blocks"}]}
{"id":"curb-022","title":"Implement git_init_run_branch with naming convention","description":"## Context\nCreating a branch per run keeps work isolated and enables clean PR workflows.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Branch naming: curb/{session-name}/{timestamp}. Create from current HEAD.\n\n## Implementation Steps\n1. Implement git_init_run_branch(session_name)\n2. Generate branch name: curb/{session_name}/{YYYYMMDD-HHMMSS}\n3. Check if branch already exists (warn and use if so)\n4. Create and checkout branch: git checkout -b {branch}\n5. Store branch name for later reference\n6. Add git_get_run_branch() to retrieve stored name\n\n## Acceptance Criteria\n- [ ] Branch created with correct naming convention\n- [ ] Branch checked out after creation\n- [ ] Handles existing branch gracefully\n- [ ] git_get_run_branch returns current run branch\n- [ ] Works from any starting branch\n\n## Files Likely Involved\n- lib/git.sh\n\n## Notes\nUse git checkout -b for atomic create+checkout.","status":"open","priority":0,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-021","type":"blocks"}]}
{"id":"curb-023","title":"Implement git_commit_task with structured message format","description":"## Context\nCommitting after each task creates reviewable history with clear task attribution.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Structured commit message with task ID, title, and summary.\n\n## Implementation Steps\n1. Implement git_commit_task(task_id, task_title, summary)\n2. Stage all changes: git add -A\n3. Format commit message:\n   - First line: '[{task_id}] {task_title}'\n   - Blank line\n   - Summary text\n   - Blank line  \n   - 'Task-ID: {task_id}'\n4. Handle case where nothing to commit\n5. Return success/failure status\n\n## Acceptance Criteria\n- [ ] Commit created with structured message\n- [ ] Task ID in commit title and trailer\n- [ ] All changes staged before commit\n- [ ] No-op if nothing to commit (not an error)\n- [ ] Commit message parseable for task extraction\n\n## Files Likely Involved\n- lib/git.sh\n\n## Notes\nUse git commit -m with heredoc for multi-line message.","status":"open","priority":0,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-022","type":"blocks"}]}
{"id":"curb-024","title":"Implement git_has_changes and git_get_run_branch helpers","description":"## Context\nHelper functions support the git workflow integration in the main loop.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Simple wrappers around git commands.\n\n## Implementation Steps\n1. Implement git_has_changes() - returns 0 if uncommitted changes exist\n2. Use: git status --porcelain\n3. Implement git_get_run_branch() - returns stored branch name\n4. Implement git_stash_changes() and git_unstash_changes() for safety\n5. Add git_get_base_branch() to remember where we branched from\n\n## Acceptance Criteria\n- [ ] git_has_changes correctly detects changes\n- [ ] git_get_run_branch returns branch name set by git_init_run_branch\n- [ ] Stash functions work for temporary change storage\n- [ ] Base branch tracked for potential PR creation\n\n## Files Likely Involved\n- lib/git.sh\n\n## Notes\nUse global variables to store branch state within session.","status":"open","priority":0,"issue_type":"task","labels":["phase-3","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-021","type":"blocks"}]}
{"id":"curb-025","title":"Add --push flag and git_push_branch (explicit opt-in)","description":"## Context\nPushing requires explicit opt-in for safety. The --push flag enables it.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Only push when --push flag is passed. Never auto-push.\n\n## Implementation Steps\n1. Add --push flag to cmd_run argument parsing\n2. Implement git_push_branch() - pushes current branch to origin\n3. Use: git push -u origin {branch}\n4. Only call git_push_branch if --push flag was set\n5. Add git_push_branch --force option (with extra confirmation)\n6. Log push operations clearly\n\n## Acceptance Criteria\n- [ ] --push flag recognized by curb run\n- [ ] git_push_branch pushes to origin with upstream tracking\n- [ ] Without --push, no push occurs (safe default)\n- [ ] Push success/failure logged clearly\n- [ ] Force push requires explicit --force flag\n\n## Files Likely Involved\n- lib/git.sh\n- curb (flag parsing)\n\n## Notes\nSafety first - never push without explicit user intent.","status":"open","priority":1,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-023","type":"blocks"}]}
{"id":"curb-026","title":"Integrate git workflow into main loop","description":"## Context\nIntegration connects the git module to the main loop: branch on start, commit after each task.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Call git functions at appropriate points in the loop.\n\n## Implementation Steps\n1. Call git_init_run_branch after session_init (if in git repo)\n2. After each task completion, call git_commit_task\n3. Before task, capture diff for artifacts\n4. After task, capture diff and commit\n5. At end of run, optionally push if --push flag set\n6. Handle non-git directories gracefully (skip git ops)\n\n## Acceptance Criteria\n- [ ] Branch created at run start\n- [ ] Commit created after each successful task\n- [ ] Push happens at end if --push flag set\n- [ ] Works correctly in non-git directories (skips git ops)\n- [ ] Commit messages reference task IDs\n\n## Files Likely Involved\n- curb (main script)\n- lib/git.sh\n\n## Notes\nUse git_in_repo to guard git operations.","status":"open","priority":0,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-023","type":"blocks"},{"depends_on_id":"curb-024","type":"blocks"}]}
{"id":"curb-027","title":"Write BATS tests for lib/git.sh","description":"## Context\nTest coverage for git operations ensures workflow reliability.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Use temp git repos for isolation. Test all git functions.\n\n## Implementation Steps\n1. Create tests/git.bats\n2. Setup: create temp git repo with initial commit\n3. Test git_init_run_branch creates correct branch\n4. Test git_commit_task creates commit with correct message\n5. Test git_has_changes detection\n6. Test git_get_run_branch returns correct name\n7. Teardown: clean up temp repos\n\n## Acceptance Criteria\n- [ ] tests/git.bats exists\n- [ ] All git functions tested\n- [ ] Tests use isolated temp repos\n- [ ] Tests verify commit messages\n- [ ] Tests pass: bats tests/git.bats\n\n## Files Likely Involved\n- tests/git.bats (new)\n- lib/git.sh\n\n## Notes\nUse git init in temp directory for each test.","status":"open","priority":1,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","test"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-026","type":"blocks"}]}
{"id":"curb-028","title":"CHECKPOINT: Verify branch-per-run, commit-per-task workflow","description":"## Context\nValidation checkpoint for Phase 3 git workflow.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Run curb and verify git history.\n\n## Implementation Steps\n1. Run full test suite\n2. Run curb on test project with multiple tasks\n3. Verify branch created with correct name\n4. Verify commits exist for each task\n5. Verify commit messages have task IDs\n6. Test --push flag (to a test remote)\n7. Document any issues\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Branch naming correct: curb/{session}/{timestamp}\n- [ ] One commit per completed task\n- [ ] Commit messages include task IDs\n- [ ] --push works correctly\n\n## Files Likely Involved\n- All Phase 3 files\n\n## Notes\nPhase 3 checkpoint. Verify git log shows expected history.","status":"open","priority":0,"issue_type":"task","labels":["phase-3","model:sonnet","complexity:medium","checkpoint"],"dependencies":[{"depends_on_id":"curb-E03","type":"parent-child"},{"depends_on_id":"curb-027","type":"blocks"}]}
{"id":"curb-029","title":"Add iteration tracking to budget.sh","description":"## Context\nIteration limits prevent runaway loops by capping retries per task and total iterations per run.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Add counters and limit checks to existing budget module.\n\n## Implementation Steps\n1. Add global variables: _TASK_ITERATIONS (associative array), _RUN_ITERATIONS\n2. Add config options: max_task_iterations (default 3), max_run_iterations (default 50)\n3. Implement budget_set_max_task_iterations(n)\n4. Implement budget_set_max_run_iterations(n)\n5. Implement budget_get_task_iterations(task_id)\n6. Implement budget_get_run_iterations()\n\n## Acceptance Criteria\n- [ ] Iteration counters track per-task and per-run\n- [ ] Config options for max iterations\n- [ ] Defaults: 3 per task, 50 per run\n- [ ] Counters persist across function calls\n\n## Files Likely Involved\n- lib/budget.sh\n- lib/config.sh (defaults)\n\n## Notes\nUse declare -A for associative array (task iterations).","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-020","type":"blocks"}]}
{"id":"curb-030","title":"Implement budget_check_* and budget_increment_* functions","description":"## Context\nCheck and increment functions enable the main loop to enforce iteration limits.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Check returns 0/1 for under/over limit. Increment updates counters.\n\n## Implementation Steps\n1. Implement budget_increment_task_iteration(task_id)\n2. Implement budget_increment_run_iteration()\n3. Implement budget_check_task_iterations(task_id) - returns 1 if over limit\n4. Implement budget_check_run_iterations() - returns 1 if over limit\n5. Implement budget_reset_task_iterations(task_id) for retry scenarios\n6. Log warnings when approaching limits (80% threshold)\n\n## Acceptance Criteria\n- [ ] Increment functions update counters correctly\n- [ ] Check functions return correct status\n- [ ] Warning logged at 80% of limit\n- [ ] Reset function clears task counter\n- [ ] Functions work together correctly\n\n## Files Likely Involved\n- lib/budget.sh\n\n## Notes\nReturn 0 for OK, 1 for exceeded (bash convention).","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-029","type":"blocks"}]}
{"id":"curb-031","title":"Add logger_redact function with secret patterns","description":"## Context\nSecret redaction prevents accidental exposure of sensitive data in logs and output.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Regex patterns to detect and mask secrets. Configurable patterns.\n\n## Implementation Steps\n1. Define default secret patterns array in logger.sh\n2. Patterns: API_KEY, TOKEN, SECRET, PASSWORD, BEARER, private_key, etc.\n3. Implement logger_redact(string) - returns string with secrets masked\n4. Replace matches with '[REDACTED]'\n5. Make patterns configurable via config.json\n6. Apply redaction in logger_write automatically\n\n## Acceptance Criteria\n- [ ] Common secret patterns detected and redacted\n- [ ] Redaction replaces value with '[REDACTED]'\n- [ ] Patterns configurable via config\n- [ ] logger_write applies redaction automatically\n- [ ] No false positives on common words\n\n## Files Likely Involved\n- lib/logger.sh\n- lib/config.sh\n\n## Notes\nPatterns: /API_KEY[=:][^ ]+/, /Bearer [A-Za-z0-9]+/, etc.","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"}]}
{"id":"curb-032","title":"Add logger_stream with timestamps","description":"## Context\nTimestamped streaming output helps users understand when events occurred during runs.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Prefix stream output with timestamp.\n\n## Implementation Steps\n1. Implement logger_stream(message) function\n2. Format: '[HH:MM:SS] message'\n3. Apply secret redaction before output\n4. Output to stdout (not log file)\n5. Use in places where --stream flag enables output\n6. Make timestamp format configurable (optional)\n\n## Acceptance Criteria\n- [ ] logger_stream outputs with timestamp prefix\n- [ ] Timestamp format is HH:MM:SS\n- [ ] Secret redaction applied\n- [ ] Works with --stream flag in main loop\n\n## Files Likely Involved\n- lib/logger.sh\n\n## Notes\nUse date +%H:%M:%S for timestamp.","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-031","type":"blocks"}]}
{"id":"curb-033","title":"Add config schema for guardrails","description":"## Context\nConfig options allow users to customize guardrail thresholds.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Add new keys to config schema with sensible defaults.\n\n## Implementation Steps\n1. Add to config defaults: max_task_iterations=3\n2. Add to config defaults: max_run_iterations=50\n3. Add to config defaults: secret_patterns (array)\n4. Add to config defaults: iteration_warning_threshold=0.8\n5. Update config_get to support these keys\n6. Document new config options\n\n## Acceptance Criteria\n- [ ] Config keys defined with defaults\n- [ ] config_get returns correct values\n- [ ] Users can override in config.json\n- [ ] Defaults are sensible\n\n## Files Likely Involved\n- lib/config.sh\n- docs/CONFIG.md\n\n## Notes\nFollow existing config patterns.","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:haiku","complexity:low","setup"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-029","type":"blocks"}]}
{"id":"curb-034","title":"Integrate iteration limits into main loop","description":"## Context\nIntegration enforces iteration limits during run execution.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Check limits before each task attempt, abort if exceeded.\n\n## Implementation Steps\n1. Load max iterations from config at run start\n2. Before each task attempt, check budget_check_run_iterations\n3. Before each task retry, check budget_check_task_iterations\n4. Increment counters after each attempt\n5. If limit exceeded, log reason and stop/move-on based on policy\n6. Include iteration counts in task artifacts\n\n## Acceptance Criteria\n- [ ] Run stops when max_run_iterations exceeded\n- [ ] Task marked failed when max_task_iterations exceeded\n- [ ] Iteration counts logged\n- [ ] Counts included in artifact metadata\n- [ ] Behavior matches configured policy\n\n## Files Likely Involved\n- curb (main script)\n- lib/budget.sh\n\n## Notes\nThis integrates with failure handling in Phase 5.","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-030","type":"blocks"},{"depends_on_id":"curb-033","type":"blocks"}]}
{"id":"curb-035","title":"Write BATS tests for iteration tracking and secret redaction","description":"## Context\nTest coverage ensures guardrails work correctly.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Test limits and redaction independently.\n\n## Implementation Steps\n1. Add tests to tests/budget.bats for iteration tracking\n2. Test increment and check functions\n3. Test limit exceeded behavior\n4. Create tests/logger.bats for redaction tests\n5. Test various secret patterns are redacted\n6. Test false positive avoidance\n\n## Acceptance Criteria\n- [ ] Iteration tracking fully tested\n- [ ] Limit enforcement tested\n- [ ] Secret patterns tested\n- [ ] Redaction output verified\n- [ ] All tests pass\n\n## Files Likely Involved\n- tests/budget.bats\n- tests/logger.bats (new or extended)\n\n## Notes\nTest edge cases: exactly at limit, one over limit.","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:sonnet","complexity:medium","test"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-034","type":"blocks"},{"depends_on_id":"curb-032","type":"blocks"}]}
{"id":"curb-036","title":"CHECKPOINT: Verify guardrails prevent runaway loops","description":"## Context\nValidation checkpoint for Phase 4 guardrails.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Test limits with intentionally failing tasks.\n\n## Implementation Steps\n1. Run full test suite\n2. Create test scenario that would loop forever\n3. Verify max_task_iterations stops task retries\n4. Verify max_run_iterations stops run\n5. Verify secrets redacted in output\n6. Verify timestamps in stream output\n7. Document any issues\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] Iteration limits enforced\n- [ ] Secrets properly redacted\n- [ ] Timestamps appearing in output\n- [ ] No runaway loops possible\n\n## Files Likely Involved\n- All Phase 4 files\n\n## Notes\nPhase 4 checkpoint. Critical for autonomous safety.","status":"open","priority":1,"issue_type":"task","labels":["phase-4","model:sonnet","complexity:medium","checkpoint"],"dependencies":[{"depends_on_id":"curb-E04","type":"parent-child"},{"depends_on_id":"curb-035","type":"blocks"}]}
{"id":"curb-037","title":"Create lib/failure.sh with mode enum and failure_get_mode","description":"## Context\nFailure handling module provides configurable responses to task failures.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Simple enum-like constants and config reader.\n\n## Implementation Steps\n1. Create lib/failure.sh with standard header\n2. Define mode constants: FAILURE_STOP, FAILURE_MOVE_ON, FAILURE_RETRY, FAILURE_TRIAGE\n3. Add config default: failure_mode='move-on'\n4. Implement failure_get_mode() - returns current mode from config\n5. Implement failure_set_mode(mode) - for runtime override\n6. Validate mode values\n\n## Acceptance Criteria\n- [ ] lib/failure.sh exists\n- [ ] Mode constants defined\n- [ ] failure_get_mode returns configured mode\n- [ ] Default mode is 'move-on'\n- [ ] Invalid modes rejected\n\n## Files Likely Involved\n- lib/failure.sh (new)\n- lib/config.sh\n\n## Notes\nKeep simple - complex logic in later tasks.","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:haiku","complexity:low","setup"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-036","type":"blocks"}]}
{"id":"curb-038","title":"Implement stop and move-on failure modes","description":"## Context\nStop and move-on are the simplest failure modes - halt entirely or skip and continue.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Return different exit codes to signal behavior to main loop.\n\n## Implementation Steps\n1. Implement failure_handle_stop(task_id, exit_code, output)\n2. Log failure and return code indicating 'halt run'\n3. Implement failure_handle_move_on(task_id, exit_code, output)\n4. Mark task as failed, log, return code indicating 'continue'\n5. Store failure info for later retrieval (for explain command)\n6. Update task artifacts with failure info\n\n## Acceptance Criteria\n- [ ] Stop mode halts run immediately\n- [ ] Move-on mode marks task failed and continues\n- [ ] Failure info stored for retrieval\n- [ ] Task artifacts updated with failure details\n- [ ] Exit codes distinguish stop vs continue\n\n## Files Likely Involved\n- lib/failure.sh\n\n## Notes\nUse exit code 0 for continue, non-zero for stop.","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-037","type":"blocks"}]}
{"id":"curb-039","title":"Implement retry mode with counter and context passing","description":"## Context\nRetry mode attempts the task again with failure context to help the agent succeed.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Increment retry counter, augment prompt with failure context.\n\n## Implementation Steps\n1. Implement failure_handle_retry(task_id, exit_code, output)\n2. Check iteration limit (from budget.sh)\n3. If under limit: increment counter, return 'retry' signal\n4. If over limit: fall back to move-on behavior\n5. Implement failure_get_context(task_id) - returns failure info for prompt augmentation\n6. Format context: 'Previous attempt failed with: {output}. Please try a different approach.'\n\n## Acceptance Criteria\n- [ ] Retry increments task iteration counter\n- [ ] Retry respects max_task_iterations limit\n- [ ] Failure context available for prompt augmentation\n- [ ] Falls back to move-on when limit exceeded\n- [ ] Context format helpful for agent\n\n## Files Likely Involved\n- lib/failure.sh\n- lib/budget.sh\n\n## Notes\nContext should be concise but include key error info.","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-038","type":"blocks"}]}
{"id":"curb-040","title":"Integrate failure handling into main loop","description":"## Context\nIntegration connects failure handling to the main loop's task execution.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** After task failure, call failure handler and respond to its signal.\n\n## Implementation Steps\n1. Source lib/failure.sh in curb\n2. After harness returns non-zero, call failure handler\n3. Based on handler return: stop run, retry task, or move to next task\n4. For retry: augment prompt with failure context\n5. Log failure handling decisions\n6. Update artifacts with failure handling info\n\n## Acceptance Criteria\n- [ ] Failure mode respected on task failure\n- [ ] Stop mode halts run\n- [ ] Move-on mode continues to next task\n- [ ] Retry mode re-executes with context\n- [ ] All modes logged and tracked\n\n## Files Likely Involved\n- curb (main script)\n- lib/failure.sh\n\n## Notes\nThis is the key integration point for failure handling.","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-039","type":"blocks"}]}
{"id":"curb-041","title":"Implement cmd_explain to show task failure reasons","description":"## Context\nThe explain command helps users understand why a task failed or is blocked.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Read failure info from artifacts, format for display.\n\n## Implementation Steps\n1. Create cmd_explain(task_id) function\n2. Find task artifacts directory\n3. Read task.json for status and metadata\n4. Read summary.md for failure details\n5. Check dependencies for blocked status\n6. Format output with clear explanation\n7. Include suggestions for resolution if possible\n\n## Acceptance Criteria\n- [ ] 'curb explain <task-id>' shows task status\n- [ ] Failed tasks show failure reason\n- [ ] Blocked tasks show blocking dependencies\n- [ ] Output is human-readable\n- [ ] Handles missing task gracefully\n\n## Files Likely Involved\n- curb (main script)\n- lib/artifacts.sh\n\n## Notes\nMake output actionable - what can user do next?","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-040","type":"blocks"},{"depends_on_id":"curb-012","type":"blocks"}]}
{"id":"curb-042","title":"Write BATS tests for failure modes","description":"## Context\nTest coverage ensures failure handling works correctly for all modes.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Test each mode independently with mock failures.\n\n## Implementation Steps\n1. Create tests/failure.bats\n2. Test failure_get_mode returns correct mode\n3. Test stop mode halts appropriately\n4. Test move-on mode continues\n5. Test retry mode with under/over limit scenarios\n6. Test failure context generation\n7. Test cmd_explain output\n\n## Acceptance Criteria\n- [ ] tests/failure.bats exists\n- [ ] All failure modes tested\n- [ ] Limit enforcement tested\n- [ ] Context generation tested\n- [ ] All tests pass\n\n## Files Likely Involved\n- tests/failure.bats (new)\n- lib/failure.sh\n\n## Notes\nUse mock harness that fails on demand for testing.","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:sonnet","complexity:medium","test"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-041","type":"blocks"}]}
{"id":"curb-043","title":"CHECKPOINT: Verify failure handling works for all modes","description":"## Context\nValidation checkpoint for Phase 5 failure handling.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 20m\n**Approach:** Test each mode with real task failures.\n\n## Implementation Steps\n1. Run full test suite\n2. Test stop mode: verify run halts on failure\n3. Test move-on mode: verify continues past failure\n4. Test retry mode: verify retries with context\n5. Test retry limit: verify falls back to move-on\n6. Test curb explain output\n7. Document any issues\n\n## Acceptance Criteria\n- [ ] All tests pass\n- [ ] All failure modes work correctly\n- [ ] Retry limit enforced\n- [ ] curb explain provides useful info\n- [ ] Failures properly recorded in artifacts\n\n## Files Likely Involved\n- All Phase 5 files\n\n## Notes\nPhase 5 checkpoint. Critical for production reliability.","status":"open","priority":1,"issue_type":"task","labels":["phase-5","model:sonnet","complexity:medium","checkpoint"],"dependencies":[{"depends_on_id":"curb-E05","type":"parent-child"},{"depends_on_id":"curb-042","type":"blocks"}]}
{"id":"curb-044","title":"Create default pre-loop hook for automatic branch creation","description":"## Context\nDefault hook automates branch creation at run start for users who want it.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Ship as example hook, document how to enable.\n\n## Implementation Steps\n1. Create examples/hooks/pre-loop.d/10-auto-branch.sh\n2. Hook checks if in git repo, creates branch if so\n3. Uses git_init_run_branch from lib/git.sh\n4. Make hook optional (not enabled by default)\n5. Document in CONFIG.md how to enable default hooks\n\n## Acceptance Criteria\n- [ ] Hook script exists in examples/\n- [ ] Hook creates branch when enabled\n- [ ] Hook is idempotent (safe to run twice)\n- [ ] Documentation explains how to enable\n- [ ] Hook respects session naming\n\n## Files Likely Involved\n- examples/hooks/pre-loop.d/10-auto-branch.sh (new)\n- docs/CONFIG.md\n\n## Notes\nShip as example, let users copy to enable.","status":"open","priority":2,"issue_type":"task","labels":["phase-6","model:haiku","complexity:low","setup"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-028","type":"blocks"}]}
{"id":"curb-045","title":"Create default post-loop hook for PR prompt","description":"## Context\nDefault hook offers to create PR at end of successful run.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Interactive prompt at run end, uses gh CLI.\n\n## Implementation Steps\n1. Create examples/hooks/post-loop.d/90-pr-prompt.sh\n2. Hook checks if changes were pushed\n3. If pushed, prompt user to create PR\n4. Use gh pr create with sensible defaults\n5. PR title/body from run summary\n6. Make hook optional (not enabled by default)\n\n## Acceptance Criteria\n- [ ] Hook script exists in examples/\n- [ ] Prompts for PR creation if changes pushed\n- [ ] Uses gh CLI for PR creation\n- [ ] PR has meaningful title and body\n- [ ] Hook is optional and documented\n\n## Files Likely Involved\n- examples/hooks/post-loop.d/90-pr-prompt.sh (new)\n- docs/CONFIG.md\n\n## Notes\nRequires gh CLI installed. Graceful fallback if missing.","status":"open","priority":2,"issue_type":"task","labels":["phase-6","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-044","type":"blocks"}]}
{"id":"curb-046","title":"Add full harness command line to debug output","description":"## Context\nSeeing the exact command helps debug harness invocation issues.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 15m\n**Approach:** Log full command in harness.sh when debug mode enabled.\n\n## Implementation Steps\n1. In harness_invoke, capture full command with args\n2. When DEBUG=true, log the command before execution\n3. Include all flags and arguments\n4. Redact any secrets in the command\n5. Format for easy copy-paste testing\n\n## Acceptance Criteria\n- [ ] Full command logged in debug mode\n- [ ] Command includes all flags\n- [ ] Secrets redacted from command\n- [ ] Easy to copy-paste for manual testing\n\n## Files Likely Involved\n- lib/harness.sh\n\n## Notes\nUse logger_redact on command before logging.","status":"open","priority":2,"issue_type":"task","labels":["phase-6","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-020","type":"blocks"}]}
{"id":"curb-047","title":"Implement acceptance criteria parsing from task descriptions","description":"## Context\nTasks with acceptance criteria should be verified before marking done.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Parse markdown checkboxes from task description.\n\n## Implementation Steps\n1. Implement parse_acceptance_criteria(description) in tasks.sh\n2. Look for markdown checklist items: '- [ ]' or '- [x]'\n3. Extract criteria text\n4. Implement verify_acceptance_criteria(task_id)\n5. Run verification commands if criteria specify them\n6. Mark task done only if criteria pass\n\n## Acceptance Criteria\n- [ ] Checkbox items extracted from descriptions\n- [ ] Verification attempted for parseable criteria\n- [ ] Task not marked done if criteria fail\n- [ ] Tasks without criteria use default behavior\n- [ ] Criteria results logged\n\n## Files Likely Involved\n- lib/tasks.sh\n- curb (main loop integration)\n\n## Notes\nStart simple - match '- [ ]' patterns. Complex verification in future.","status":"open","priority":2,"issue_type":"task","labels":["phase-6","model:sonnet","complexity:medium","logic"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-043","type":"blocks"}]}
{"id":"curb-048","title":"Update UPGRADING.md with migration guide for subcommands","description":"## Context\nMigration guide helps users transition from flag-based to subcommand CLI.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 25m\n**Approach:** Document old vs new syntax, explain deprecation timeline.\n\n## Implementation Steps\n1. Create or update UPGRADING.md\n2. Document flag to subcommand mapping:\n   - curb --status  curb status\n   - curb-init  curb init\n   - etc.\n3. Explain deprecation warnings\n4. Explain how to suppress warnings if needed\n5. Provide timeline for flag removal (if planned)\n6. Include examples for common workflows\n\n## Acceptance Criteria\n- [ ] UPGRADING.md exists with migration guide\n- [ ] All deprecated flags documented\n- [ ] New syntax examples provided\n- [ ] Deprecation timeline explained\n- [ ] Clear and helpful tone\n\n## Files Likely Involved\n- UPGRADING.md\n\n## Notes\nBe welcoming - users shouldn't feel bad about using old syntax.","status":"open","priority":2,"issue_type":"task","labels":["phase-6","model:haiku","complexity:low","docs"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-020","type":"blocks"}]}
{"id":"curb-049","title":"Update README.md with new commands and features","description":"## Context\nREADME needs to reflect the new 1.0 features and commands.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 30m\n**Approach:** Update existing sections, add new feature documentation.\n\n## Implementation Steps\n1. Update CLI usage section with subcommands\n2. Document artifact bundle system\n3. Document session naming (--name flag)\n4. Document git workflow (branch per run, commit per task)\n5. Document guardrails (iteration limits, secret redaction)\n6. Document failure handling modes\n7. Update examples throughout\n\n## Acceptance Criteria\n- [ ] CLI section shows subcommands\n- [ ] New features documented\n- [ ] Examples updated\n- [ ] Version reflects 1.0\n- [ ] Links and references accurate\n\n## Files Likely Involved\n- README.md\n\n## Notes\nKeep README focused on getting started. Details in CONFIG.md.","status":"open","priority":2,"issue_type":"task","labels":["phase-6","model:haiku","complexity:low","docs"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-048","type":"blocks"}]}
{"id":"curb-050","title":"Integrate beads assignee with session name","description":"## Context\nSetting beads assignee to session name enables tracking which curb instance claimed each task.\n\n## Implementation Hints\n\n**Recommended Model:** haiku\n**Estimated Duration:** 20m\n**Approach:** Call bd update --assignee when claiming tasks.\n\n## Implementation Steps\n1. In tasks.sh task_claim function, check if using beads backend\n2. If beads, call: bd update <task-id> --assignee <session-name>\n3. Get session name from session_get_name()\n4. Handle beads not available gracefully\n5. Log assignee setting\n\n## Acceptance Criteria\n- [ ] Beads tasks get assignee set to session name\n- [ ] Works only when using beads backend\n- [ ] Graceful handling if beads unavailable\n- [ ] Assignee visible in bd show output\n\n## Files Likely Involved\n- lib/tasks.sh\n- lib/beads.sh\n- lib/session.sh\n\n## Notes\nOnly applies to beads backend, not prd.json.","status":"open","priority":1,"issue_type":"task","labels":["phase-6","model:haiku","complexity:low","logic"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-002","type":"blocks"}]}
{"id":"curb-051","title":"Final integration test pass","description":"## Context\nFull end-to-end testing before 1.0 release.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 30m\n**Approach:** Run all tests, manual E2E testing, verify all features.\n\n## Implementation Steps\n1. Run full BATS test suite\n2. Run E2E tests in tests/e2e/\n3. Manual test: curb init  curb run  curb status  curb explain\n4. Verify artifacts generated correctly\n5. Verify git workflow (branch, commits)\n6. Verify guardrails work\n7. Verify failure handling\n8. Test with both beads and prd.json backends\n\n## Acceptance Criteria\n- [ ] All automated tests pass\n- [ ] E2E workflow completes successfully\n- [ ] All new features work correctly\n- [ ] No regressions from previous version\n- [ ] Documentation matches behavior\n\n## Files Likely Involved\n- All project files\n\n## Notes\nThis is the pre-release validation pass.","status":"open","priority":1,"issue_type":"task","labels":["phase-6","model:sonnet","complexity:medium","test"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-049","type":"blocks"}]}
{"id":"curb-052","title":"CHECKPOINT: 1.0 release validation","description":"## Context\nFinal checkpoint before declaring 1.0 release ready.\n\n## Implementation Hints\n\n**Recommended Model:** sonnet\n**Estimated Duration:** 25m\n**Approach:** Final review of all requirements and quality.\n\n## Implementation Steps\n1. Review triage requirements - all P0 complete?\n2. Review architecture - all components implemented?\n3. All checkpoints passed?\n4. Documentation complete and accurate?\n5. UPGRADING.md ready for existing users?\n6. Version number updated to 1.0.0?\n7. Create release notes\n8. Tag release\n\n## Acceptance Criteria\n- [ ] All P0 requirements implemented\n- [ ] All P1 requirements implemented (or documented as deferred)\n- [ ] All tests pass\n- [ ] Documentation complete\n- [ ] Ready for public release\n\n## Files Likely Involved\n- All project files\n\n## Notes\nFinal 1.0 checkpoint. Congratulations on reaching this milestone!","status":"open","priority":0,"issue_type":"task","labels":["phase-6","model:sonnet","complexity:medium","checkpoint"],"dependencies":[{"depends_on_id":"curb-E06","type":"parent-child"},{"depends_on_id":"curb-051","type":"blocks"}]}
