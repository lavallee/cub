#!/usr/bin/env bash
#
# cub - Claude Under Ralph + Beads
#
# Autonomous AI coding agent harness that drives Claude Code in a loop
# to build software from a prd.json backlog with beads-style task tracking.
#
# Usage:
#   cub              # Run loop until all tasks complete
#   cub --once       # Run single iteration
#   cub --status     # Show current task status
#   cub --ready      # Show ready tasks
#   cub --plan       # Run in planning mode (generate fix_plan.md)
#   cub --budget 1000000  # Set token budget for run
#   cub --debug      # Enable debug logging (can combine with other flags)
#
set -euo pipefail

# Error trap for debugging - logs where script crashes due to set -e
_error_trap() {
    local exit_code=$?
    local line_no=$1
    echo "[ERROR] Script exited at line ${line_no} with exit code ${exit_code}" >&2
    # Also log to structured logger if available
    if type log_error &>/dev/null && [[ -n "$(logger_get_file 2>/dev/null)" ]]; then
        log_error "Script crashed" "{\"line\": ${line_no}, \"exit_code\": ${exit_code}}"
    fi
}
trap '_error_trap ${LINENO}' ERR

# Version information
CUB_VERSION="0.25.1"

# Resolve symlinks to find the real installation directory
_resolve_symlink() {
    local path="$1"
    while [[ -L "$path" ]]; do
        local dir="$(cd "$(dirname "$path")" && pwd)"
        path="$(readlink "$path")"
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$path"
}
CUB_DIR="$(cd "$(dirname "$(_resolve_symlink "${BASH_SOURCE[0]}")")" && pwd)"
PROJECT_DIR="${CUB_PROJECT_DIR:-$(pwd)}"

# Source task management library
source "${CUB_DIR}/lib/tasks.sh"
# Source layout detection (new vs legacy file organization)
source "${CUB_DIR}/lib/layout.sh"
# Source harness abstraction layer
source "${CUB_DIR}/lib/harness.sh"
# Source XDG directory helpers
source "${CUB_DIR}/lib/xdg.sh"
# Source configuration management
source "${CUB_DIR}/lib/config.sh"
# Source logger
source "${CUB_DIR}/lib/logger.sh"
# Source git operations
source "${CUB_DIR}/lib/git.sh"
# Source state verification
source "${CUB_DIR}/lib/state.sh"
# Source budget tracking
source "${CUB_DIR}/lib/budget.sh"
# Source hooks framework
source "${CUB_DIR}/lib/hooks.sh"
# Source session management
source "${CUB_DIR}/lib/session.sh"
# Source artifacts management
source "${CUB_DIR}/lib/artifacts.sh"
# Source failure handling
source "${CUB_DIR}/lib/failure.sh"
# Source project checks
source "${CUB_DIR}/lib/project.sh"
# Source guardrails (institutional memory)
source "${CUB_DIR}/lib/guardrails.sh"
# Source command implementations
source "${CUB_DIR}/lib/cmd_guardrails.sh"
source "${CUB_DIR}/lib/cmd_init.sh"
source "${CUB_DIR}/lib/cmd_explain.sh"
source "${CUB_DIR}/lib/cmd_artifacts.sh"
source "${CUB_DIR}/lib/cmd_agent.sh"
source "${CUB_DIR}/lib/cmd_doctor.sh"
source "${CUB_DIR}/lib/cmd_prep.sh"
source "${CUB_DIR}/lib/cmd_interview.sh"
source "${CUB_DIR}/lib/cmd_import.sh"
# Source branch management (v0.19)
source "${CUB_DIR}/lib/branches.sh"
source "${CUB_DIR}/lib/cmd_branch.sh"
# Source checkpoint management (v0.19)
source "${CUB_DIR}/lib/checkpoints.sh"
source "${CUB_DIR}/lib/cmd_checkpoint.sh"
# PR management (v0.19) - now handled by Python CLI (cub pr, cub merge)

# Load configuration early
config_load

# Version subcommand
cmd_version() {
    echo "cub v${CUB_VERSION}"
    return 0
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Debug mode (set via --debug flag)
DEBUG="${CUB_DEBUG:-false}"
# Stream mode (set via --stream flag)
STREAM="${CUB_STREAM:-false}"
# Backend mode (set via --backend flag or CUB_BACKEND env)
# Values: "auto", "beads", "json"
BACKEND="${CUB_BACKEND:-auto}"
# Harness (set via --harness flag, HARNESS env, or config file)
# Values: "auto", "claude", "codex", "opencode", "gemini"
# Priority: CLI flag > env var > config harness.priority > default (claude > opencode > codex > gemini)
HARNESS="${HARNESS:-$(config_get_or "harness.default" "auto")}"
# Model (set via --model flag or CUB_MODEL env)
# Values: "opus", "sonnet", "haiku" (only applies to claude harness)
MODEL="${CUB_MODEL:-}"
# Epic filter (set via --epic flag or CUB_EPIC env)
EPIC="${CUB_EPIC:-}"
# Label filter (set via --label flag or CUB_LABEL env)
LABEL="${CUB_LABEL:-}"
# Budget (set via --budget flag, CUB_BUDGET env, or config file)
BUDGET="${CUB_BUDGET:-}"
# Require clean state (set via --require-clean flag or config)
# Empty means use config default, "true"/"false" overrides config
REQUIRE_CLEAN="${CUB_REQUIRE_CLEAN:-}"
# Session name (set via --name flag or CUB_SESSION_NAME env)
SESSION_NAME="${CUB_SESSION_NAME:-}"
# Push flag (set via --push flag)
# Values: "true" or "false"
PUSH="${CUB_PUSH:-false}"

log_info() { echo -e "${BLUE}[cub]${NC} $1"; }
log_success() { echo -e "${GREEN}[cub]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[cub]${NC} $1"; }
_log_error_console() { echo -e "${RED}[cub]${NC} $1" >&2; }
log_debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${DIM}${CYAN}[debug]${NC}${DIM} $1${NC}" >&2
    fi
}

# Deprecation warning helper
warn_deprecated_flag() {
    local old_flag="$1"
    local new_syntax="$2"

    # Check if deprecation warnings are suppressed
    if [[ "${CUB_NO_DEPRECATION_WARNINGS:-}" == "1" ]]; then
        return 0
    fi

    echo -e "${YELLOW}[cub]${NC} Warning: ${old_flag} is deprecated, use: ${new_syntax}" >&2
}

# Main entry point
main() {
    # Parse global flags (affect entire system) and separate run-specific flags
    local args=()
    for arg in "$@"; do
        if [[ "$arg" == "--debug" || "$arg" == "-d" ]]; then
            DEBUG="true"
            log_debug "Debug mode enabled"
            log_debug "CUB_DIR=${CUB_DIR}"
            log_debug "PROJECT_DIR=${PROJECT_DIR}"
            log_debug "Shell: $SHELL (bash ${BASH_VERSION})"
            log_debug "Date: $(date)"
        elif [[ "$arg" == "--stream" ]]; then
            STREAM="true"
            log_info "Stream mode enabled - showing harness activity"
        elif [[ "$arg" == "--backend="* ]]; then
            BACKEND="${arg#--backend=}"
            export CUB_BACKEND="$BACKEND"
        elif [[ "$arg" == "--backend" ]]; then
            # Next arg is the backend value - handle in next iteration
            _next_is_backend=true
            continue
        elif [[ "${_next_is_backend:-}" == "true" ]]; then
            BACKEND="$arg"
            export CUB_BACKEND="$BACKEND"
            _next_is_backend=false
        elif [[ "$arg" == "--harness="* ]]; then
            HARNESS="${arg#--harness=}"
            export HARNESS
        elif [[ "$arg" == "--harness" ]]; then
            # Next arg is the harness value - handle in next iteration
            _next_is_harness=true
            continue
        elif [[ "${_next_is_harness:-}" == "true" ]]; then
            HARNESS="$arg"
            export HARNESS
            _next_is_harness=false
        else
            # Pass all other args through (including run-specific flags)
            args+=("$arg")
        fi
    done
    unset _next_is_backend
    unset _next_is_harness

    check_deps
    log_debug "Dependencies checked: jq and harness found"

    # Subcommand dispatcher (check for subcommands before legacy flags)
    # Process first non-flag argument as potential subcommand
    local first_arg="${args[0]:-}"

    # Check if first arg is a subcommand (not a flag)
    if [[ -n "$first_arg" && ! "$first_arg" =~ ^- ]]; then
        case "$first_arg" in
            init)
                # Pass remaining args to cmd_init
                cmd_init "${args[@]:1}"
                return $?
                ;;
            explain-task)
                # Explain a task or session
                cmd_explain "${args[@]:1}"
                return $?
                ;;
            artifacts)
                # Manage artifacts
                cmd_artifacts "${args[@]:1}"
                return $?
                ;;
            close-task)
                # Close a task (agent helper command)
                cmd_agent_close "${args[@]:1}"
                return $?
                ;;
            verify-task)
                # Verify a task is closed (agent helper command)
                cmd_agent_verify "${args[@]:1}"
                return $?
                ;;
            doctor)
                # Diagnose and fix common issues
                cmd_doctor "${args[@]:1}"
                return $?
                ;;
            # Vision-to-Tasks Prep commands (v0.14)
            prep)
                # Run full vision-to-tasks prep pipeline
                cmd_prep "${args[@]:1}"
                return $?
                ;;
            triage)
                # Stage 1: Requirements refinement
                cmd_triage "${args[@]:1}"
                return $?
                ;;
            architect)
                # Stage 2: Technical design
                cmd_architect "${args[@]:1}"
                return $?
                ;;
            plan)
                # Stage 3: Task decomposition
                cmd_plan "${args[@]:1}"
                return $?
                ;;
            bootstrap)
                # Stage 4: Initialize beads from plan
                cmd_bootstrap "${args[@]:1}"
                return $?
                ;;
            sessions)
                # Manage prep sessions
                cmd_sessions "${args[@]:1}"
                return $?
                ;;
            validate)
                # Validate beads state
                cmd_validate "${args[@]:1}"
                return $?
                ;;
            interview)
                # Interview mode: Deep questioning for task specs
                cmd_interview "${args[@]:1}"
                return $?
                ;;
            import)
                # Import requirements from GitHub, Markdown, JSON, etc.
                cmd_import "${args[@]:1}"
                return $?
                ;;
            # Branch management commands (v0.19)
            branch)
                # Create/bind a branch to an epic
                cmd_branch "${args[@]:1}"
                return $?
                ;;
            branches)
                # List and manage branch bindings
                cmd_branches "${args[@]:1}"
                return $?
                ;;
            checkpoints)
                # List and manage checkpoints
                cmd_checkpoints "${args[@]:1}"
                return $?
                ;;
            # pr command is now handled by Python CLI (cub pr, cub merge)
            guardrails)
                # Manage institutional memory
                cmd_guardrails "${args[@]:1}"
                return $?
                ;;
            version)
                # Show version
                cmd_version
                return $?
                ;;
            help)
                # Show help (fall through to --help handling below)
                args=("--help")
                ;;
            *)
                # Unknown subcommand - show error and help
                # (only show error for non-flag arguments)
                if [[ ! "$first_arg" =~ ^- ]]; then
                    _log_error_console "Unknown subcommand: ${first_arg}"
                    echo ""
                    args=("--help")
                fi
                ;;
        esac
    fi

    # Legacy flag parsing (for backwards compatibility)
    # Note: run, status, upgrade are now Python-native - these cases redirect to Python CLI
    case "${args[0]:-}" in
        --status|-s)
            _log_error_console "Please use 'cub status' instead"
            return 1
            ;;
        --ready|-r)
            _log_error_console "Please use 'cub run --ready' instead"
            return 1
            ;;
        --once|-1)
            _log_error_console "Please use 'cub run --once' instead"
            return 1
            ;;
        --plan|-p)
            _log_error_console "Please use 'cub run --plan' instead"
            return 1
            ;;
        --test|-t)
            log_info "Testing Claude Code invocation..."
            log_debug "Binary: $(which claude)"
            log_debug "Version: $(claude --version 2>&1)"
            echo ""
            log_info "Test 1: Simple echo pipe"
            log_debug "Command: echo 'Say hello' | claude -p"
            if echo "Say hello" | claude -p; then
                log_success "Test 1 passed"
            else
                _log_error_console "Test 1 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 2: Heredoc pipe"
            log_debug "Command: claude -p <<< 'Say goodbye'"
            if claude -p <<< "Say goodbye"; then
                log_success "Test 2 passed"
            else
                _log_error_console "Test 2 failed (exit: $?)"
            fi
            echo ""
            log_info "Test 3: Multi-line prompt"
            local test_prompt="You are a helpful assistant.

Say 'cub test successful' and nothing else."
            log_debug "Command: echo \"\$test_prompt\" | claude -p"
            if echo "$test_prompt" | claude -p; then
                log_success "Test 3 passed"
            else
                _log_error_console "Test 3 failed (exit: $?)"
            fi
            echo ""
            log_success "All tests complete"
            ;;
        --migrate-to-beads)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "Migrating from prd.json to beads..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "false"
            ;;
        --migrate-to-beads-dry-run)
            if [[ ! -f "${PROJECT_DIR}/prd.json" ]]; then
                _log_error_console "No prd.json found to migrate"
                exit 1
            fi
            log_info "DRY RUN: Showing what would be migrated..."
            echo ""
            migrate_json_to_beads "${PROJECT_DIR}/prd.json" "true"
            ;;
        --dump-prompt)
            validate_project
            local prd="${PROJECT_DIR}/prd.json"
            local current_task
            current_task=$(get_in_progress_task "$prd")
            if [[ -z "$current_task" || "$current_task" == "null" ]]; then
                current_task=$(get_ready_tasks "$prd" | jq 'first')
            fi
            if [[ "$current_task" == "null" || -z "$current_task" ]]; then
                _log_error_console "No tasks available"
                exit 1
            fi
            local sys_file="${PROJECT_DIR}/cub_system_prompt.txt"
            local task_file="${PROJECT_DIR}/cub_task_prompt.txt"
            generate_system_prompt > "$sys_file"
            generate_task_prompt "$current_task" > "$task_file"
            log_success "Prompts dumped:"
            log_info "  System: ${sys_file} ($(wc -c < "$sys_file") bytes)"
            log_info "  Task:   ${task_file} ($(wc -c < "$task_file") bytes)"
            log_info ""
            log_info "To test manually:"
            log_info "  claude -p --append-system-prompt \"\$(cat ${sys_file})\" < ${task_file}"
            ;;
        --help|-h)
            cat <<EOF
cub v${CUB_VERSION} - Claude Under Ralph + Beads

Autonomous AI coding agent that drives harnesses in a loop to complete
tasks from a project backlog.

SUBCOMMANDS:
  cub init [--global] [<dir>]  Initialize project or system
  cub run [<options>]           Run the main loop (default)
  cub status [--json]           Show task progress
  cub explain-task <task-id>    Show task details
  cub artifacts [<task-id>]     List task outputs
  cub close-task <task-id>      Close a task (for agent use)
  cub verify-task <task-id>     Verify task is closed
  cub doctor [--fix]            Diagnose and fix issues
  cub guardrails show           Display institutional memory
  cub upgrade [--head|--local]  Upgrade cub to newer version
  cub version                   Show version

VISION-TO-TASKS PREP (v0.14):
  cub prep [VISION.md]          Run full prep (triage→architect→plan→bootstrap)
  cub triage [VISION.md]        Stage 1: Requirements refinement
  cub architect [SESSION]       Stage 2: Technical design
  cub plan [SESSION]            Stage 3: Task decomposition
  cub bootstrap [SESSION]       Stage 4: Initialize beads
  cub sessions                  List/manage prep sessions
  cub validate                  Validate beads state

INTERVIEW MODE (v0.16):
  cub interview <task-id>       Deep dive on task specifications
  cub interview <task-id> --auto   AI-generated answers

QUICK START:
  cub init                      Initialize in current directory
  cub run                       Start the main loop
  cub status                    Check progress
  cub run --ready               List tasks to work on

USE --help WITH ANY SUBCOMMAND:
  cub init --help               Init subcommand help
  cub run --help                Run subcommand help
  cub status --help             Status subcommand help
  cub explain-task --help       Explain-task subcommand help
  cub artifacts --help          Artifacts subcommand help
  cub upgrade --help            Upgrade subcommand help

EXECUTION MODES:
  cub                           Run continuous loop
  cub run --once                Single iteration then exit
  cub run --ready               List ready tasks
  cub run --plan                Analyze code and plan

CORE FLAGS (work with run):
  --harness <name>               Use specific harness (auto, claude, codex,
                                 gemini, opencode)
  --model <name>                 Claude model (opus, sonnet, haiku)
  --budget <tokens>              Set token budget (e.g., 1000000)
  --name <name>                  Session name for tracking

FILTERING:
  --epic <id>                    Work on tasks in epic
  --label <name>                 Work on tasks with label

RELIABILITY:
  --require-clean                Enforce clean git state
  --no-require-clean             Disable clean state check

DEBUGGING:
  --debug, -d                    Show detailed logs
  --stream                       Stream harness output
  --backend <mode>               Task backend (auto, beads, json)

UTILITY:
  --test                         Test harness invocation
  --dump-prompt                  Export task prompts
  --migrate-to-beads             Convert prd.json to beads
  --migrate-to-beads-dry-run     Preview migration

EXAMPLES:
  cub                           Start main loop
  cub run --once                Single iteration
  cub status                    Show progress
  cub run --ready               List tasks
  cub run --epic backend-v2     Work on epic
  cub run --once --debug        Debug one iteration
  cub run --model sonnet        Use Sonnet model
  cub artifacts cub-018         Get task output
  cub explain-task cub-018      See task details
  cub init ~/my-project         Initialize project
  cub init --global             Setup system config

ENVIRONMENT VARIABLES:
  CUB_PROJECT_DIR               Project directory (default: pwd)
  CUB_MAX_ITERATIONS            Max loop iterations (default: 100)
  CUB_DEBUG                     Set to "true" for debug
  CUB_BACKEND                   Task backend (auto/beads/json)
  CUB_BUDGET                    Token budget
  CUB_REQUIRE_CLEAN             Clean state enforcement
  HARNESS                        Harness to use
  CUB_MODEL                     Claude model
  CUB_EPIC                      Epic filter
  CUB_LABEL                     Label filter

PROJECT FILES:
  prd.json                       Task backlog (json backend)
  .beads/                        Task tracking (beads backend)
  .cub/
    ├── prompt.md                System prompt template
    ├── agent.md                 Build/run instructions
    ├── progress.txt             Progress log
    ├── fix_plan.md              Issue tracking
    ├── progress.md              Beads progress tracking
    ├── sessions/                Pipeline session artifacts
    └── runs/                    Execution runs
  specs/                         Specification files

LEARN MORE:
  README.md                      Overview and features
  CONFIG.md                      Configuration options
  CONTRIBUTING.md                Development guidelines

INSTALLATION:
  Beads (optional):
    brew install steveyegge/beads/bd
    npm install -g @beads/bd
    go install github.com/steveyegge/beads/cmd/bd@latest
EOF
            ;;
        --version)
            echo "cub v${CUB_VERSION}"
            ;;
        *)
            # Unrecognized command - bash script should only be called for delegated commands
            _log_error_console "Unknown command: ${args[0]:-}"
            _log_error_console "Use 'cub --help' for available commands"
            return 1
            ;;
    esac
}

main "$@"
