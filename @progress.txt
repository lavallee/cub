
## Task cub-j1a.2: Implement core CRUD methods (2026-01-26)

**Status:** Completed

**Key Learnings:**

1. **Implementation Already Complete**: The JsonlBackend implementation was already fully complete with all core CRUD methods (list_tasks, get_task, create_task, update_task, close_task) matching the TaskBackend protocol exactly. The task description indicated new implementation was needed, but the code was already there.

2. **Backend Registration**: The jsonl backend was registered with `@register_backend("jsonl")` decorator but was missing from the import list in `src/cub/core/tasks/__init__.py`. Adding `jsonl` to the import list made the backend discoverable via `list_backends()`.

3. **Helper Method Pattern**: The `_get_prefix()` helper method (not `_generate_task_id()`) provides project-specific prefixes using the first 3 characters of the project directory name, defaulting to "cub" if too short.

4. **JSONL Storage Format**: The JsonlBackend uses beads-compatible JSONL format where each line is a complete JSON object representing one task. This differs from JsonBackend which stores all tasks in a single JSON array.

5. **Atomic Writes**: Both backends use the same atomic write pattern (temp file + rename) to prevent corruption on write failures, ensuring data integrity.

6. **Timestamp Management**: All update operations (create_task, update_task, close_task) properly set `updated_at` timestamp. The close_task method additionally sets `closed_at` and optionally adds a reason to the notes field.

7. **Caching Strategy**: The JSONL backend implements file caching with mtime-based invalidation, identical to the JSON backend's approach.

8. **Test Coverage**: No new tests were needed as the implementation already passes all existing backend tests. The JsonBackend tests serve as a template for how JSONL tests should work.

**Outcome:** Successfully verified all CRUD methods are implemented, registered the backend for discoverability, fixed minor lint issue in unrelated file. All 76 tests passing, type checking clean.

## Task cub-j1a.3: Implement dependency-aware and utility methods (2026-01-26)

**Status:** Completed

**Key Learnings:**

1. **Implementation Already Complete**: Similar to cub-j1a.2, all dependency-aware and utility methods were already fully implemented in the JsonlBackend class. The methods `get_ready_tasks`, `get_task_counts`, `add_task_note`, and `import_tasks` were all present and working correctly.

2. **Dependency Resolution Algorithm**: The `get_ready_tasks` method implements a two-pass algorithm:
   - First pass: Build a set of closed task IDs for O(1) lookup
   - Second pass: Filter open tasks where all dependencies are in the closed set
   This is more efficient than nested loops for dependency checking.

3. **Priority Sorting**: Ready tasks are sorted using `priority_numeric` computed field (0=highest priority). The sort is stable and consistent across all task backends.

4. **Import with ID Preservation**: The `import_tasks` method correctly preserves explicit task IDs while generating new IDs only for tasks without IDs. This is critical for staging plans where task IDs are pre-defined and dependencies reference specific IDs.

5. **Timestamp in Notes**: The `add_task_note` method automatically prepends timestamps in ISO format to each note, making the notes field act as an audit log. This matches the pattern used in `close_task` when adding reasons.

6. **Task Counts Efficiency**: The `get_task_counts` method iterates raw task dicts rather than parsing into Task models for better performance, since it only needs the status field.

7. **Comprehensive Testing**: All methods were validated with:
   - Type checking (mypy): no issues
   - Unit tests (pytest): 493 passed, covering all task backend methods
   - Manual functional test: verified dependency chains, priority sorting, and ID preservation

8. **Epic Closure Support**: The `try_close_epic` method (also already implemented) checks both parent relationships and label-based associations, providing flexible epic-task organization.

**Outcome:** Successfully verified all dependency-aware and utility methods work correctly with complex dependency graphs, proper priority sorting, and ID preservation. Ready for integration with `cub run`.
